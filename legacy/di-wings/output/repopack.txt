This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repopack on: 2024-10-02T07:45:31.731Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
.github/
  workflows/
    npm-publish.yml
    pr-testing.yml
examples/
  bun/
    .gitignore
    index.ts
    package.json
    README.md
src/
  lib/
    common/
      errors.ts
      interfaces.ts
      utils.ts
    crypto/
      JWE/
        DecryptTransformer.ts
        ecdhkdf.ts
        EncryptTransformer.ts
        KeyEncryptionKey.ts
        Suite.ts
        xc20p.ts
      JWS/
        createSigner.ts
        createVerifier.ts
        Suite.ts
      JWT/
        Suite.ts
      keypairs/
        BaseKeyPair.ts
        Ed25519VerificationKey2018.ts
        Ed25519VerificationKey2020.ts
        HD.ts
        JsonWebKey2020.ts
        Multikey.ts
        Secp256k1KeyPair.ts
        X25519KeyAgreementKey2019.ts
        X25519KeyAgreementKey2020.ts
      LDP/
        proof.ts
      utils/
        encoding.ts
        sha256.ts
        staticImplements.ts
        vcs.ts
      constants.ts
      index.ts
      mnemonic.ts
    dids/
      DIDDocument.ts
      DIDResolver.ts
      index.ts
      Secret.ts
      SecretResolver.ts
    vcs/
      canon.ts
      index.ts
      issue.ts
      jwt.ts
      present.ts
      validation.ts
      verify.ts
  tests/
    fixtures/
      credentials/
        case-1.json
        case-10.json
        case-2.json
      crypto/
        contexts/
          credentials-examples.json
          credentials.json
          dids.json
          ed255192020.json
          jws2020.json
          odrl.json
          vaccination.json
        didDocuments/
          ed255192020.json
        proofs/
          case-1.json
          case-2.json
          with-challenge-and-domain.json
        controller.json
        documentLoader.ts
        HD.json
        jwe.json
        jws.json
        mnemonic.json
        plaintext.json
      keypairs/
        case-2.json
        EcdsaSecp256k1VerificationKey2019.json
        Ed25519VerificationKey2018.json
        Ed25519VerificationKey2020.json
        JsonWebKey2020.json
        X25519KeyAgreementKey2019.json
        X25519KeyAgreementKey2020.json
      presentations/
        case-10.json
      verifiableCredentials/
        case-10.json
      verifiablePresentations/
        case-10.json
    mocks/
      MockSignatureSuite.ts
    unit/
      crypto/
        Ed25519VerificationKey2018.test.ts
        Ed25519VerificationKey2020.test.ts
        HD.test.ts
        JsonWebKey2020.test.ts
        JWE.test.ts
        JWS.test.ts
        JWT.test.ts
        mnemonic.test.ts
        Multikey.test.ts
        Secp256k1KeyPair.test.ts
        X25519KeyAgreementKey2019.test.ts
        X25519KeyAgreementKey2020.test.ts
      dids/
        did-document-verification-method.test.ts
        did-document.test.ts
        did-resolver.test.ts
        secret-resolver.test.ts
        secret.test.ts
      vcs/
        issue-and-verify.test.ts
        issuer.test.ts
        jwt.test.ts
        presentation.test.ts
        validation.test.ts
        verifier.test.ts
  global.d.ts
  index.ts
.gitignore
.releaserc.json
CHANGELOG.md
package.json
README.md
tsconfig.json

================================================================
Repository Files
================================================================

================
File: .github/workflows/npm-publish.yml
================
name: NPM Package Publish

on:
  push:
    branches:
      - master

jobs:
  publish:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          fetch-depth: 0
          persist-credentials: false

      - name: Setup Bun
        uses: oven-sh/setup-bun@v1
        with:
          bun-version: latest

      - name: Install dependencies
        run: bun install

      - name: Run tests
        run: bun test

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '20'
          registry-url: 'https://registry.npmjs.org'

      - name: Semantic Release
        env:
          GITHUB_TOKEN: ${{ secrets.GH_TOKEN }}
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}
        run: npx semantic-release

  generate-docs:
    needs: publish
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Setup Bun
        uses: oven-sh/setup-bun@v1
        with:
          bun-version: latest

      - name: Install dependencies
        run: bun install

      - name: Generate documentation
        run: bun run docs

      - name: Upload documentation artifact
        uses: actions/upload-artifact@v3
        with:
          name: documentation
          path: docs/

      # Uncomment the following steps when you're ready to deploy the docs site
      # - name: Deploy documentation to GitHub Pages
      #   uses: peaceiris/actions-gh-pages@v3
      #   with:
      #     github_token: ${{ secrets.GITHUB_TOKEN }}
      #     publish_dir: ./docs

================
File: .github/workflows/pr-testing.yml
================
name: Pull Request Checks

on:
  pull_request:
    types: [opened, synchronize, reopened]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Setup Bun
        uses: oven-sh/setup-bun@v1
        with:
          bun-version: latest

      - name: Install dependencies
        run: bun install

      - name: Run tests
        run: bun test

      - name: Upload test results
        uses: actions/upload-artifact@v3
        with:
          name: test-results
          path: output/test-log.txt

================
File: examples/bun/.gitignore
================
# Based on https://raw.githubusercontent.com/github/gitignore/main/Node.gitignore

# Logs

logs
_.log
npm-debug.log_
yarn-debug.log*
yarn-error.log*
lerna-debug.log*
.pnpm-debug.log*

# Caches

.cache

# Diagnostic reports (https://nodejs.org/api/report.html)

report.[0-9]_.[0-9]_.[0-9]_.[0-9]_.json

# Runtime data

pids
_.pid
_.seed
*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover

lib-cov

# Coverage directory used by tools like istanbul

coverage
*.lcov

# nyc test coverage

.nyc_output

# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files)

.grunt

# Bower dependency directory (https://bower.io/)

bower_components

# node-waf configuration

.lock-wscript

# Compiled binary addons (https://nodejs.org/api/addons.html)

build/Release

# Dependency directories

node_modules/
jspm_packages/

# Snowpack dependency directory (https://snowpack.dev/)

web_modules/

# TypeScript cache

*.tsbuildinfo

# Optional npm cache directory

.npm

# Optional eslint cache

.eslintcache

# Optional stylelint cache

.stylelintcache

# Microbundle cache

.rpt2_cache/
.rts2_cache_cjs/
.rts2_cache_es/
.rts2_cache_umd/

# Optional REPL history

.node_repl_history

# Output of 'npm pack'

*.tgz

# Yarn Integrity file

.yarn-integrity

# dotenv environment variable files

.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# parcel-bundler cache (https://parceljs.org/)

.parcel-cache

# Next.js build output

.next
out

# Nuxt.js build / generate output

.nuxt
dist

# Gatsby files

# Comment in the public line in if your project uses Gatsby and not Next.js

# https://nextjs.org/blog/next-9-1#public-directory-support

# public

# vuepress build output

.vuepress/dist

# vuepress v2.x temp and cache directory

.temp

# Docusaurus cache and generated files

.docusaurus

# Serverless directories

.serverless/

# FuseBox cache

.fusebox/

# DynamoDB Local files

.dynamodb/

# TernJS port file

.tern-port

# Stores VSCode versions used for testing VSCode extensions

.vscode-test

# yarn v2

.yarn/cache
.yarn/unplugged
.yarn/build-state.yml
.yarn/install-state.gz
.pnp.*

# IntelliJ based IDEs
.idea

# Finder (MacOS) folder config
.DS_Store

================
File: examples/bun/index.ts
================
// test.ts
import { Ed25519VerificationKey2020, JsonWebSignature2020Suite } from 'di-wings';

async function testDiWings() {
  try {
    const key = await Ed25519VerificationKey2020.generate();
    console.log('Generated key:', key);

    const suite = new JsonWebSignature2020Suite({
      key: await key.export(),
      date: new Date().toISOString()
    });
    console.log('Created suite:', suite);

    console.log('di-wings package imported and used successfully!');
  } catch (error) {
    console.error('Error testing di-wings:', error);
  }
}

testDiWings();

================
File: examples/bun/package.json
================
{
  "name": "di-wings-example-bun",
  "module": "index.ts",
  "type": "module",
  "devDependencies": {
    "@types/bun": "latest"
  },
  "peerDependencies": {
    "typescript": "^5.0.0"
  },
  "dependencies": {
    "di-wings": "^0.1.0"
  }
}

================
File: examples/bun/README.md
================
# di-wings-example-bun

To install dependencies:

```bash
bun install
```

To run:

```bash
bun run index.ts
```

This project was created using `bun init` in bun v1.1.21. [Bun](https://bun.sh) is a fast all-in-one JavaScript runtime.

================
File: src/lib/common/errors.ts
================
export class NotImplementedError extends Error {
  constructor(message: string) {
    super(message);
    Object.setPrototypeOf(this, NotImplementedError.prototype);
  }
}

export class ValidationError extends Error {
  constructor(message: string) {
    super(message);
    Object.setPrototypeOf(this, ValidationError.prototype);
  }
}

================
File: src/lib/common/interfaces.ts
================
import type { JsonWebKey2020, JsonWebKeyPair } from '../crypto/index.js';
import type { Ed25519VerificationKey2018 } from '../crypto/keypairs/Ed25519VerificationKey2018.js';
import type { Ed25519VerificationKey2020 } from '../crypto/keypairs/Ed25519VerificationKey2020.js';
import type { Secp256k1KeyPair } from '../crypto/keypairs/Secp256k1KeyPair.js';
import type { X25519KeyAgreementKey2019 } from '../crypto/keypairs/X25519KeyAgreementKey2019.js';
import type { X25519KeyAgreementKey2020 } from '../crypto/keypairs/X25519KeyAgreementKey2020.js';

export interface JWTPayload {
    iss?: string;
    sub?: string;
    aud?: string;
    exp?: number;
    nbf?: number;
    iat?: number;
    jt?: string;
    [x: string]: any;
}

export interface Header {
	typ?: string;
	alg: string;
	kid: string;
	apu?: string;
	apv?: string;
	epk?: IJWK;
}

export interface IJWE {
	protected: string;
	iv: string;
	ciphertext: string;
	tag: string;
	aad?: string;
	recipients?: { header: Header; encrypted_key: string }[];
}

export interface IJWS {
	header: Header;
	payload: string;
	signature: string;
	protected?: string;
}

export interface IJWK {
	alg?: string;
	crv: string;
	d?: string;
	dp?: string;
	dq?: string;
	e?: string;
	ext?: boolean;
	k?: string;
	key_ops?: string[];
	kid?: string;
	kty: string;
	n?: string;
	oth?: Array<{
		d?: string;
		r?: string;
		t?: string;
	}>;
	p?: string;
	q?: string;
	qi?: string;
	use?: string;
	x?: string;
	y?: string;
	x5c?: string[];
	x5t?: string;
	'x5t#S256'?: string;
	x5u?: string;
	[propName: string]: unknown
}

export type DocumentLoader = (
	uri: string
) => Promise<{ document: any; documentUrl: string; contextUrl: string }>;

export interface LinkedDataSuite {
	type: string;
	date: string;
	context: string;

	createProof: (
		document: any,
		purpose: string,
		documentLoader: DocumentLoader,
		{domain, challenge}: {
			domain?: string,
			challenge?: string
		}
	) => Promise<ILinkedDataProof>;

	verifyProof: (
		proofDocument: ILinkedDataProof,
		document: any,
		documentLoader: DocumentLoader
	) => Promise<VerificationResult>;
}

export type AnyKeyType = Ed25519VerificationKey2020 | Ed25519VerificationKey2018 | X25519KeyAgreementKey2019 | X25519KeyAgreementKey2020 | Secp256k1KeyPair;

export interface VerificationResult {
	verified: boolean;
	/**
	 * The checks performed
	 */
	checks?: Array<string>;
	/**
	 * Warnings
	 */
	warnings?: Array<string>;
	/**
	 * Errors
	 */
	errors?: Array<string>;
}

export interface ProofVerification {
	verified: boolean;
	error: string;
}

export enum IProofPurpose {
  verificationMethod = 'verificationMethod',
  assertionMethod = 'assertionMethod',
  authentication = 'authentication',
  keyAgreement = 'keyAgreement',
  contractAgreement = 'contactAgreement',
  capabilityInvocation = 'capabilityInvocation',
  capabilityDelegation = 'capabilityDelegation',
}

export enum IProofType {
  Ed25519Signature2018 = 'Ed25519Signature2018',
  Ed25519Signature2020 = 'Ed25519Signature2020',
  EcdsaSecp256k1Signature2019 = 'EcdsaSecp256k1Signature2019',
  EcdsaSecp256k1RecoverySignature2020 = 'EcdsaSecp256k1RecoverySignature2020',
  JsonWebSignature2020 = 'JsonWebSignature2020',
  RsaSignature2018 = 'RsaSignature2018',
  GpgSignature2020 = 'GpgSignature2020',
  JcsEd25519Signature2020 = 'JcsEd25519Signature2020',
  BbsBlsSignatureProof2020 = 'BbsBlsSignatureProof2020',
  BbsBlsBoundSignatureProof2020 = 'BbsBlsBoundSignatureProof2020',
}

/**
 * A JSON-LD Linked Data proof.
 */
 export interface ILinkedDataProof {
  type: IProofType | string // The proof type
  created: string // The ISO8601 date-time string for creation
  proofPurpose: IProofPurpose | string // The specific intent for the proof
  verificationMethod: string // A set of parameters required to independently verify the proof
  challenge?: string // A challenge to protect against replay attacks
  domain?: string // A string restricting the (usage of a) proof to the domain and protects against replay attacks
  proofValue?: string // One of any number of valid representations of proof values
  jws?: string // JWS based proof
  nonce?: string // Similar to challenge. A nonce to protect against replay attacks, used in some ZKP proofs
  requiredRevealStatements?: string[] // The parts of the proof that must be revealed in a derived proof
}

export interface JWTCredential {
	/**
	 * The credential subject ID
	 */
	sub?: string;
	/**
	 * The ID of the credential
	 */
	jti?: string;
	/**
	 * The issuer of the credential
	 */
	iss: string;
	/**
	 * The issuance date of the credential (unix timestamp)
	 */
	nbf: number;
	/**
	 * The issuance date of the credential (unix timestamp)
	 */
	iat: number;
	/**
	 * The expiry date of the credential (unix timestamp)
	 */
	exp?: number;
	/**
	 * The nonce included in the signed data payload
	 */
	nonce: string;
	/**
	 * The remaining credential properties
	 */
	vc: {
		'@context': Array<string> | string;
		type: string[];
		credentialSubject: any;
		[k: string]: any;
	};
}

/**
 * A JSON-LD Credential.
 */
export interface Credential {
	/**
	 * The JSON-LD context of the credential.
	 */
	'@context': Array<string> | string;
	/**
	 * The ID of the credential.
	 */
	id?: string;
	/**
	 * The JSON-LD type of the credential.
	 */
	type: string[];
	issuer?: { id: string, name?: string, image?: string, url?: string, type?: string } | string;
	/**
	 * The issuanceDate
	 */
	issuanceDate?: string;
	/**
	 * The expirationDate
	 */
	expirationDate?: string;
	/**
	 * The credential subject
	 */
	credentialSubject: {
		/**
		 * credential subject ID
		 */
		id?: string;
		[k: string]: any;
	};
	/**
	 * The status of the credential
	 */
	credentialStatus?: {
		id: string;
		type: string;
	};

  [x: string]: unknown
}

/**
 * A JSON-LD Presentation.
 */
export interface Presentation {
	/**
	 * The JSON-LD context of the presentation.
	 */
	'@context': Array<string> | string;
	/**
	 * The ID of the presentation.
	 */
	id?: string;
	/**
	 * The JSON-LD type of the presentation.
	 */
	type: string[];
	/**
	 * The Verifiable Credentials included in the presentation
	 */
	verifiableCredential: Array<VerifiableCredential> | VerifiableCredential;

  [x: string]: unknown
}

export interface VerifiablePresentation extends Presentation {
	proof: ILinkedDataProof | Array<ILinkedDataProof>;
}

export interface VerifiableCredential extends Credential {
	proof: ILinkedDataProof | Array<ILinkedDataProof>;
}

export interface LinkedDataKey {
	id: string;
	type: string;
}

export interface ProofVerificationResult {
	verified: boolean;
	error?: string;
}


// export interface SignatureSuite {
//   key?: JsonWebKey | LinkedDataKey;

//   getVerificationMethod: (options: {
//     proof: LinkedDataProof;
//     documentLoader: DocumentLoader;
//   }) => Promise<JsonWebKey | LinkedDataKey>;

//   deriveProof?: (
//     verifiableCredential: VerifiableCredential,
//     frame: object
//   ) => Promise<VerifiableCredential>;

//   createProof: (
//     credential: Credential | JWTCredential,
//     proofPurpose: string,
//     options: { documentLoader: DocumentLoader }
//   ) => Promise<LinkedDataProof>;

//   verifyProof: (
//     proof: LinkedDataProof,
//     verifiableCredential: VerifiableCredential,
//     options: { documentLoader: DocumentLoader }
//   ) => Promise<ProofVerification>;
// }

/**
 * A secret.
 */
export interface ISecret {
  id: string;
  type: string;
  /** The value of the private key in PEM format. Only one value field will be present. */
  privateKeyPem?: string;

  /** The value of the private key in JWK format. Only one value field will be present. */
  privateKeyJwk?: any;

  /** The value of the private key in hex format. Only one value field will be present. */
  privateKeyHex?: string;

  /** The value of the private key in Base64 format. Only one value field will be present. */
  privateKeyBase64?: string;

  /** The value of the private key in Base58 format. Only one value field will be present. */
  privateKeyBase58?: string;

  /** The value of the private key in Multibase format. Only one value field will be present. */
  privateKeyMultibase?: string;

  asJsonWebKey(): Promise<JsonWebKey2020>;
}

export interface ISecretResolver {
  resolve(id: string): Promise<ISecret>;
}

/**
 * A verification method definition entry in a DID Document.
 */
export interface IDIDDocumentVerificationMethod {
  /** Fully qualified identifier of this public key, e.g. did:example:123#key-1 */
  id: string;

  /** The type of this public key, as defined in: https://w3c-ccg.github.io/ld-cryptosuite-registry/ */
  type: string;

  /** The DID of the controller of this key. */
  controller: string;

  /** The value of the public key in PEM format. Only one value field will be present. */
  publicKeyPem?: string;

  /** The value of the public key in JWK format. Only one value field will be present. */
  publicKeyJwk?: IJWK;

  /** The value of the public key in hex format. Only one value field will be present. */
  publicKeyHex?: string;

  /** The value of the public key in Base64 format. Only one value field will be present. */
  publicKeyBase64?: string;

  /** The value of the public key in Base58 format. Only one value field will be present. */
  publicKeyBase58?: string;

  /** The value of the public key in Multibase format. Only one value field will be present. */
  publicKeyMultibase?: string;

  /** Returns the public key in JWK format regardless of the current type */
  asJsonWebKey(): Promise<JsonWebKey2020>;

  toJSON(): object;
}

/**
 * Defines a service descriptor entry present in a DID Document.
 */
export interface IDIDDocumentServiceDescriptor {
  /** id of this service, e.g. `did:example:123#id`. */
  id: string;

  /** The type of this service. */
  type: string;

  /** The endpoint of this service. */
  serviceEndpoint: string | any;

  /** didcomm service extension */
  routingKeys: string[];
}

/**
 * Decentralized Identity Document.
 */
export interface IDIDDocument {
  /** The JSON Document (self) */
  document: object;

  /** The JSON-LD context of the DID Documents. */
  "@context": string[] | string;

  /** The DID to which this DID Document pertains. */
  id: string;

  /** The controller of the DID */
  controller?: string;

  /** This DID is also known as */
  alsoKnownAs?: string;

  /** Array of verification methods associated with the DID. */
  verificationMethod?: IDIDDocumentVerificationMethod[];

  /** Array of services associated with the DID. */
  service?: IDIDDocumentServiceDescriptor[];

  /** Array of authentication methods. */
  authentication?: IDIDDocumentVerificationMethod[];

  /** Array of assertion methods. */
  assertionMethod?: IDIDDocumentVerificationMethod[];

  /** Array of key agreement methods */
  keyAgreement?: IDIDDocumentVerificationMethod[];

  /** Array of capability invocation methods */
  capabilityInvocation?: IDIDDocumentVerificationMethod[];

  /** Array of capability delegation methods */
  capabilityDelegation?: IDIDDocumentVerificationMethod[];

  normalizeVerificationMethod: (
    methods: (string | IDIDDocumentVerificationMethod)[]
  ) => IDIDDocumentVerificationMethod[];
  getVerificationMethodById: (id: string) => IDIDDocumentVerificationMethod | undefined;
  getServiceById: (id: string) => IDIDDocumentServiceDescriptor | undefined;
  getServiceByType: (type: string) => IDIDDocumentServiceDescriptor | undefined;
  getKeyAgreementById: (id: string) => IDIDDocumentVerificationMethod | undefined;
  getAllKeyAgreements: () => IDIDDocumentVerificationMethod[];
  getAuthenticationById: (id: string) => IDIDDocumentVerificationMethod | undefined;
  getCapabilityInvocationById: (id: string) => IDIDDocumentVerificationMethod | undefined;
  getCapabilityDelegationById: (id: string) => IDIDDocumentVerificationMethod | undefined;
  getAssertionMethodById: (id: string) => IDIDDocumentVerificationMethod | undefined;
  toJSON: () => object;
}

export interface IDIDResolver {
  resolve(id: string): Promise<IDIDDocument>;
}

export interface Readable<T> {
  subscribe(run: (value: T) => void, invalidate?: (value?: T) => void): () => void;
}

export interface StartStopNotifier<T> {
  (set: (value: T) => void): (() => void) | void;
}

export declare function readable<T>(
  value?: T,
  start?: StartStopNotifier<T>
): Readable<T>;

================
File: src/lib/common/utils.ts
================
import type { ILinkedDataProof } from "../crypto";

export function isProofArray(proof: ILinkedDataProof | ILinkedDataProof[]): proof is ILinkedDataProof[] {
  return Array.isArray(proof);
}

================
File: src/lib/crypto/JWE/DecryptTransformer.ts
================
/*!
 * Copyright (c) 2019-2020 Digital Bazaar, Inc. All rights reserved.
 */
import { Buffer } from 'buffer/index.js'
import * as cipher from '../JWE/xc20p.js';

import { KeyEncryptionKey } from '../JWE/KeyEncryptionKey.js';
import { stringToUint8Array } from '../utils/sha256.js';

const CIPHER_ALGORITHMS: any = {
	[cipher.JWE_ENC]: cipher
};

export class DecryptTransformer {
	public keyAgreementKey: any;
	public KeyPairClass: any;

	constructor({ keyAgreementKey, KeyPairClass }: any = {}) {
		if (!keyAgreementKey) {
			throw new TypeError('"keyAgreementKey" is a required parameter.');
		}
		this.KeyPairClass = KeyPairClass;
		this.keyAgreementKey = keyAgreementKey;
	}

	async transform(chunk: any, controller: any) {
		// assumes `chunk` is an object with a JWE under the `jwe` property
		if (!(chunk && typeof chunk === 'object')) {
			throw new TypeError('"chunk" must be an object.');
		}
		const { jwe } = chunk;

		const data = await this.decrypt(jwe);
		if (data === null) {
			const error = new Error('Invalid decryption key.');
			error.name = 'DataError';
			throw error;
		}

		controller.enqueue(data);
	}

	async decrypt(jwe: any) {
		// validate JWE
		if (!(jwe && typeof jwe === 'object')) {
			throw new TypeError('"jwe" must be an object.');
		}
		if (typeof jwe.protected !== 'string') {
			throw new TypeError('"jwe.protected" is missing or not a string.');
		}
		if (typeof jwe.iv !== 'string') {
			throw new Error('Invalid or missing "iv".');
		}
		if (typeof jwe.ciphertext !== 'string') {
			throw new Error('Invalid or missing "ciphertext".');
		}
		if (typeof jwe.tag !== 'string') {
			throw new Error('Invalid or missing "tag".');
		}

		// validate encryption header
		let header;
		let additionalData;
		try {
			// ASCII(BASE64URL(UTF8(JWE Protected Header)))
			additionalData = stringToUint8Array(jwe.protected);
			header = JSON.parse(Buffer.from(jwe.protected, 'base64').toString());
		} catch (e) {
			throw new Error('Invalid JWE "protected" header.');
		}
		if (!(header.enc && typeof header.enc === 'string')) {
			throw new Error('Invalid JWE "enc" header.');
		}
		const cipher = CIPHER_ALGORITHMS[header.enc];
		if (!cipher) {
			throw new Error(`Unsupported encryption algorithm "${header.enc}".`);
		}
		if (!Array.isArray(jwe.recipients)) {
			throw new TypeError('"jwe.recipients" must be an array.');
		}

		// find `keyAgreementKey` matching recipient
		const { keyAgreementKey } = this;

		const _findRecipient = (recipients: any, key: any) => {
			return recipients.find(
				(rec: any) =>
					(rec.header && rec.header.kid === key.id) ||
					rec.header.kid.split('#').pop() === key.id.split('#').pop()
			);
		};

		const recipient = _findRecipient(jwe.recipients, keyAgreementKey);

		if (!recipient) {
			throw new Error('No matching recipient found for key agreement key.');
		}
		// get wrapped CEK
		const { encrypted_key: wrappedKey } = recipient;
		if (typeof wrappedKey !== 'string') {
			throw new Error('Invalid or missing "encrypted_key".');
		}

		// TODO: consider a cache of encrypted_key => CEKs to reduce unwrapping
		// calls which may even need to hit the network (e.g., Web KMS)

		// derive KEK and unwrap CEK
		const { epk } = recipient.header;

		const { kek } = await KeyEncryptionKey.fromEphemeralPeer(this.KeyPairClass)({
			keyAgreementKey,
			epk
		});

		const cek = await kek.unwrapKey({ wrappedKey });
		if (!cek) {
			// failed to unwrap key
			return null;
		}

		// decrypt content
		const { ciphertext, iv, tag } = jwe;
		return cipher.decrypt({
			ciphertext: Buffer.from(ciphertext, 'base64'),
			iv: Buffer.from(iv, 'base64'),
			tag: Buffer.from(tag, 'base64'),
			additionalData,
			cek
		});
	}
}

================
File: src/lib/crypto/JWE/ecdhkdf.ts
================
/*!
 * Copyright (c) 2019-2020 Digital Bazaar, Inc. All rights reserved.
 */
import { Buffer } from 'buffer/index.js'
import { sha256Uint8Array } from '../utils/sha256.js';

// only supported algorithm
const KEY_ALGORITHM = 'ECDH-ES+A256KW';

// create static ALGORITHM_ID
const ALGORITHM_CONTENT = KEY_ALGORITHM; //new TextEncoder().encode();
const ALGORITHM_ID = new Uint8Array(4 + ALGORITHM_CONTENT.length);
// write length of content as 32-bit big endian integer, then write content
const dv = new DataView(ALGORITHM_ID.buffer, ALGORITHM_ID.byteOffset, ALGORITHM_ID.byteLength);
dv.setUint32(0, ALGORITHM_CONTENT.length);
ALGORITHM_ID.set(Buffer.from(ALGORITHM_CONTENT), 4);

// RFC 7518 Section 4.6.2 specifies using SHA-256 for ECDH-ES KDF
// https://tools.ietf.org/html/rfc7518#section-4.6.2
const HASH_ALGORITHM = { name: 'SHA-256' };

// derived keys are always 256-bits
const KEY_LENGTH = 256;

/**
 * Derives a 256-bit AES-KW key encryption key from a shared secret that
 * was derived from an ephemeral and static pair
 * of Elliptic Curve Diffie-Hellman keys.
 *
 * The KDF used is described in RFC 7518. This KDF is referenced by RFC 8037,
 * which defines how to perform Curve25519 (X25519) ECDH key agreement.
 *
 * @param {object} options - The options to use.
 * @param {Uint8Array} options.secret - The shared secret (i.e., `Z`) to use.
 * @param {Uint8Array} options.producerInfo - An array of application-specific
 *   bytes describing the consumer (aka the "encrypter" or "sender").
 * @param {Uint8Array} options.consumerInfo - An array of application-specific
 *   bytes describing the producer (aka the "decrypter" or
 *   "receiver"/"recipient").
 *
 * @returns {Promise<Uint8Array>} - Resolves to the generated key.
 */
export async function deriveKey({ secret, producerInfo, consumerInfo }: any) {
	if (!(secret instanceof Uint8Array && secret.length > 0)) {
		throw new TypeError('"secret" must be a non-empty Uint8Array.');
	}

	if (!(producerInfo instanceof Uint8Array && producerInfo.length > 0)) {
		console.warn('producerInfo', producerInfo);
		throw new TypeError('"producerInfo" must be a non-empty Uint8Array.');
	}
	if (!(consumerInfo instanceof Uint8Array && consumerInfo.length > 0)) {
		console.warn('consumerInfo', consumerInfo);
		throw new TypeError('"consumerInfo" must be a non-empty Uint8Array.');
	}

	// the output of Concat KDF is hash(roundNumber || Z || OtherInfo)
	// where roundNumber is always 1 because the hash length is presumed to
	// ...match the key length, encoded as a big endian 32-bit integer
	// where OtherInfo is:
	// AlgorithmID || PartyUInfo || PartyVInfo || SuppPubInfo
	// where SuppPubInfo is the key length in bits, big endian encoded as a
	// 32-bit number, i.e., 256 === [0, 0, 1, 0]
	const input = new Uint8Array(
		4 + // round number
			secret.length + // `Z`
			ALGORITHM_ID.length + // AlgorithmID
			4 +
			producerInfo.length + // PartyUInfo
			4 +
			consumerInfo.length + // PartyVInfo
			4
	); // SuppPubInfo (key data length in bits)
	let offset = 0;
	const dv = new DataView(input.buffer, input.byteOffset, input.byteLength);
	dv.setUint32(offset, 1);
	input.set(secret, (offset += 4));
	input.set(ALGORITHM_ID, (offset += secret.length));
	dv.setUint32((offset += ALGORITHM_ID.length), producerInfo.length);
	input.set(producerInfo, (offset += 4));
	dv.setUint32((offset += producerInfo.length), consumerInfo.length);
	input.set(consumerInfo, (offset += 4));
	dv.setUint32((offset += consumerInfo.length), KEY_LENGTH);

	// hash input and return result as derived key
	return new Uint8Array(sha256Uint8Array(input));
}

================
File: src/lib/crypto/JWE/EncryptTransformer.ts
================
/*!
 * Copyright (c) 2019-2020 Digital Bazaar, Inc. All rights reserved.
 */
import * as cipher from '../JWE/xc20p.js';

import { base64url, utf8 } from '../utils/encoding.js';

const CIPHER_ALGORITHMS: any = {
	[cipher.JWE_ENC]: cipher
};

// 1 MiB = 1048576
const DEFAULT_CHUNK_SIZE = 1048576;

export class EncryptTransformer {
	public recipients: any;
	public encodedProtectedHeader: any;
	public additionalData: any;
	public cek: any;
	public chunkSize: any;
	public offset: any;
	public totalOffset: any;
	public index: any;
	public buffer: any;

	constructor({
		recipients,
		encodedProtectedHeader,
		additionalData,
		cek,
		chunkSize = DEFAULT_CHUNK_SIZE
	}: any = {}) {
		this.recipients = recipients;
		this.encodedProtectedHeader = encodedProtectedHeader;
		this.additionalData = additionalData;
		this.cek = cek;
		this.chunkSize = chunkSize;
		this.offset = 0;
		this.totalOffset = 0;
		this.index = 0;
	}

	start() {
		this.buffer = new Uint8Array(this.chunkSize);
	}

	async transform(chunk: any, controller: any) {
		const { buffer } = this;

		// assumes `chunk` is a Uint8Array...
		if (!(chunk instanceof Uint8Array)) {
			throw new TypeError('"chunk" must be an object.');
		}
		while (chunk) {
			const space = buffer.length - this.offset;
			if (chunk.length <= space) {
				buffer.set(chunk, this.offset);
				this.offset += chunk.byteLength;
				this.totalOffset += chunk.byteLength;
				chunk = null;
			} else {
				const partial = new Uint8Array(chunk.buffer, chunk.byteOffset, space);
				chunk = new Uint8Array(chunk.buffer, chunk.byteOffset + space, chunk.length - space);
				buffer.set(partial, this.offset);
				this.offset += space;
				this.totalOffset += space;
			}

			// flush if buffer is full and more data remains
			if (chunk) {
				await this.flush(controller);
			}
		}
	}

	async flush(controller: any) {
		if (this.offset === 0) {
			// nothing to flush
			return;
		}

		// encrypt data
		const { buffer } = this;
		const data = new Uint8Array(buffer.buffer, buffer.byteOffset, this.offset);
		const jwe = await this.encrypt(data);

		// clear buffer
		this.offset = 0;

		controller.enqueue({
			index: this.index++,
			offset: this.totalOffset,
			jwe
		});
	}

	async encrypt(data: any) {
		const { additionalData, cek, encodedProtectedHeader } = this;
		const protectedHeader = JSON.parse(utf8.decode(base64url.decode(encodedProtectedHeader)))
		const suite = CIPHER_ALGORITHMS[protectedHeader.enc];

		const { ciphertext, iv, tag } = await suite.encrypt({
			data,
			additionalData,
			cek
		});

		// represent encrypted data as JWE
		const jwe = {
			protected: this.encodedProtectedHeader,
			recipients: this.recipients,
			iv: base64url.encode(iv),
			ciphertext: base64url.encode(ciphertext),
			tag: base64url.encode(tag)
		};
		return jwe;
	}
}

================
File: src/lib/crypto/JWE/KeyEncryptionKey.ts
================
import { AESKW } from '@stablelib/aes-kw';
import { X25519KeyAgreementKey2019 } from '../keypairs/X25519KeyAgreementKey2019.js';
import { base64url } from '../utils/encoding.js';
import { deriveKey } from '../JWE/ecdhkdf.js';
import { Buffer } from 'buffer/index.js';

export interface CreateKekOptions {
	keyData: Uint8Array;
}

export interface WrapKeyOptions {
	unwrappedKey: Uint8Array;
}

export interface UnwrapKeyOptions {
	wrappedKey: string; //base64url
}

export class KeyEncryptionKey {
	public aeskw: AESKW;
	public algorithm: any;

	static createKek = async ({ keyData }: CreateKekOptions) => {
		return new KeyEncryptionKey(keyData);
	};

	constructor(key: Uint8Array) {
		if (key.length !== 32) {
			throw new Error('key must be 32 bytes');
		}
		this.aeskw = new AESKW(key);
		this.algorithm = { name: 'A256KW' };
	}

	/**
	 * Wraps a cryptographic key.
	 *
	 * @param {object} options - The options to use.
	 * @param {Uint8Array} options.unwrappedKey - The key material as a
	 *   `Uint8Array`.
	 *
	 * @returns {string} - The base64url-encoded wrapped key bytes.
	 */
	wrapKey({ unwrappedKey }: WrapKeyOptions): string {
		const wrappedKey = this.aeskw.wrapKey(unwrappedKey);
		return base64url.encode(Buffer.from(wrappedKey));
	}

	/**
	 * Unwraps a cryptographic key.
	 *
	 * @param {object} options - The options to use.
	 * @param {string} options.wrappedKey - The wrapped key material as a
	 *   base64url-encoded string.
	 *
	 * @returns {Uint8Array} - Resolves to the key bytes or null if
	 *   the unwrapping fails because the key does not match.
	 */
	unwrapKey({ wrappedKey }: UnwrapKeyOptions): Uint8Array | null {
		const _wrappedKey = base64url.decode(wrappedKey);
		try {
			return this.aeskw.unwrapKey(_wrappedKey);
		} catch (e) {
			// decryption failed
			console.error(e);
			return null;
		}
	}

	static fromStaticPeer = (KeyPair: any) => {
		return async ({ ephemeralKeyPair, staticPublicKey }: any) => {
			if (!staticPublicKey) throw new Error("no staticPublicKey found")
			if (!(
				staticPublicKey.type === 'X25519KeyAgreementKey2019' ||
				staticPublicKey.type === 'X25519KeyAgreementKey2020' ||
				staticPublicKey.type === 'JsonWebKey2020'
			)) {
				throw new Error(
					`"staticPublicKey.type" must be "X25519KeyAgreementKey2019", "X25519KeyAgreementKey2020" or "JsonWebKey2020".`
					);
			}
			const epkPair =
				ephemeralKeyPair.keypair.type === 'JsonWebKey2020'
				? await X25519KeyAgreementKey2019.fromJWK(ephemeralKeyPair.keypair)
				: await KeyPair.from(ephemeralKeyPair.keypair);
						
			// "Party U Info"
			const producerInfo: Uint8Array = epkPair.multikey.publicKey;

			// "Party V Info"
			const consumerInfo = Buffer.from(staticPublicKey.id);
			const consumerKey =
				staticPublicKey.type === 'JsonWebKey2020'
				? await X25519KeyAgreementKey2019.fromJWK(staticPublicKey)
				: await KeyPair.from(staticPublicKey);
			const secret = await epkPair.deriveSecret(consumerKey);
			const keyData = await deriveKey({ secret, producerInfo, consumerInfo });
			return {
				kek: await KeyEncryptionKey.createKek({ keyData }),
				epk: ephemeralKeyPair.epk,
				apu: base64url.encode(producerInfo),
				apv: base64url.encode(consumerInfo as any)
			};
		};
	};

	static fromEphemeralPeer = (KeyPairClass: any) => {
		return async ({ keyAgreementKey, epk }: any) => {
			if (!(epk && typeof epk === 'object')) {
				throw new TypeError('"epk" must be an object.');
			}

			// convert to LD key for Web KMS
			const ephemeralPublicKey = {
				type: 'JsonWebKey2020',
				publicKeyJwk: epk,
				id: epk,
				controller: epk
			};

			const epkPair = await X25519KeyAgreementKey2019.fromJWK(ephemeralPublicKey);

			// safe to use IDs like in rfc7518 or does
			// https://tools.ietf.org/html/rfc7748#section-7 pose any issues?

			// "Party U Info"
			const producerInfo: Uint8Array = epkPair.multikey.publicKey;
			// if (epkPair.publicKey.extractable) {
			//   const temp = await epkPair.export({ type: "JsonWebKey2020" });
			//   producerInfo = Uint8Array.from(
			//     Buffer.concat([
			//       Buffer.from(temp.publicKeyJwk.x, "base64"),
			//       Buffer.from(temp.publicKeyJwk.y, "base64"),
			//     ])
			//   );
			// }

			// "Party V Info"
			const consumerInfo = Buffer.from(keyAgreementKey.id);
			// converts keys again....
			// base58 encoding should only be used at the network / serialization boundary.
			const secret = await keyAgreementKey.deriveSecret(epkPair);

			const keyData = await deriveKey({ secret, producerInfo, consumerInfo });
			return {
				kek: await KeyEncryptionKey.createKek({ keyData })
			};
		};
	};
}

================
File: src/lib/crypto/JWE/Suite.ts
================
import { generateKey, JWE_ENC } from '../JWE/xc20p.js';
import { KeyEncryptionKey } from '../JWE/KeyEncryptionKey.js';
import { EncryptTransformer } from '../JWE/EncryptTransformer.js';
import { DecryptTransformer } from '../JWE/DecryptTransformer.js';
import type { Header, IJWE } from '../../common/interfaces.js';
import { X25519KeyAgreementKey2019 } from '../keypairs/X25519KeyAgreementKey2019.js';
import { JsonWebKeyPair } from '../keypairs/JsonWebKey2020.js';
import { base64url } from '../utils/encoding.js';
import { stringToUint8Array } from '../utils/sha256.js';
import type { BaseKeyPair } from '../keypairs/BaseKeyPair.js';
import { Buffer } from 'buffer/index.js';

export class JsonWebEncryptionSuite {
	public encrypt: any;
	public decrypt: any;

	constructor() {
		this.encrypt = this.createEncrypter().encrypt;
		this.decrypt = this.createDecrypter().decrypt;
	}

	private createEncryptTransformer = ({ recipients, publicKeyResolver, chunkSize }: any) => {
		return {
			encrypt: async (data: Uint8Array): Promise<IJWE> => {
				if (!(Array.isArray(recipients) && recipients.length > 0)) {
					throw new TypeError('"recipients" must be a non-empty array.');
				}

				const alg = 'ECDH-ES+A256KW';

				if (!recipients.every((e) => e.header && e.header.alg === alg)) {
					throw new Error(`All recipients must use the algorithm "${alg}".`);
				}

				const cek = await generateKey();
				const publicKeys = await Promise.all(
					recipients.map((e) => publicKeyResolver(e.header.kid))
				);
				// derive ephemeral ECDH key pair to use with all recipients
				const epk = await (
					await X25519KeyAgreementKey2019.generate()
				).export({
					type: 'JsonWebKey2020',
					privateKey: true
				});

				const ephemeralKeyPair = {
					keypair: epk,
					epk: epk.publicKeyJwk
				};
				
				// derive KEKs for each recipient
				const derivedResults = await Promise.all(
					publicKeys.map((staticPublicKey) =>
						KeyEncryptionKey.fromStaticPeer(JsonWebKeyPair)({
							ephemeralKeyPair,
							staticPublicKey
						})
					)
				);

				// update all recipients with ephemeral ECDH key and wrapped CEK
				await Promise.all(
					recipients.map(async (recipient, i) => {
						const { kek, epk, apu, apv } = derivedResults[i];
						recipients[i] = recipient = { header: { ...recipient.header } };
						recipient.header.epk = epk;
						recipient.header.apu = apu;
						recipient.header.apv = apv;
						recipient.encrypted_key = await kek.wrapKey({ unwrappedKey: cek });
					})
				);

				// create shared protected header as associated authenticated data (aad)
				// ASCII(BASE64URL(UTF8(JWE Protected Header)))
				const enc = JWE_ENC;
				const jweProtectedHeader = JSON.stringify({ enc });
				const encodedProtectedHeader = base64url.encode(
					Buffer.from(stringToUint8Array(jweProtectedHeader))
				);
				// UTF8-encoding a base64url-encoded string is the same as ASCII
				const additionalData = stringToUint8Array(encodedProtectedHeader);

				return new EncryptTransformer({
					recipients,
					encodedProtectedHeader,
					additionalData,
					cek,
					chunkSize
				}).encrypt(data);
			}
		};
	};

	createEncrypter = () => {
		return {
			encrypt: async ({
				data,
				recipients,
				publicKeyResolver
			}: {
				data: object | string;
				recipients: { header: Header }[];
				publicKeyResolver: (id: string) => Promise<BaseKeyPair>;
			}): Promise<IJWE> => {
				if (typeof data !== 'object' && typeof data !== 'string') {
					throw new TypeError('"data" must be an object or a string.');
				}
				let binaryData =
					typeof data === 'string'
						? stringToUint8Array(data)
						: stringToUint8Array(JSON.stringify(data));
				const transformer = this.createEncryptTransformer({
					recipients,
					publicKeyResolver
				});
				return transformer.encrypt(binaryData);
			}
		};
	};

	async createDecryptTransformer({ keyAgreementKey }: any) {
		return new DecryptTransformer({
			KeyPairClass: JsonWebKeyPair,
			keyAgreementKey
		});
	}

	createDecrypter = () => {
		return {
			decrypt: async ({ jwe, keyAgreementKey }: { jwe: IJWE; keyAgreementKey: any }) => {
				const transformer = await this.createDecryptTransformer({
					keyAgreementKey
				});
				const decrypted = await transformer.decrypt(jwe);
				return JSON.parse(Buffer.from(decrypted).toString());
			}
		};
	};
}

================
File: src/lib/crypto/JWE/xc20p.ts
================
/*!
 * Copyright (c) 2019-2020 Digital Bazaar, Inc. All rights reserved.
 */
import { XChaCha20Poly1305, KEY_LENGTH } from "@stablelib/xchacha20poly1305";
import { randomBytes } from "@stablelib/random"

export const JWE_ENC = "XC20P";

/**
 * Generates a content encryption key (CEK). The 256-bit key is intended to be
 * used as a XChaCha20Poly1305 (draft-irtf-cfrg-xchacha-01) key.
 *
 * @returns {Promise<Uint8Array>} - Resolves to the generated key.
 */
export async function generateKey() {
  // generate content encryption key
  return randomBytes(KEY_LENGTH)
}

/**
 * Encrypts some data. The data will be encrypted using the given
 * 256-bit XChaCha20Poly1305 (draft-irtf-cfrg-xchacha-01) content encryption
 * key (CEK).
 *
 * @param {object} options - The options to use.
 * @param {Uint8Array} options.data - The data to encrypt.
 * @param {Uint8Array} [options.additionalData] - Optional additional
 *   authentication data.
 * @param {Uint8Array} options.cek - The content encryption key to use.
 *
 * @returns {Promise<object>} - Resolves to `{ciphertext, iv, tag}`.
 */
export async function encrypt({ data, additionalData, cek }: any) {
  if (!(data instanceof Uint8Array)) {
    throw new TypeError('"data" must be a Uint8Array.');
  }
  if (!(cek instanceof Uint8Array)) {
    throw new TypeError('"cek" must be a Uint8Array.');
  }

  const cipher = new XChaCha20Poly1305(cek);
  // Note: Uses a random value here as a counter is not viable -- multiple
  // recipients may be trying to update at the same time and use the same
  // counter breaking security; using XChaCha20Poly1305 once available will
  // further reduce chances of a collision as it has a 192-bit IV
  const iv = randomBytes(cipher.nonceLength)

  // encrypt data
  const encrypted = cipher.seal(iv, data, additionalData);

  // split ciphertext and tag
  const ciphertext = encrypted.subarray(0, encrypted.length - cipher.tagLength);
  const tag = encrypted.subarray(encrypted.length - cipher.tagLength);

  return {
    ciphertext,
    iv,
    tag,
  };
}

/**
 * Decrypts some encrypted data. The data must have been encrypted using
 * the given XChaCha20Poly1305 (draft-irtf-cfrg-xchacha-01) content encryption
 * key (CEK).
 *
 * @param {object} options - The options to use.
 * @param {Uint8Array} options.ciphertext - The data to decrypt.
 * @param {Uint8Array} options.iv - The initialization vector (aka nonce).
 * @param {Uint8Array} options.tag - The authentication tag.
 * @param {Uint8Array} [options.additionalData] - Optional additional
 *   authentication data.
 * @param {Uint8Array} options.cek - The content encryption key to use.
 *
 * @returns {Promise<Uint8Array>} The decrypted data.
 */
export async function decrypt({
  ciphertext,
  iv,
  tag,
  additionalData,
  cek,
}: any) {
  if (!(iv instanceof Uint8Array)) {
    throw new Error('Invalid or missing "iv".');
  }
  if (!(ciphertext instanceof Uint8Array)) {
    throw new Error('Invalid or missing "ciphertext".');
  }
  if (!(tag instanceof Uint8Array)) {
    throw new Error('Invalid or missing "tag".');
  }
  if (!(cek instanceof Uint8Array)) {
    throw new TypeError('"cek" must be a Uint8Array.');
  }

  // decrypt `ciphertext`
  const cipher = new XChaCha20Poly1305(cek);
  const encrypted = new Uint8Array(ciphertext.length + cipher.tagLength);
  encrypted.set(ciphertext);
  encrypted.set(tag, ciphertext.length);
  return cipher.open(iv, encrypted, additionalData);
}

================
File: src/lib/crypto/JWS/createSigner.ts
================
import type { JWA_ALG } from '../constants.js';
import { base64url } from '../utils/encoding.js';
import { Buffer } from 'buffer/index.js';

export type Signer = {
	sign: ({ data }: { data: Uint8Array }) => Promise<Uint8Array>;
};

export const detachedHeaderParams = {
	b64: false,
	crit: ['b64']
};

export const createJWSSigner = (
	signer: Signer,
	type: JWA_ALG,
	options: any = {
		detached: false
	}
) => {
	return {
		sign: async (
			data: Uint8Array,
			options?: { detached?: boolean; header?: object }
		): Promise<string> => {
			const header = {
				alg: type,
				...options.header,
				...(options.detached ? detachedHeaderParams : undefined)
			};
			const encodedHeader = base64url.encode(Buffer.from(JSON.stringify(header)));
			const encodedPayload = base64url.encode(
				data instanceof Uint8Array ? data : Buffer.from(JSON.stringify(data))
			);
			const toBeSigned = options.detached
				? new Uint8Array(
						Buffer.concat([Buffer.from(encodedHeader, 'base64'), Buffer.from('.', 'utf-8'), data])
				  )
				: new Uint8Array(Buffer.from(`${encodedHeader}.${encodedPayload}`));

			const message = toBeSigned as any;
			const signature = await signer.sign({ data: message });

			return options.detached
				? `${encodedHeader}..${base64url.encode(Buffer.from(signature))}`
				: `${encodedHeader}.${encodedPayload}.${base64url.encode(Buffer.from(signature))}`;
		}
	};
};

================
File: src/lib/crypto/JWS/createVerifier.ts
================
import type { JWA_ALG } from '../constants.js';
import { Buffer } from 'buffer/index.js';

export type Verifier = {
	verify: ({ data, signature }: { data: Uint8Array; signature: Uint8Array }) => Promise<boolean>;
};

export const createJWSVerifier = (
	verifier: Verifier,
	type: JWA_ALG,
	options: any = {
		detached: false
	}
) => {
	return {
		verify: async ({
			data,
			signature
		}: {
			data?: Uint8Array;
			signature: string;
		}): Promise<boolean> => {
			if (!signature.split) {
				signature = signature.toString();
			}
			const [encodedHeader, encodedPayload, encodedSignature] = signature.split('.');
			const decoded = JSON.parse(Buffer.from(encodedHeader, 'base64').toString());

			if (decoded.alg !== type) {
				throw new Error('JWS.header contained unsupported alg: ' + decoded.alg);
			}

			let toBeSigned: any = `${encodedHeader}.${encodedPayload}`;

			if (options.detached && decoded.b64) {
				throw new Error('header.b64 must be false for detached jws.');
			}

			if (options.detached && !decoded.crit.includes('b64')) {
				throw new Error('header.crit must include "b64" for detached jws.');
			}

			if (options.detached && !data) {
				throw new Error('cannot verify a detached jws without data.');
			}

			if (options.detached && data) {
				toBeSigned = Buffer.concat([
					Buffer.from(encodedHeader + '.', 'utf8'),
					Buffer.from(data.buffer, data.byteOffset, data.length)
				]);
			}

			const verified = verifier.verify({
				data: Buffer.from(toBeSigned),
				signature: Buffer.from(encodedSignature, 'base64')
			});
			return verified;
		}
	};
};

================
File: src/lib/crypto/JWS/Suite.ts
================
import type { DocumentLoader, ProofJSON } from '..';
import { JsonWebKeyPair } from '../keypairs/JsonWebKey2020.js';
import { LinkedDataProof } from '../LDP/proof.js';
import { base64url } from '../utils/encoding.js';
import { sha256buffer } from '../utils/sha256.js';
import { Buffer } from 'buffer/index.js';
import jsonld from 'jsonld';

export { createJWSSigner } from '../JWS/createSigner.js';
export { createJWSVerifier } from '../JWS/createVerifier.js';

export interface ISuite {
  key?: JsonWebKeyPair;
  getVerificationMethod: (options: any) => Promise<JsonWebKeyPair>;
  deriveProof?: (options: any) => Promise<any>;
}

interface JWSProofJSON extends ProofJSON {
  jws?: string;
}

export class JsonWebSignature2020LinkedDataProof extends LinkedDataProof {
  public jws: string | null;

  constructor(
    type: string,
    proofPurpose: string,
    verificationMethod: string,
    created: string,
    challenge: string | null = null,
    domain: string | null = null,
    jws: string | null = null
  ) {
    super(type, proofPurpose, verificationMethod, challenge ?? undefined, domain ?? undefined, created);
    this.jws = jws;
  }

  toJSON(): JWSProofJSON {
    const json: JWSProofJSON = super.toJSON();

    if (this.jws) {
      json.jws = this.jws;
    }

    return json;
  }
}

export class JsonWebSignature2020Suite {
  public key: JsonWebKeyPair;
  public date: string;
  public type: string = 'JsonWebSignature2020';
  public context: string = 'https://w3c-ccg.github.io/lds-jws2020/contexts/lds-jws2020-v1.json';
  public verificationMethod?: string;
  public useNativeCanonize: boolean = false;

  constructor(options: { key: JsonWebKeyPair; date?: string }) {
    this.date = options.date || new Date().toISOString();
    if (options.key) {
      this.key = options.key;
      this.verificationMethod = this.key.id;
    } else {
      throw new Error('key is required');
    }
  }

  async getVerificationMethod({ proof, documentLoader }: any) {
    let { verificationMethod } = proof;
    if (typeof verificationMethod === 'object') {
      verificationMethod = verificationMethod.id;
    }
    if (!verificationMethod) {
      throw new Error('No verification method found in proof');
    }

    const { document } = await documentLoader(verificationMethod);
    const result = document.verificationMethod.find((v: { id: string; }) => v.id === verificationMethod);
    if (!result || !result.controller) {
      throw new Error(`Verification method ${verificationMethod} not found.`);
    }

    return JsonWebKeyPair.fromJWK(result);
  }

  async canonize(input: any, { documentLoader }: any) {
    return await jsonld.canonize(input, {
      algorithm: 'URDNA2015',
      format: 'application/n-quads',
      documentLoader,
      useNative: this.useNativeCanonize
    });
  }

  async canonizeProof(proof: any, { documentLoader }: any) {
    const { jws, ...rest } = proof;
    return await this.canonize(rest, {
      documentLoader
    });
  }

  async createVerifyData({ document, proof, documentLoader }: any) {
    const c14nProofOptions = await this.canonizeProof(proof, {
      documentLoader
    });
    const c14nDocument = await this.canonize(document, {
      documentLoader
    });
    return Buffer.concat([sha256buffer(c14nProofOptions), sha256buffer(c14nDocument)]);
  }

  async createProof(
    document: any,
    purpose: string,
    documentLoader: DocumentLoader,
    options?: { domain?: string; challenge?: string }
  ): Promise<JWSProofJSON> {
    if (!this.verificationMethod) {
      throw new Error("No verificationMethod, Can't create proof");
    }
    let proof = new JsonWebSignature2020LinkedDataProof(
      this.type,
      purpose,
      this.verificationMethod,
      new Date().toISOString(),
      options?.challenge ?? null,
      options?.domain ?? null,
      null
    );
    const verifyData = await this.createVerifyData({
      document: {...document, '@context': [...document['@context'], this.context]},
      proof: { '@context': [...document['@context'], this.context], ...proof.toJSON() },
      documentLoader
    });
    const sig = await this.sign(verifyData);
    proof.jws = sig;
    return proof.toJSON();
  }

  async sign(verifyData: Uint8Array): Promise<string> {
    try {
      const key = await this.key.exportAsLD({ privateKey: true });
      const detachedJws = await key.sign!(verifyData);
      return (
        base64url.encode(Buffer.from(JSON.stringify({ b64: false, crit: ['b64'], alg: this.key.JWA }))) +
        '..' +
        base64url.encode(detachedJws)
      );
    } catch (e) {
      console.error('Failed to sign.', e);
      throw e;
    }
  }

	async verify(verifyData: Uint8Array, verificationMethod: JsonWebKeyPair, proof: { jws: string }): Promise<{ verified: boolean; error?: string }> {
		try {
			const key = await verificationMethod.exportAsLD({ privateKey: false });
			const [header, _, signature] = proof.jws.split('.');
			
			if (!header || !signature) {
				return { verified: false, error: "Invalid JWS format" };
			}

			const headerData = JSON.parse(Buffer.from(base64url.decode(header)).toString('utf-8'));
			
			if (!headerData.crit.includes('b64') || headerData.b64) {
				return { verified: false, error: "'b64' JWS header param must be false and in crit" };
			}
			
			if (!headerData.alg) {
				return { verified: false, error: "JWS header is missing 'alg' parameter" };
			}
			
			if (!this.key.JWA) {
				return { verified: false, error: "Key is missing JWA property" };
			}
			
			if (headerData.alg !== this.key.JWA) {
				return { verified: false, error: `JWA alg mismatch: received ${headerData.alg}, expected ${this.key.JWA}` };
			}

			const verified = await key.verify!(verifyData, base64url.decode(signature));
			return { verified };
		} catch (e: any) {
			console.error('Verification error:', e.message);
			return { verified: false, error: `Unexpected error during verification: ${e.message}` };
		}
	}

  async verifyProof(
    proof: JWSProofJSON,
    document: any,
    documentLoader: DocumentLoader,
    options: { expansionMap?: any; compactProof?: any } = {}
  ) {
    try {
      const verifyData = await this.createVerifyData({
        document,
        proof: { '@context': [...document['@context'], this.context], ...proof },
        documentLoader
      });

      const verificationMethod = await this.getVerificationMethod({
        proof,
        document,
        documentLoader,
        instance: true
      });

      if (!proof.jws) {
        return { verified: false, errors: ['jws not found in proof'] };
      }
			
      const { verified, error } = await this.verify(verifyData, verificationMethod, proof as {jws: string});
      if (!verified) {
        return { verified: false, errors: [error || 'Invalid signature'] };
      }

      const jwsProof = new JsonWebSignature2020LinkedDataProof(
        proof.type,
        proof.proofPurpose,
        proof.verificationMethod,
        proof.created,
        proof.challenge,
        proof.domain,
        proof.jws
      );

      const purposeValid = jwsProof.validate();

      if (!purposeValid) {
        throw new Error('Proof purpose not valid');
      }

      return { verified: true };
    } catch (error: any) {
      return { verified: false, errors: [error.message] };
    }
  }
}

================
File: src/lib/crypto/JWT/Suite.ts
================
import type { JWA_ALG } from "../constants";
import type { JWTPayload, VerificationResult } from "../../common/interfaces";
import type { JsonWebKey2020 } from "../keypairs/JsonWebKey2020";
import { base64url } from "../utils/encoding";
import { Buffer } from 'buffer';

export class JWTSuite {
    public key: JsonWebKey2020;
    public alg: JWA_ALG;

    constructor(options: { key: JsonWebKey2020, alg: JWA_ALG }) {
        if (options.key) {
            this.key = options.key;
        } else {
            throw new Error('`key` is required');
        }
        if (options.alg) {
            this.alg = options.alg;
        } else {
            throw new Error('`alg` is required');
        }
    }

    async sign(payload: JWTPayload): Promise<string> {
        try {
            const { privateKeyJwk, id } = await this.key.export!({ privateKey: true });
            if (!privateKeyJwk) {
                throw new Error(`Private key not found`);
            }

            const header = {
                alg: this.alg,
                typ: "JWT",
                kid: id
            };

            const encodedHeader = base64url.encode(JSON.stringify(header));
            const encodedPayload = base64url.encode(JSON.stringify(payload));
            const signingInput = `${encodedHeader}.${encodedPayload}`;

            const keyPair = await this.key.exportAsLD!({ privateKey: true });
            const signature = await keyPair.sign!(Buffer.from(signingInput));

            return `${signingInput}.${base64url.encode(Buffer.from(signature))}`;
        } catch (e) {
            console.error('Failed to sign.', e);
            throw e;
        }
    }

    async verify(jwt: string): Promise<VerificationResult> {
        try {
            const [encodedHeader, encodedPayload, encodedSignature] = jwt.split('.');
            
            if (!encodedHeader || !encodedPayload || !encodedSignature) {
                throw new Error('Invalid JWT format');
            }

            const header = JSON.parse(Buffer.from(base64url.decode(encodedHeader)).toString());
            
            if (header.alg !== this.alg) {
                throw new Error(`Algorithm mismatch: expected ${this.alg}, got ${header.alg}`);
            }

            const signingInput = `${encodedHeader}.${encodedPayload}`;
            const signature = Buffer.from(base64url.decode(encodedSignature));

            const { publicKeyJwk } = await this.key.export!({ privateKey: false });
            if (!publicKeyJwk) {
                throw new Error(`Public key not found`);
            }

            const keyPair = await this.key.exportAsLD!({ privateKey: false });
            const isValid = await keyPair.verify!(Buffer.from(signingInput), signature);

            if (!isValid) {
                throw new Error('Invalid signature');
            }

            return {
                verified: true,
                errors: []
            };
        } catch (e: any) {
            console.error(e.message);
            return { verified: false, errors: [e.message] };
        }
    }
}

================
File: src/lib/crypto/keypairs/BaseKeyPair.ts
================
import type { JsonWebKey2020 } from '../keypairs/JsonWebKey2020.js';

export interface BaseKeyPairStatic {
	from(
		k: BaseKeyPair,
		options: { detached: boolean }
	): Promise<BaseKeyPair>;
	fromJWK(k: JsonWebKey2020): Promise<BaseKeyPair>;
	generate(options: {
		kty?: string;
		crv?: string;
		detached?: boolean;
		secureRandom?: () => Uint8Array;
	}): Promise<BaseKeyPair>;
}

export interface BaseKeyPair {
	id: string;
	type: string;
	controller: string;
	JWA?: string;

	signer?: (privateKey: Uint8Array) => { sign: ({ data }: { data: Uint8Array }) => {} };
	sign?: ({ data }: { data: Uint8Array }) => Promise<Uint8Array>;

	verifier?: (publicKey: Uint8Array) => {
		verify: ({ data, signature }: { data: Uint8Array; signature: Uint8Array }) => Promise<boolean>;
	};
	verify?: ({ data, signature }: { data: Uint8Array; signature: Uint8Array }) => Promise<boolean>;
}

================
File: src/lib/crypto/keypairs/Ed25519VerificationKey2018.ts
================
import { Ed25519VerificationKey2020 } from './Ed25519VerificationKey2020';
import { base58, multibase, base64url, MULTICODEC_ED25519_PRIV_HEADER, MULTICODEC_ED25519_PUB_HEADER } from '../utils/encoding';
import type { DocumentLoader } from '../../common/interfaces';
import { createVerifyData } from '../utils/vcs';
import type { JsonWebKey2020 } from './JsonWebKey2020';
import type { Multikey } from './Multikey';

export class Ed25519Signature2018LinkedDataProof {
  public type: string;
  public proofPurpose: string;
  public verificationMethod: string;
  public created: string;
  public jws?: string;
  public challenge?: string;
  public domain?: string;

  constructor(
    type: string,
    proofPurpose: string,
    verificationMethod: string,
    created: string,
    jws?: string,
    challenge?: string,
    domain?: string
  ) {
    this.type = type;
    this.proofPurpose = proofPurpose;
    this.verificationMethod = verificationMethod;
    this.created = created;
    this.jws = jws;
    this.challenge = challenge;
    this.domain = domain;
  }

  toJSON() {
    const json: any = {
      type: this.type,
      proofPurpose: this.proofPurpose,
      verificationMethod: this.verificationMethod,
      created: this.created,
    };
    if (this.jws) json.jws = this.jws;
    if (this.challenge) json.challenge = this.challenge;
    if (this.domain) json.domain = this.domain;
    return json;
  }
}

export class Ed25519VerificationKey2018 {
  private key2020: Ed25519VerificationKey2020;
	multikey: Multikey;

  constructor(id: string, controller: string, publicKeyBase58: string, privateKeyBase58?: string) {
    const publicKeyMultibase = multibase.encode(MULTICODEC_ED25519_PUB_HEADER, base58.decode(publicKeyBase58));
    const privateKeyMultibase = privateKeyBase58
      ? multibase.encode(MULTICODEC_ED25519_PRIV_HEADER, base58.decode(privateKeyBase58))
      : undefined;
    this.key2020 = new Ed25519VerificationKey2020(id, controller, publicKeyMultibase, privateKeyMultibase);
		this.multikey = this.key2020.multikey;
  }

  get id(): string {
    return this.key2020.id;
  }

  get type(): string {
    return 'Ed25519VerificationKey2018';
  }

  get controller(): string {
    return this.key2020.controller;
  }

  get publicKeyBase58(): string {
    return base58.encode(multibase.decode(MULTICODEC_ED25519_PUB_HEADER, this.key2020.publicKeyMultibase));
  }

  get privateKeyBase58(): string | undefined {
    return this.key2020.privateKeyMultibase
      ? base58.encode(multibase.decode(MULTICODEC_ED25519_PRIV_HEADER, this.key2020.privateKeyMultibase))
      : undefined;
  }

  static async generate(): Promise<Ed25519VerificationKey2018> {
    const key2020 = await Ed25519VerificationKey2020.generate();
    return new Ed25519VerificationKey2018(
      key2020.id,
      key2020.controller,
      base58.encode(multibase.decode(MULTICODEC_ED25519_PUB_HEADER, key2020.publicKeyMultibase)),
      key2020.privateKeyMultibase
        ? base58.encode(multibase.decode(MULTICODEC_ED25519_PRIV_HEADER, key2020.privateKeyMultibase))
        : undefined
    );
  }

	static from(options: { id?: string, controller?: string, publicKeyBase58: string, privateKeyBase58?: string }): Ed25519VerificationKey2018 {
    return new Ed25519VerificationKey2018(
      options.id ?? `#${options.publicKeyBase58.slice(0, 8)}`,
      options.controller ?? `#${options.publicKeyBase58.slice(0, 8)}`,
      options.publicKeyBase58,
      options.privateKeyBase58
    );
  }

	static fromJWK = async (k: JsonWebKey2020) => {
		let publicKey, privateKey;
		if (!k.publicKeyJwk.x)
			throw new Error('Public Key Not found')
		publicKey = base58.encode(base64url.decode(k.publicKeyJwk.x));
		if (k.privateKeyJwk && k.privateKeyJwk.d) {
			privateKey = base58.encode(base64url.decode(k.privateKeyJwk.d));
		}
		return new Ed25519VerificationKey2018(k.id, k.controller, publicKey, privateKey);
	};

  async sign(data: Uint8Array): Promise<Uint8Array> {
    return this.key2020.sign(data);
  }

  async verify(data: Uint8Array, signature: Uint8Array): Promise<boolean> {
    return this.key2020.verify(data, signature);
  }

  async createProof(
    document: any,
    purpose: string,
    documentLoader: DocumentLoader,
    options?: { domain?: string, challenge?: string }
  ): Promise<Ed25519Signature2018LinkedDataProof> {
    if (!this.key2020.privateKeyMultibase) {
      throw new Error("No privateKey, Can't create proof");
    }
    const date = new Date().toISOString();
    const proof = new Ed25519Signature2018LinkedDataProof(
      'Ed25519Signature2018',
      purpose,
      this.id,
      date.slice(0, date.length - 5) + 'Z',
      undefined,
      options?.challenge,
      options?.domain
    );

    const verifyData = await createVerifyData({
      document,
      proof: { '@context': document['@context'], ...proof.toJSON() },
      documentLoader
    });

    const signature = await this.sign(verifyData);
    
    // Create JWS
    const header = {
      alg: 'EdDSA',
      b64: false,
      crit: ['b64']
    };

    const encodedHeader = base64url.encode(JSON.stringify(header));
    const encodedSignature = base64url.encode(signature);
    
    proof.jws = `${encodedHeader}..${encodedSignature}`;

    return proof;
  }

  async verifyProof(
    proof: Ed25519Signature2018LinkedDataProof,
    document: any,
    documentLoader: DocumentLoader
  ): Promise<{ verified: boolean; errors?: string[] }> {
    try {
      const { proof: documentProof, ...doc } = document;
      const verifyData = await createVerifyData({
        document: doc,
        proof: { '@context': doc['@context'], ...proof },
        documentLoader
      });

      if (!proof.jws) {
        throw new Error('No jws found in proof');
      }

      const [encodedHeader, encodedSignature] = proof.jws.split('..');
      
      if (!encodedHeader || !encodedSignature) {
        throw new Error('Invalid JWS format');
      }

      const header = JSON.parse(base64url.decode(encodedHeader).toString());
      
      if (!header.b64 || !header.crit.includes('b64')) {
        throw new Error('Invalid JWS header');
      }

      const signature = base64url.decode(encodedSignature);
      const verified = await this.verify(verifyData, signature);

      if (!verified) {
        return { verified: false, errors: ['Invalid signature'] };
      }

      return { verified: true };
    } catch (error: any) {
      return { verified: false, errors: [error.message] };
    }
  }

  async export(options?: { privateKey?: boolean; type: 'JsonWebKey2020' }): Promise<any> {
    return this.key2020.export(options);
  }
}

================
File: src/lib/crypto/keypairs/Ed25519VerificationKey2020.ts
================
import { Multikey, KeyType } from './Multikey';
import { base58, base64url, multibase, MULTICODEC_ED25519_PRIV_HEADER, MULTICODEC_ED25519_PUB_HEADER } from '../utils/encoding';
import type { DocumentLoader } from '../../common/interfaces';
import { createVerifyData } from '../utils/vcs';
import type { JsonWebKey2020, JsonWebKeyPair } from './JsonWebKey2020';

export class Ed25519Signature2020LinkedDataProof {
  public type: string;
  public proofPurpose: string;
  public verificationMethod: string;
  public created: string;
  public proofValue?: string;
  public challenge?: string;
  public domain?: string;

  constructor(
    type: string,
    proofPurpose: string,
    verificationMethod: string,
    created: string,
    proofValue?: string,
    challenge?: string,
    domain?: string
  ) {
    this.type = type;
    this.proofPurpose = proofPurpose;
    this.verificationMethod = verificationMethod;
    this.created = created;
    this.proofValue = proofValue;
    this.challenge = challenge;
    this.domain = domain;
  }

  toJSON() {
    const json: any = {
      type: this.type,
      proofPurpose: this.proofPurpose,
      verificationMethod: this.verificationMethod,
      created: this.created,
    };
    if (this.proofValue) json.proofValue = this.proofValue;
    if (this.challenge) json.challenge = this.challenge;
    if (this.domain) json.domain = this.domain;
    return json;
  }
}

export class Ed25519VerificationKey2020 {
  multikey: Multikey;

  constructor(id: string, controller: string, publicKeyMultibase: string, privateKeyMultibase?: string) {
    const publicKey = multibase.decode(MULTICODEC_ED25519_PUB_HEADER, publicKeyMultibase);
    const privateKey = privateKeyMultibase ? multibase.decode(MULTICODEC_ED25519_PRIV_HEADER, privateKeyMultibase) : undefined;
    this.multikey = new Multikey(KeyType.Ed25519, id, controller, publicKey, privateKey);
  }

	get publicKey(): Uint8Array {
    return this.multikey.publicKey;
  }

	get privateKey(): Uint8Array | undefined {
    return this.multikey.privateKey;
  }

  get id(): string {
    return this.multikey.id;
  }

  get type(): string {
    return 'Ed25519VerificationKey2020';
  }

  get controller(): string {
    return this.multikey.controller;
  }

  get publicKeyMultibase(): string {
    return this.multikey.publicKeyMultibase;
  }

  get privateKeyMultibase(): string | undefined {
    return this.multikey.privateKeyMultibase;
  }

  static async generate(): Promise<Ed25519VerificationKey2020> {
    const generatedMultikey = await Multikey.generate(KeyType.Ed25519);
    return new Ed25519VerificationKey2020(
      generatedMultikey.id,
      generatedMultikey.controller,
      generatedMultikey.publicKeyMultibase,
      generatedMultikey.privateKeyMultibase
    );
  }

  static from(options: { id?: string, controller?: string, publicKeyBase58: string, privateKeyBase58?: string }): Ed25519VerificationKey2020 {
    const publicKeyMultibase = multibase.encode(MULTICODEC_ED25519_PUB_HEADER, base58.decode(options.publicKeyBase58));
    const privateKeyMultibase = options.privateKeyBase58
      ? multibase.encode(MULTICODEC_ED25519_PRIV_HEADER, base58.decode(options.privateKeyBase58))
      : undefined;
    return new Ed25519VerificationKey2020(
      options.id ?? `#${publicKeyMultibase.slice(0, 8)}`,
      options.controller ?? `#${publicKeyMultibase.slice(0, 8)}`,
      publicKeyMultibase,
      privateKeyMultibase
    );
  }
	
	static fromBase58 = async (options: { id?: string, controller?: string, publicKeyBase58: string, privateKeyBase58?: string }) => {
		let publicKeyMultibase, privateKeyMultibase;
		publicKeyMultibase = multibase.encode(MULTICODEC_ED25519_PUB_HEADER, base58.decode(options.publicKeyBase58))
		if (options.privateKeyBase58) {
			privateKeyMultibase = multibase.encode(MULTICODEC_ED25519_PRIV_HEADER, base58.decode(options.privateKeyBase58))
		}
		return new Ed25519VerificationKey2020(
			options.id ?? `#${publicKeyMultibase.slice(0, 8)}`,
			options.controller ?? `#${publicKeyMultibase.slice(0, 8)}`,
			publicKeyMultibase,
			privateKeyMultibase
		);
	}

	static fromJWK = async (k: JsonWebKey2020) => {
		let publicKey, privateKey;
		if (!k.publicKeyJwk.x)
			throw new Error('Public Key Not found')
		publicKey = base58.encode(base64url.decode(k.publicKeyJwk.x));
		if (k.privateKeyJwk && k.privateKeyJwk.d) {
			privateKey = base58.encode(base64url.decode(k.privateKeyJwk.d));
		}
		return new Ed25519VerificationKey2020(k.id, k.controller, publicKey, privateKey);
	};

  async sign(data: Uint8Array): Promise<Uint8Array> {
    return this.multikey.sign(data);
  }

  async verify(data: Uint8Array, signature: Uint8Array): Promise<boolean> {
    return this.multikey.verify(data, signature);
  }

	async export(
    options: {
      privateKey?: boolean;
      type: 'JsonWebKey2020';
    } = {
      privateKey: false,
      type: 'JsonWebKey2020'
    }
  ): Promise<JsonWebKey2020> {
		return this.multikey.export(options);
	}

  async createProof(
    document: any,
    purpose: string,
    documentLoader: DocumentLoader,
    options?: { domain?: string, challenge?: string }
  ): Promise<Ed25519Signature2020LinkedDataProof> {
    if (!this.privateKeyMultibase) {
      throw new Error("No privateKey, Can't create proof");
    }
    const date = new Date().toISOString();
    const proof = new Ed25519Signature2020LinkedDataProof(
      'Ed25519Signature2020',
      purpose,
      this.id,
      date.slice(0, date.length - 5) + 'Z',
      undefined,
      options?.challenge,
      options?.domain
    );

    const verifyData = await createVerifyData({
      document,
      proof: { '@context': document['@context'], ...proof.toJSON() },
      documentLoader
    });

    const signature = await this.sign(verifyData);
    proof.proofValue = multibase.encode(new Uint8Array([]), signature);

    return proof;
  }

  async verifyProof(
    proof: Ed25519Signature2020LinkedDataProof,
    document: any,
    documentLoader: DocumentLoader
  ): Promise<{ verified: boolean; errors?: string[] }> {
    try {
      const { proof: documentProof, ...doc } = document;
      const verifyData = await createVerifyData({
        document: doc,
        proof: { '@context': doc['@context'], ...proof },
        documentLoader
      });

      const signature = multibase.decode(new Uint8Array([]), proof.proofValue ?? '');
      const verified = await this.verify(verifyData, signature);

      if (!verified) {
        return { verified: false, errors: ['Invalid signature'] };
      }

      return { verified: true };
    } catch (error: any) {
      return { verified: false, errors: [error.message] };
    }
  }
}

================
File: src/lib/crypto/keypairs/HD.ts
================
import { hexToBytes } from "@noble/hashes/utils"
import { HDKey } from "@scure/bip32"

export const seedToHD = (seed: string) => {
  return HDKey.fromMasterSeed(hexToBytes(seed)).privateExtendedKey;
}

export const deriveKeyAtPathFromMaster = (masterKey: string, path: string): HDKey => {
  return HDKey.fromExtendedKey(masterKey).derive(path);
}

================
File: src/lib/crypto/keypairs/JsonWebKey2020.ts
================
import type { IJWK } from "..";
import { createJWSSigner } from "../JWS/createSigner.js";
import { createJWSVerifier } from "../JWS/createVerifier.js";
import { Ed25519VerificationKey2018 } from "../keypairs/Ed25519VerificationKey2018.js";
import { Secp256k1KeyPair } from "../keypairs/Secp256k1KeyPair.js";
import { X25519KeyAgreementKey2019 } from "../keypairs/X25519KeyAgreementKey2019.js";
import { Ed25519VerificationKey2020 } from "../keypairs/Ed25519VerificationKey2020.js";
import { X25519KeyAgreementKey2020 } from "../keypairs/X25519KeyAgreementKey2020.js";
import type { Multikey } from "./Multikey.js";


const applyJwa = async (k: any, options?: any) => {
	// attach verifier w/ jwa
	const verifier = await getVerifier(k, options);

	k.verifier = () => verifier as any;

	// attach encrypter w/ jwa
	const encrypter = await getEncrypter(k, options);
	k.encrypter = () => encrypter as any;

	if (k.privateKey) {
		// attach signer w/ jwa
		const signer = await getSigner(k, options);
		k.signer = () => signer as any;

		//attach decrypter w/ jwa
		const decrypter = await getDecrypter(k, options);
		k.decrypter = () => decrypter as any;
	}
	return k;
};

const useJwa = async (k: any, options?: any) => {
	k.useJwa = async (options?: any) => {
		return applyJwa(k, options);
	};
	return applyJwa(k, options);
};

const getKeyPairForKtyAndCrv = (kty: string, crv: string) => {
	if (kty === 'OKP') {
		if (crv === 'Ed25519') {
			return Ed25519VerificationKey2018;
		}
		if (crv === 'X25519') {
			return X25519KeyAgreementKey2019;
		}
	}
	if (kty === 'EC') {
		if (crv === 'secp256k1') {
			return Secp256k1KeyPair;
		}

		// if (crv === "BLS12381_G2") {
		//   return Bls12381G2KeyPair;
		// }
	}
	throw new Error(`getKeyPairForKtyAndCrv does not support: ${kty} and ${crv}`);
};

const getKeyPairForType = (k: any) => {
	if (k.type === 'JsonWebKey2020') {
		return getKeyPairForKtyAndCrv(k.publicKeyJwk.kty, k.publicKeyJwk.crv);
	}
	if (k.type === 'Ed25519VerificationKey2018') {
		return Ed25519VerificationKey2018;
	}
	if (k.type === 'Ed25519VerificationKey2020') {
		return Ed25519VerificationKey2020;
	}
	// if (k.type === "EcdsaSecp256k1VerificationKey2019") {
	//   return Secp256k1KeyPair;
	// }
	// if (k.type === "Bls12381G2Key2020") {
	//   return Bls12381G2KeyPair;
	// }
	if (k.type === 'X25519KeyAgreementKey2019') {
		return X25519KeyAgreementKey2019;
	}
	if (k.type === 'X25519KeyAgreementKey2020') {
		return X25519KeyAgreementKey2020
	}

	throw new Error('getKeyPairForType does not support type: ' + k.type);
};

const getVerifier = async (k: any, options = { detached: true }) => {
	const { publicKeyJwk } = await k.export({ type: 'JsonWebKey2020' });
	if (publicKeyJwk) {
		const { kty, crv } = publicKeyJwk;

		if (kty === 'OKP') {
			if (crv === 'Ed25519') {
				return createJWSVerifier(k.verifier(k.publicKey), 'EdDSA', options);
			}
		}

		if (kty === 'EC') {
			if (crv === 'secp256k1') {
				return createJWSVerifier(k.verifier(k.publicKey), 'ES256K', options);
			}

			if (crv === 'P-256') {
				return createJWSVerifier(k.verifier(k.publicKey), 'ES256', options);
			}
			if (crv === 'P-384') {
				return createJWSVerifier(k.verifier(k.publicKey), 'ES384', options);
			}
			if (crv === 'P-521') {
				return createJWSVerifier(k.verifier(k.publicKey), 'ES512', options);
			}

			if (crv === 'BLS12381_G2') {
				throw new Error('BLS12381_G2 has no registered JWA');
			}
		}
	}
	console.log(`getVerifier does not support ${JSON.stringify(publicKeyJwk, null, 2)}`);
	return () => {};
};

const getSigner = (k: any, options = { detached: true }) => {
	const { publicKeyJwk } = k;
	if (publicKeyJwk) {
		const { kty, crv } = publicKeyJwk;

		if (kty === 'OKP') {
			if (crv === 'Ed25519') {
				return createJWSSigner(k.signer(k.privateKey), 'EdDSA', options);
			}
		}
		if (kty === 'EC') {
			if (crv === 'secp256k1') {
				return createJWSSigner(k.signer(k.privateKey), 'ES256K', options);
			}
			if (crv === 'BLS12381_G2') {
				throw new Error('BLS12381_G2 has no registered JWA');
			}
			if (crv === 'P-256') {
				return createJWSSigner(k.signer(k.privateKey), 'ES256', options);
			}
			if (crv === 'P-384') {
				return createJWSSigner(k.signer(k.privateKey), 'ES384', options);
			}
			if (crv === 'P-521') {
				return createJWSSigner(k.signer(k.privateKey), 'ES512', options);
			}
		}
	}
	console.log(`getSigner does not support ${JSON.stringify(publicKeyJwk, null, 2)}`);
	return () => {};
};

const getEncrypter = async (k: JsonWebKeyPair, options = { flattened: false }) => {
	const { publicKeyJwk } = await k.export();
};

const getDecrypter = async (k: JsonWebKeyPair, options = { flattened: false }) => {
	const { privateKeyJwk } = await k.export();
};

export interface JsonWebKey2020 {
	id: string;
	type: string;
	controller: string;
	publicKeyJwk: IJWK;
	privateKeyJwk?: IJWK;
	setJWA?: () => void;
	export?: (options: {privateKey?: boolean}) => Promise<JsonWebKey2020>
	exportAsLD?: (options: {privateKey?: boolean}) => Promise<Multikey>
}

export class JsonWebKeyPair implements JsonWebKey2020 {
	id: string;
	type: 'JsonWebKey2020';
	controller: string;
	publicKeyJwk: IJWK;
	privateKeyJwk?: IJWK;
  JWA?: string;

	constructor(id: string, controller: string, publicKeyJwk?: IJWK, privateKeyJwk?: IJWK) {
		if(!publicKeyJwk) {
			throw new Error(`'publicKeyJwk' is required`)
		}
		this.type = 'JsonWebKey2020';
		this.id = id;
		this.controller = controller;
		this.publicKeyJwk = publicKeyJwk;
		if (privateKeyJwk) {
			this.privateKeyJwk = privateKeyJwk;
		}
		this.setJWA();
	}

	setJWA() {
    if (this.publicKeyJwk.kty === 'EC' && this.publicKeyJwk.crv === 'secp256k1') {
      this.JWA = 'ES256K';
    }
    // Add more conditions for other key types if needed
  }

	static from = async (k: Multikey, options: any = { detached: true }) => {
		const KeyPair = getKeyPairForType(k);
		const key = KeyPair.from(k as any);
		let { detached, header } = options;
		if (detached === undefined) {
			detached = true;
		}
		return useJwa(key, { detached, header });
	};

	static fromJWK = async (k: JsonWebKey2020) => {
		return new JsonWebKeyPair(k.id, k.controller, k.publicKeyJwk, k.privateKeyJwk);
	};

	static generate = async (options: any = { kty: 'OKP', crv: 'Ed25519', detached: true }) => {
		const KeyPair = getKeyPairForKtyAndCrv(options.kty, options.crv);
		return await KeyPair.generate();
	};

	async export(
		options: {
			privateKey?: boolean;
		} = {
			privateKey: false
		}
	): Promise<JsonWebKey2020> {
		const resp: JsonWebKey2020 = {
			id: this.id,
			type: this.type,
			controller: this.controller,
			publicKeyJwk: this.publicKeyJwk,
		};
		if(options.privateKey) {
			resp.privateKeyJwk = this.privateKeyJwk;
		}
		return resp;
	}

	/**
	 * export as the Linked Data non JWK variant
	 */
	async exportAsLD(
		options: {
			privateKey?: boolean;
		} = {
			privateKey: false
		}
	): Promise<Multikey> {
		const keyPairClass = getKeyPairForKtyAndCrv(this.publicKeyJwk.kty, this.publicKeyJwk.crv);
		const jwk = await this.export(options);
		return (await keyPairClass.fromJWK(jwk)).multikey;
	}
}

================
File: src/lib/crypto/keypairs/Multikey.ts
================
import { base58, bigIntToBuf, base64url, multibase, MULTICODEC_ED25519_PUB_HEADER, MULTICODEC_X25519_PUB_HEADER, MULTICODEC_SECP256K1_PUB_HEADER, MULTICODEC_ED25519_PRIV_HEADER, MULTICODEC_X25519_PRIV_HEADER, MULTICODEC_SECP256K1_PRIV_HEADER } from '../utils/encoding';
import * as ed25519 from '@stablelib/ed25519';
import * as x25519 from '@stablelib/x25519';
import * as secp from '@noble/secp256k1';
import { sha256Uint8Array } from '../utils/sha256';
import { XChaCha20Poly1305 } from '@stablelib/xchacha20poly1305';
import type { JsonWebKey2020, JsonWebKeyPair } from './JsonWebKey2020';

export enum KeyType {
  Ed25519 = 'Ed25519',
  X25519 = 'X25519',
  Secp256k1 = 'Secp256k1',
}

export class Multikey {
  id: string;
  type: 'Multikey' = 'Multikey';
  controller: string;
  publicKeyMultibase: string;
  publicKey: Uint8Array;
  privateKeyMultibase?: string;
  privateKey?: Uint8Array;
  keyType: KeyType;
  private signer?: (data: Uint8Array) => Promise<Uint8Array>;
  private verifier?: (data: Uint8Array, signature: Uint8Array) => Promise<boolean>;

  constructor(keyType: KeyType, id: string, controller: string, publicKey: Uint8Array, privateKey?: Uint8Array) {
    this.keyType = keyType;
    this.id = id;
    this.controller = controller;
    this.publicKeyMultibase = Multikey.encodePublicKey(publicKey, keyType);
    this.publicKey = publicKey;
    this.verifier = this.createVerifier(publicKey);
    if (privateKey) {
      this.privateKeyMultibase = Multikey.encodePrivateKey(privateKey, keyType);
      this.privateKey = privateKey;
      this.signer = this.createSigner(privateKey);
    }
  }

  static async generate(keyType: KeyType): Promise<Multikey> {
    let publicKey: Uint8Array, privateKey: Uint8Array;

    switch (keyType) {
      case KeyType.Ed25519:
        const ed25519KeyPair = ed25519.generateKeyPair();
        publicKey = ed25519KeyPair.publicKey;
        privateKey = ed25519KeyPair.secretKey;
        break;
      case KeyType.X25519:
        const x25519KeyPair = x25519.generateKeyPair();
        publicKey = x25519KeyPair.publicKey;
        privateKey = x25519KeyPair.secretKey;
        break;
      case KeyType.Secp256k1:
        privateKey = secp.utils.randomPrivateKey();
        publicKey = secp.getPublicKey(privateKey);
        break;
      default:
        throw new Error('Unsupported key type');
    }

    const fingerprint = Multikey.fingerprintFromPublicKey(keyType, publicKey);
    const controller = `did:key:${fingerprint}`;
    const id = `${controller}#${fingerprint}`;

    return new Multikey(keyType, id, controller, publicKey, privateKey);
  }

  private static fingerprintFromPublicKey(keyType: KeyType, publicKey: Uint8Array): string {
    let prefix: Uint8Array;
    switch (keyType) {
      case KeyType.Ed25519:
        prefix = new Uint8Array([0xed, 0x01]);
        break;
      case KeyType.X25519:
        prefix = new Uint8Array([0xec, 0x01]);
        break;
      case KeyType.Secp256k1:
        prefix = new Uint8Array([0xe7, 0x01]);
        break;
      default:
        throw new Error('Unsupported key type');
    }
    const fullKey = new Uint8Array(prefix.length + publicKey.length);
    fullKey.set(prefix);
    fullKey.set(publicKey, prefix.length);
    return 'z' + base58.encode(fullKey);
  }

  private createSigner(privateKey: Uint8Array) {
    switch (this.keyType) {
      case KeyType.Ed25519:
        return async (data: Uint8Array) => ed25519.sign(privateKey, data);
      case KeyType.Secp256k1:
        return async (data: Uint8Array) => {
          const msgHash = sha256Uint8Array(data);
          return secp.sign(msgHash, privateKey).toCompactRawBytes();
        };
      case KeyType.X25519:
        return async (data: Uint8Array) => {
          throw new Error('X25519 keys cannot be used for signing');
        }
      default:
        throw new Error('Unsupported key type');
    }
  }

  private createVerifier(publicKey: Uint8Array) {
    switch (this.keyType) {
      case KeyType.Ed25519:
        return async (data: Uint8Array, signature: Uint8Array) => ed25519.verify(publicKey, data, signature);
      case KeyType.Secp256k1:
        return async (data: Uint8Array, signature: Uint8Array) => {
          const msgHash = sha256Uint8Array(data);
          return secp.verify(signature, msgHash, publicKey);
        };
      case KeyType.X25519:
        return async (data: Uint8Array, signature: Uint8Array) => {
          throw new Error('X25519 keys cannot be used for verification');
        }
      default:
        throw new Error('Unsupported key type');
    }
  }

  async sign(data: Uint8Array): Promise<Uint8Array> {
    if (!this.signer) {
      throw new Error('No private key available for signing');
    }
    return this.signer(data);
  }

  async verify(data: Uint8Array, signature: Uint8Array): Promise<boolean> {
    if (!this.verifier) {
      throw new Error('No public key available for verification');
    }
    return this.verifier(data, signature);
  }

  async deriveSecret(peerKey: Multikey): Promise<Uint8Array> {
    if (this.keyType !== KeyType.X25519 || peerKey.keyType !== KeyType.X25519) {
      throw new Error('Secret derivation is only supported for X25519 keys');
    }
    if (!this.privateKeyMultibase) {
      throw new Error('No private key available for deriving secret');
    }
    const privateKey = Multikey.decodePrivateKey(this.privateKeyMultibase).privateKey;
    const peerPublicKey = Multikey.decodePublicKey(peerKey.publicKeyMultibase).publicKey;
    return x25519.sharedKey(privateKey, peerPublicKey);
  }

  async encrypt(data: Uint8Array, recipientPublicKey: Multikey): Promise<Uint8Array> {
    if (this.keyType !== KeyType.X25519 || recipientPublicKey.keyType !== KeyType.X25519) {
      throw new Error('Encryption is only supported for X25519 keys');
    }
    const sharedSecret = await this.deriveSecret(recipientPublicKey);
    const cipher = new XChaCha20Poly1305(sharedSecret);
    const nonce = x25519.generateKeyPair().publicKey.subarray(0, 24); // Use first 24 bytes as nonce
    return cipher.seal(nonce, data);
  }

  async decrypt(data: Uint8Array, senderPublicKey: Multikey): Promise<Uint8Array> {
    if (this.keyType !== KeyType.X25519 || senderPublicKey.keyType !== KeyType.X25519) {
      throw new Error('Decryption is only supported for X25519 keys');
    }
    const sharedSecret = await this.deriveSecret(senderPublicKey);
    const cipher = new XChaCha20Poly1305(sharedSecret);
    const nonce = data.subarray(0, 24);
    const ciphertext = data.subarray(24);
    const decrypted = cipher.open(nonce, ciphertext);
    if (!decrypted) {
      throw new Error('Decryption failed');
    }
    return decrypted;
  }

  static encodePublicKey(publicKey: Uint8Array, keyType: KeyType): string {
    let header: Uint8Array;
    switch (keyType) {
      case KeyType.Ed25519:
        header = MULTICODEC_ED25519_PUB_HEADER;
        break;
      case KeyType.X25519:
        header = MULTICODEC_X25519_PUB_HEADER;
        break;
      case KeyType.Secp256k1:
        header = MULTICODEC_SECP256K1_PUB_HEADER;
        break;
      default:
        throw new Error('Unsupported key type');
    }
    return multibase.encode(header, publicKey);
  }

  static encodePrivateKey(privateKey: Uint8Array, keyType: KeyType): string {
    let header: Uint8Array;
    switch (keyType) {
      case KeyType.Ed25519:
        header = MULTICODEC_ED25519_PRIV_HEADER;
        break;
      case KeyType.X25519:
        header = MULTICODEC_X25519_PRIV_HEADER;
        break;
      case KeyType.Secp256k1:
        header = MULTICODEC_SECP256K1_PRIV_HEADER;
        break;
      default:
        throw new Error('Unsupported key type');
    }
    return multibase.encode(header, privateKey);
  }

  static decodePublicKey(publicKeyMultibase: string): { keyType: KeyType; publicKey: Uint8Array } {
    if (!publicKeyMultibase.startsWith('z')) {
      throw new Error('Invalid Multibase encoding');
    }
    const decoded = base58.decode(publicKeyMultibase.slice(1));
    const header = decoded.slice(0, 2);
    const publicKey = decoded.slice(2);

    if (header[0] === MULTICODEC_ED25519_PUB_HEADER[0] && header[1] === MULTICODEC_ED25519_PUB_HEADER[1]) {
      return { keyType: KeyType.Ed25519, publicKey };
    } else if (header[0] === MULTICODEC_X25519_PUB_HEADER[0] && header[1] === MULTICODEC_X25519_PUB_HEADER[1]) {
      return { keyType: KeyType.X25519, publicKey };
    } else if (header[0] === MULTICODEC_SECP256K1_PUB_HEADER[0] && header[1] === MULTICODEC_SECP256K1_PUB_HEADER[1]) {
      return { keyType: KeyType.Secp256k1, publicKey };
    } else {
      throw new Error('Unsupported key type');
    }
  }

  static decodePrivateKey(privateKeyMultibase: string): { keyType: KeyType; privateKey: Uint8Array } {
    if (!privateKeyMultibase.startsWith('z')) {
      throw new Error('Invalid Multibase encoding');
    }
    const decoded = base58.decode(privateKeyMultibase.slice(1));
    const header = decoded.slice(0, 2);
    const privateKey = decoded.slice(2);

    if (header[0] === MULTICODEC_ED25519_PRIV_HEADER[0] && header[1] === MULTICODEC_ED25519_PRIV_HEADER[1]) {
      return { keyType: KeyType.Ed25519, privateKey };
    } else if (header[0] === MULTICODEC_X25519_PRIV_HEADER[0] && header[1] === MULTICODEC_X25519_PRIV_HEADER[1]) {
      return { keyType: KeyType.X25519, privateKey };
    } else if (header[0] === MULTICODEC_SECP256K1_PRIV_HEADER[0] && header[1] === MULTICODEC_SECP256K1_PRIV_HEADER[1]) {
      return { keyType: KeyType.Secp256k1, privateKey };
    } else {
      throw new Error('Unsupported key type');
    }
  }

  async export(
    options: {
      privateKey?: boolean;
      type: 'JsonWebKey2020';
    } = {
      privateKey: false,
      type: 'JsonWebKey2020'
    }
  ): Promise<JsonWebKey2020> {
    let publicKeyJwk: any;
    let privateKeyJwk: any;

    const publicKey = Multikey.decodePublicKey(this.publicKeyMultibase).publicKey;
    const privateKey = this.privateKeyMultibase ? Multikey.decodePrivateKey(this.privateKeyMultibase).privateKey : undefined;

    switch (this.keyType) {
      case KeyType.Ed25519:
      case KeyType.X25519:
        publicKeyJwk = {
          kty: 'OKP',
          crv: this.keyType === KeyType.Ed25519 ? 'Ed25519' : 'X25519',
          x: base64url.encode(publicKey)
        };
        if (options.privateKey && privateKey) {
          privateKeyJwk = {
            ...publicKeyJwk,
            d: base64url.encode(privateKey)
          };
        }
        break;
      case KeyType.Secp256k1:
        const point = secp.ProjectivePoint.fromHex(secp.etc.bytesToHex(publicKey));
        publicKeyJwk = {
          kty: 'EC',
          crv: 'secp256k1',
          x: base64url.encode(secp.etc.numberToBytesBE(point.x)),
          y: base64url.encode(secp.etc.numberToBytesBE(point.y))
        };
        if (options.privateKey && privateKey) {
          privateKeyJwk = {
            ...publicKeyJwk,
            d: base64url.encode(privateKey)
          };
        }
        break;
      default:
        throw new Error('Unsupported key type');
    }

    return {
      id: this.id,
      type: 'JsonWebKey2020',
      controller: this.controller,
      publicKeyJwk,
      privateKeyJwk
    };
  }

  toJSON() {
    const json: any = {
      '@context': ['https://w3id.org/security/multikey/v1'],
      id: this.id,
      type: this.type,
      controller: this.controller,
      publicKeyMultibase: this.publicKeyMultibase,
    };
    if (this.privateKeyMultibase) {
      json.privateKeyMultibase = this.privateKeyMultibase;
    }
    return json;
  }
}

================
File: src/lib/crypto/keypairs/Secp256k1KeyPair.ts
================
import { Multikey, KeyType } from './Multikey';
import { base58, multibase, MULTICODEC_SECP256K1_PUB_HEADER, MULTICODEC_SECP256K1_PRIV_HEADER } from '../utils/encoding';
import type { JsonWebKey2020 } from './JsonWebKey2020';
import { HDKey } from "@scure/bip32";
import { hmac } from '@noble/hashes/hmac';
import { sha256 } from '@noble/hashes/sha256';
import * as secp from '@noble/secp256k1';
import { Buffer } from 'buffer/index.js';

secp.etc.hmacSha256Sync = (k, ...m) => hmac(sha256, k, secp.etc.concatBytes(...m));

export class Secp256k1KeyPair {
  multikey: Multikey;

  constructor(id: string, controller: string, publicKeyBase58: string, privateKeyBase58?: string) {
    this.multikey = new Multikey(
      KeyType.Secp256k1,
      id,
      controller,
      base58.decode(publicKeyBase58),
      privateKeyBase58 ? base58.decode(privateKeyBase58) : undefined
    );
  }

  get id(): string {
    return this.multikey.id;
  }

  get type(): string {
    return 'EcdsaSecp256k1VerificationKey2019';
  }

  get controller(): string {
    return this.multikey.controller;
  }

	get publicKey(): Uint8Array {
    return this.multikey.publicKey;
  }

	get privateKey(): Uint8Array | undefined {
    return this.multikey.privateKey;
  }

  get publicKeyBase58(): string {
    return base58.encode(multibase.decode(MULTICODEC_SECP256K1_PUB_HEADER, this.multikey.publicKeyMultibase));
  }

  get privateKeyBase58(): string | undefined {
    return this.multikey.privateKeyMultibase
      ? base58.encode(multibase.decode(MULTICODEC_SECP256K1_PRIV_HEADER, this.multikey.privateKeyMultibase))
      : undefined;
  }

  static async generate(): Promise<Secp256k1KeyPair> {
    const multikey = await Multikey.generate(KeyType.Secp256k1);
    return new Secp256k1KeyPair(
      multikey.id,
      multikey.controller,
      base58.encode(multibase.decode(MULTICODEC_SECP256K1_PUB_HEADER, multikey.publicKeyMultibase)),
      multikey.privateKeyMultibase
        ? base58.encode(multibase.decode(MULTICODEC_SECP256K1_PRIV_HEADER, multikey.privateKeyMultibase))
        : undefined
    );
  }

  static from(options: { id?: string, controller?: string, publicKeyBase58: string, privateKeyBase58?: string }): Secp256k1KeyPair {
    return new Secp256k1KeyPair(
      options.id ?? `#${options.publicKeyBase58.slice(0, 8)}`,
      options.controller ?? `#${options.publicKeyBase58.slice(0, 8)}`,
      options.publicKeyBase58,
      options.privateKeyBase58
    );
  }

  static async fromJWK(k: JsonWebKey2020): Promise<Secp256k1KeyPair> {
    const { x, y } = k.publicKeyJwk;
    if (!x || !y) throw new Error('Invalid public key');
    const xInt = BigInt('0x' + Buffer.from(x, 'base64').toString('hex'));
    const yInt = BigInt('0x' + Buffer.from(y, 'base64').toString('hex'));
    const pubKey = secp.ProjectivePoint.fromAffine({x: xInt, y: yInt}).toRawBytes();
    let privKey;
    if (k.privateKeyJwk && k.privateKeyJwk.d) {
      privKey = Buffer.from(k.privateKeyJwk.d, 'base64');
    }
    return new Secp256k1KeyPair(k.id, k.controller, base58.encode(pubKey), privKey ? base58.encode(privKey) : undefined);
  }

  static async fromXpub(xpub: string): Promise<Secp256k1KeyPair | null> {
    const hd = HDKey.fromExtendedKey(xpub);
    if (hd.publicKey) {
      const fingerprint = multibase.encode(MULTICODEC_SECP256K1_PUB_HEADER, hd.publicKey);
      const controller = `did:key:${fingerprint}`;
      const id = `${controller}#${fingerprint}`;
      return new Secp256k1KeyPair(id, controller, base58.encode(hd.publicKey));
    }
    return null;
  }

  async sign(data: Uint8Array): Promise<Uint8Array> {
    return this.multikey.sign(data);
  }

  async verify(data: Uint8Array, signature: Uint8Array): Promise<boolean> {
    return this.multikey.verify(data, signature);
  }

  async export(options?: { privateKey?: boolean; type: 'JsonWebKey2020' }): Promise<JsonWebKey2020> {
    return this.multikey.export(options);
  }

  toJSON() {
    return {
      id: this.id,
      type: this.type,
      controller: this.controller,
      publicKeyBase58: this.publicKeyBase58
    };
  }
}

================
File: src/lib/crypto/keypairs/X25519KeyAgreementKey2019.ts
================
import { Multikey, KeyType } from './Multikey';
import { base58, base64url, multibase, MULTICODEC_X25519_PRIV_HEADER, MULTICODEC_X25519_PUB_HEADER } from '../utils/encoding';
import type { JsonWebKey2020 } from './JsonWebKey2020';

export class X25519KeyAgreementKey2019 {
  multikey: Multikey;

  constructor(id: string, controller: string, publicKeyBase58: string, privateKeyBase58?: string) {
    this.multikey = new Multikey(KeyType.X25519, id, controller, base58.decode(publicKeyBase58), privateKeyBase58 ? base58.decode(privateKeyBase58) : undefined);
  }

  get id(): string {
    return this.multikey.id;
  }

  get type(): string {
    return 'X25519KeyAgreementKey2019';
  }

  get controller(): string {
    return this.multikey.controller;
  }

  get publicKeyBase58(): string {
    return base58.encode(multibase.decode(MULTICODEC_X25519_PUB_HEADER, this.multikey.publicKeyMultibase));
  }

  get privateKeyBase58(): string | undefined {
    return this.multikey.privateKeyMultibase
      ? base58.encode(multibase.decode(MULTICODEC_X25519_PRIV_HEADER, this.multikey.privateKeyMultibase))
      : undefined;
  }

  static async generate(): Promise<X25519KeyAgreementKey2019> {
    const multikey = await Multikey.generate(KeyType.X25519);
    return new X25519KeyAgreementKey2019(
      multikey.id,
      multikey.controller,
      base58.encode(multibase.decode(MULTICODEC_X25519_PUB_HEADER, multikey.publicKeyMultibase)),
      multikey.privateKeyMultibase
        ? base58.encode(multibase.decode(MULTICODEC_X25519_PRIV_HEADER, multikey.privateKeyMultibase))
        : undefined
    );
  }

  static from(options: { id?: string, controller?: string, publicKeyBase58: string, privateKeyBase58?: string }): X25519KeyAgreementKey2019 {
    return new X25519KeyAgreementKey2019(
      options.id ?? `#${options.publicKeyBase58.slice(0, 8)}`,
      options.controller ?? `#${options.publicKeyBase58.slice(0, 8)}`,
      options.publicKeyBase58,
      options.privateKeyBase58
    );
  }

	static fromJWK = async (k: JsonWebKey2020) => {
		let publicKey, privateKey;
		if (!k.publicKeyJwk.x)
			throw new Error('Public Key Not found')
		publicKey = base58.encode(base64url.decode(k.publicKeyJwk.x));
		if (k.privateKeyJwk && k.privateKeyJwk.d) {
			privateKey = base58.encode(base64url.decode(k.privateKeyJwk.d));
		}
		return new X25519KeyAgreementKey2019(k.id, k.controller, publicKey, privateKey);
	};

  async deriveSecret(publicKey: X25519KeyAgreementKey2019): Promise<Uint8Array> {
    return this.multikey.deriveSecret(publicKey.multikey);
  }

  async encrypt(data: Uint8Array, recipientPublicKey: X25519KeyAgreementKey2019): Promise<Uint8Array> {
    const recipientMultikey = new Multikey(
      KeyType.X25519,
      recipientPublicKey.id,
      recipientPublicKey.controller,
      base58.decode(recipientPublicKey.publicKeyBase58)
    );
    return this.multikey.encrypt(data, recipientMultikey);
  }

  async decrypt(data: Uint8Array, senderPublicKey: X25519KeyAgreementKey2019): Promise<Uint8Array> {
    const senderMultikey = new Multikey(
      KeyType.X25519,
      senderPublicKey.id,
      senderPublicKey.controller,
      base58.decode(senderPublicKey.publicKeyBase58)
    );
    return this.multikey.decrypt(data, senderMultikey);
  }

  async export(options?: { privateKey?: boolean; type: 'JsonWebKey2020' }): Promise<JsonWebKey2020> {
    return this.multikey.export(options);
  }

  toJSON() {
    return {
      id: this.id,
      type: this.type,
      controller: this.controller,
      publicKeyBase58: this.publicKeyBase58
    };
  }
}

================
File: src/lib/crypto/keypairs/X25519KeyAgreementKey2020.ts
================
import { Multikey, KeyType } from './Multikey';
import { base58, multibase, MULTICODEC_X25519_PRIV_HEADER, MULTICODEC_X25519_PUB_HEADER } from '../utils/encoding';
import * as x25519 from '@stablelib/x25519';
import { X25519KeyAgreementKey2019 } from './X25519KeyAgreementKey2019';

export class X25519KeyAgreementKey2020 {
  multikey: Multikey;

  constructor(id: string, controller: string, publicKeyMultibase: string, privateKeyMultibase?: string) {
    const publicKey = multibase.decode(MULTICODEC_X25519_PUB_HEADER, publicKeyMultibase);
    const privateKey = privateKeyMultibase ? multibase.decode(MULTICODEC_X25519_PRIV_HEADER, privateKeyMultibase) : undefined;
    this.multikey = new Multikey(KeyType.X25519, id, controller, publicKey, privateKey);
  }

  get id(): string {
    return this.multikey.id;
  }
  
  get type(): string {
    return 'X25519KeyAgreementKey2020';
  }

  get controller(): string {
    return this.multikey.controller;
  }

  get publicKeyMultibase(): string {
    return this.multikey.publicKeyMultibase;
  }

  get privateKeyMultibase(): string | undefined {
    return this.multikey.privateKeyMultibase;
  }

	get publicKey(): Uint8Array {
    return this.multikey.publicKey;
  }

	get privateKey(): Uint8Array | undefined {
    return this.multikey.privateKey;
  }

  static async generate(): Promise<X25519KeyAgreementKey2020> {
    const keyPair = x25519.generateKeyPair();
    const publicKeyMultibase = multibase.encode(MULTICODEC_X25519_PUB_HEADER, keyPair.publicKey);
    const privateKeyMultibase = multibase.encode(MULTICODEC_X25519_PRIV_HEADER, keyPair.secretKey);
    const fingerprint = publicKeyMultibase;
    const controller = `did:key:${fingerprint}`;
    const id = `${controller}#${fingerprint}`;
    return new X25519KeyAgreementKey2020(id, controller, publicKeyMultibase, privateKeyMultibase);
  }

	static from(options: { id?: string, controller?: string, publicKeyBase58?: string, privateKeyBase58?: string, publicKeyMultibase?: string, privateKeyMultibase?: string }): X25519KeyAgreementKey2020 {
    const publicKeyMultibase = options.publicKeyMultibase ?? multibase.encode(MULTICODEC_X25519_PUB_HEADER, base58.decode(options.publicKeyBase58 as string));
    let privateKeyMultibase = options.privateKeyMultibase;
    if (!privateKeyMultibase) {
      privateKeyMultibase = options.privateKeyBase58
      ? multibase.encode(MULTICODEC_X25519_PRIV_HEADER, base58.decode(options.privateKeyBase58 as string))
      : undefined;
    }
    return new X25519KeyAgreementKey2020(
      options.id ?? `#${publicKeyMultibase.slice(0, 8)}`,
      options.controller ?? `#${publicKeyMultibase.slice(0, 8)}`,
      publicKeyMultibase,
      privateKeyMultibase
    );
  }

  async deriveSecret(publicKey: X25519KeyAgreementKey2020): Promise<Uint8Array> {
    if (!this.multikey.privateKeyMultibase) {
      throw new Error('No private key available for deriving secret');
    }
    // const privateKey = multibase.decode(MULTICODEC_X25519_PRIV_HEADER, this.multikey.privateKeyMultibase);
    // const peerPublicKey = multibase.decode(MULTICODEC_X25519_PUB_HEADER, publicKey.publicKeyMultibase);
    return this.multikey.deriveSecret(publicKey.multikey);
    // return x25519.sharedKey(privateKey, peerPublicKey);
  }

  async export(options?: { privateKey?: boolean; type: 'JsonWebKey2020' }): Promise<any> {
    return this.multikey.export(options);
  }
}

================
File: src/lib/crypto/LDP/proof.ts
================
import type { ILinkedDataProof } from "../../common/interfaces";

export interface ProofJSON {
  type: string;
  proofPurpose: string;
  verificationMethod: string;
  created: string;
  challenge?: string;
  domain?: string;
}
export class LinkedDataProof implements ILinkedDataProof {
  public type: string;
  public proofPurpose: string;
  public created: string;
  public verificationMethod: string;
  public challenge?: string;
  public domain?: string;

  constructor(
    type: string,
    proofPurpose: string,
    verificationMethod: string,
    challenge?: string,
    domain?: string,
    created?: string
  ) {
    this.type = type;
    this.proofPurpose = proofPurpose;
    this.verificationMethod = verificationMethod;
    this.challenge = challenge;
    this.domain = domain;
    this.created = created ?? this.generateTimestamp();
  }

  private generateTimestamp(): string {
    const date = new Date().toISOString();
    return date.slice(0, -5) + 'Z';
  }

  public validate(maxTimestampDelta: number | null = null): boolean {
    if (maxTimestampDelta !== null && maxTimestampDelta !== Infinity) {
      const expected = new Date().getTime();
      const delta = maxTimestampDelta * 1000;
      const created = new Date(this.created).getTime();
      
      if (isNaN(created) || created < expected - delta || created > expected + delta) {
        console.error("The proof's created timestamp is out of range.");
        return false;
      }
    }
    return true;
  }

  public toJSON(): ProofJSON {
    const json: ProofJSON = {
      type: this.type,
      proofPurpose: this.proofPurpose,
      verificationMethod: this.verificationMethod,
      created: this.created
    };

    if (this.challenge) {
      json.challenge = this.challenge;
    }

    if (this.domain) {
      json.domain = this.domain;
    }

    return json;
  }
}

================
File: src/lib/crypto/utils/encoding.ts
================
// @ts-ignore
import b58 from 'b58';
import { Buffer } from 'buffer/index.js';

// multibase base58-btc header
export const MULTIBASE_BASE58BTC_HEADER = 'z';
// multicodec ed25519-pub header as varint
export const MULTICODEC_ED25519_PUB_HEADER = new Uint8Array([0xed, 0x01]);
// multicodec ed25519-priv header as varint
export const MULTICODEC_ED25519_PRIV_HEADER = new Uint8Array([0x80, 0x26]);
// multicodec x25519-pub header as varint
export const MULTICODEC_X25519_PUB_HEADER = new Uint8Array([0xec, 0x01]);
// multicodec x25519-priv header as varint
export const MULTICODEC_X25519_PRIV_HEADER = new Uint8Array([0x82, 0x26]);
// multicode secp256k1-pub header as varint
export const MULTICODEC_SECP256K1_PUB_HEADER = new Uint8Array([0xe7, 0x01]);
// multicode secp256k1-priv header as varint
export const MULTICODEC_SECP256K1_PRIV_HEADER = new Uint8Array([0x13, 0x01]);

export const base64 = {
	encode: (unencoded: any): string => {
		return Buffer.from(unencoded || '').toString('base64');
	},
	decode: (encoded: any): Uint8Array => {
		return new Uint8Array(Buffer.from(encoded || '', 'base64').buffer);
	}
};

export const utf8 = {
	encode: (unencoded: string): Uint8Array => {
		return new TextEncoder().encode(unencoded)
	},
	decode: (encoded: Uint8Array): string => {
		return new TextDecoder().decode(encoded);
	}
}

export const base64url = {
	encode: (unencoded: any): string => {
		var encoded = base64.encode(unencoded);
		return encoded.replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/g, '');
	},
	decode: (encoded: any): Uint8Array => {
		encoded = encoded.replace(/-/g, '+').replace(/_/g, '/');
		while (encoded.length % 4) encoded += '=';
		return base64.decode(encoded);
	}
};

export const base58 = {
	encode: (unencoded: Uint8Array): string => {
		return b58.encode(unencoded);
	},
	decode: (encoded: string): Uint8Array => {
		return b58.decode(encoded);
	}
};

export const multibase = {
	encode: (header: Uint8Array, val: Uint8Array): string => {
		let mcBytes;
		if (header.length > 0) {
			mcBytes = new Uint8Array(header.length + val.length);
			mcBytes.set(header)
			mcBytes.set(val, header.length)
		}
		return MULTIBASE_BASE58BTC_HEADER + base58.encode(mcBytes ?? val)
	},
	decode: (header: Uint8Array, val: string): Uint8Array => {
		const mcValue = base58.decode(val.substring(1))
		for (let i = 0; i < header.length; i++) {
			if (mcValue[i] !== header[i]) {
				throw new Error('Multibase value does not have expected header.')
			}
		}
		return mcValue.slice(header.length)
	}
}

export function bigIntToBuf(bn: bigint): Uint8Array {
  var hex = BigInt(bn).toString(16);
  if (hex.length % 2) { hex = '0' + hex; }

  var len = hex.length / 2;
  var u8 = new Uint8Array(len);

  var i = 0;
  var j = 0;
  while (i < len) {
    u8[i] = parseInt(hex.slice(j, j+2), 16);
    i += 1;
    j += 2;
  }

  return u8;
}

================
File: src/lib/crypto/utils/sha256.ts
================
import { hash } from '@stablelib/sha256';
import { Buffer } from 'buffer/index.js';

export const sha256Uint8Array = (val: Uint8Array): Buffer => {
	return Buffer.from(hash(Buffer.from(val)));
};

export function stringToUint8Array(data: any) {
	if (typeof data === 'string') {
		// convert data to Uint8Array
		return new Uint8Array(Buffer.from(data));
	}
	if (!(data instanceof Uint8Array)) {
		throw new TypeError('"data" be a string or Uint8Array.');
	}
	return data;
}

export const sha256 = (val: string): string => {
	return Buffer.from(hash(Buffer.from(val))).toString('hex');
};

export const sha256buffer = (val: string): Buffer => {
	return Buffer.from(hash(Buffer.from(val)));
};

export const sha256pow = (
	source: string,
	target: string,
	data: string,
	user: string = 'anon',
	nonce: number = 0,
	iterations: number = 1,
	budget: number = 1000000, // about 10s worst case
	positionalReferenceHash: string = ''
) => {
	console.log(
		`sha256 mining - s:${source} t:${target} d:${data} i:${iterations} n:${nonce} b:${budget} u:${user}`
	);
	let found = [];
	let rotation: string;
	let totalRotations = 0;
	const limit = budget + nonce; //Our max nonce based on the starting value and budget provided

	for (let i = nonce; i < limit && found.length !== iterations; i++) {
		rotation = sha256(source + sha256(data) + target + user + i);
		//Check that we have found a full result
		if (rotation.slice(0, target.length) === target && rotation > positionalReferenceHash) {
			const timestamp = Math.round(new Date().getTime() / 1000);
			console.log(`found slot ${rotation}`);
			const item = {
				data: data,
				datahash: sha256(data),
				n: i,
				rotation: rotation,
				source: source,
				target: target,
				timestamp: timestamp,
				user: user
			};
			//Return item
			found.push(item);
		}
		totalRotations++;
	}
	console.log(`finished mining after ${totalRotations} rotations`);
	return found;
};

================
File: src/lib/crypto/utils/staticImplements.ts
================
export function staticImplements<T>() {
  return <U extends T>(constructor: U) => {
    constructor;
  };
}

================
File: src/lib/crypto/utils/vcs.ts
================
import jsonld from "jsonld";
import { sha256buffer } from "../utils/sha256.js";
import { Buffer } from 'buffer/index.js';

export async function canonize(input: any, { documentLoader }: any) {
  return await jsonld.canonize(input, {
    algorithm: 'URDNA2015',
    format: 'application/n-quads',
    documentLoader,
    useNative: false
  });
}

export async function canonizeProof(proof: any, { documentLoader }: any) {
  // `jws`,`signatureValue`,`proofValue` must not be included in the proof
  const { jws, signatureValue, proofValue, ...rest } = proof;
  return await canonize(rest, {
    documentLoader
  });
}
export async function createVerifyData({ document, proof, documentLoader }: any) {
  // concatenate hash of c14n proof options and hash of c14n document
  if (!proof['@context']) {
    proof['@context'] = document['@context']
  }
  const c14nProofOptions = await canonizeProof(proof, {
    documentLoader
  });
  const c14nDocument = await canonize(document, {
    documentLoader    
  });
  return Buffer.concat([sha256buffer(c14nProofOptions), sha256buffer(c14nDocument)]);
}

================
File: src/lib/crypto/constants.ts
================
export type JWA_ALG =
  | "ES256K"
  | "ES256K-R"
  | "SS256K"
  | "EdDSA"
  | "ES256"
  | "ES384"
  | "ES512";

================
File: src/lib/crypto/index.ts
================
// Export constants
export * from './constants';

// Export interfaces
export * from '../common/interfaces';

// Export utility functions
export * from './utils/encoding';
export * from './utils/sha256';
export * from './utils/vcs';

// Export keypairs
export * from './keypairs/BaseKeyPair';
export * from './keypairs/Ed25519VerificationKey2018';
export * from './keypairs/Ed25519VerificationKey2020';
export * from './keypairs/JsonWebKey2020';
export * from './keypairs/Secp256k1KeyPair';
export * from './keypairs/X25519KeyAgreementKey2019';
export * from './keypairs/X25519KeyAgreementKey2020';
export * from './keypairs/HD';

// Export JWS
export * from './JWS/Suite';

// Export JWE
export * from './JWE/Suite';

// Export JWT
export * from './JWT/Suite';

// Export LDP
export * from './LDP/proof';

================
File: src/lib/crypto/mnemonic.ts
================
import { deriveKey } from "@stablelib/pbkdf2"
import { SHA512 } from "@stablelib/sha512"
import { utf8 } from "./utils/encoding.js";
import { sha256Uint8Array } from "./utils/sha256.js";

function normalize(str: string) {
  const norm = str.normalize('NFKD');
  const words = norm.split(' ');
  if (![12, 15, 18, 21, 24].includes(words.length)) throw new Error('Invalid mnemonic');
  return { nfkd: norm, words };
}

export const hexToBytes = (hexString: string): Uint8Array => {
  const pairs = hexString.match(/.{1,2}/g)
  if (!pairs) {
    throw new Error('Tried to convert invalid hex to bytes')
  }
  return new Uint8Array(pairs.map(byte => parseInt(byte, 16)));
};

export const bytesToHex = (bytes: Uint8Array): string => {
  return bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');
};

export const lpad = (str: string, padString: string, length: number): string => {
  while (str.length < length) {
      str = padString + str;
  }

  return str;
};

export const bytesToBinary = (bytes: number[]): string => {
  return bytes.map(x => lpad(x.toString(2), '0', 8)).join('');
};

export const deriveChecksumBits = (entropy: Uint8Array): string => {
  const ENT = entropy.length * 8;
  const CS = ENT / 32;

  const hash = sha256Uint8Array(entropy);

  return bytesToBinary(Array.from(hash)).slice(0, CS);
};

export function mnemonicToEntropy(mnemonic: string): string {
  var seedWords = normalize(mnemonic).nfkd.split(' ');

  if (seedWords.length % 3 !== 0) {
      throw new Error('INVALID_MNEMONIC');
  }

  var bits = seedWords
      .map(function (word: string) {
          var index = words.indexOf(word);
          if (index === -1) {
              throw new Error('INVALID_MNEMONIC');
          }
          return lpad(index.toString(2), '0', 11);
      })
      .join('');

  var dividerIndex = Math.floor(bits.length / 33) * 32;
  var entropyBits = bits.slice(0, dividerIndex);
  var checksumBits = bits.slice(dividerIndex);
  var entropyBytes = entropyBits.match(/(.{1,8})/g)?.map(v => parseInt(v, 2));

  if (!entropyBytes || entropyBytes.length < 16 || entropyBytes.length > 32 || entropyBytes.length % 4 !== 0) {
      throw new Error('INVALID_ENTROPY');
  }

  var entropy = entropyBytes;
  var newChecksum = deriveChecksumBits(Uint8Array.from(entropy));

  if (newChecksum !== checksumBits) {
      throw new Error('INVALID_CHECKSUM');
  }

  return bytesToHex(Uint8Array.from(entropy));
}

// takes in 16 to 32 bytes of entropy and creates a mnemonic seed phrase
export const entropyToMnemonic = (input: string | Uint8Array): string => {
  const entropy = typeof input === 'string' ? hexToBytes(input) : input;

  if (entropy.length < 16 || entropy.length > 32 || entropy.length % 4 !== 0) {
      throw new Error('INVALID_ENTROPY');
  }

  const entropyBits = bytesToBinary(Array.from(entropy));
  const checksumBits = deriveChecksumBits(entropy);

  const bits = entropyBits + checksumBits;
  const chunks = bits.match(/(.{1,11})/g);
  const seedWords = chunks?.map((binary: string) => {
      const index = parseInt(binary, 2);
      return words[index];
  });
  
  if (!seedWords) {
    throw new Error('Invalid seed generated')
  }

  return seedWords.join(' ');
};

export const mnemonicToSeed = (mnemonic: string, passphrase: string = ''): string => {
  const bytes = deriveKey(SHA512, utf8.encode(normalize(mnemonic).nfkd), utf8.encode(`mnemonic${passphrase}`), 2048, 64)
  return bytesToHex(bytes)
}

export const words = [
  "abandon",
  "ability",
  "able",
  "about",
  "above",
  "absent",
  "absorb",
  "abstract",
  "absurd",
  "abuse",
  "access",
  "accident",
  "account",
  "accuse",
  "achieve",
  "acid",
  "acoustic",
  "acquire",
  "across",
  "act",
  "action",
  "actor",
  "actress",
  "actual",
  "adapt",
  "add",
  "addict",
  "address",
  "adjust",
  "admit",
  "adult",
  "advance",
  "advice",
  "aerobic",
  "affair",
  "afford",
  "afraid",
  "again",
  "age",
  "agent",
  "agree",
  "ahead",
  "aim",
  "air",
  "airport",
  "aisle",
  "alarm",
  "album",
  "alcohol",
  "alert",
  "alien",
  "all",
  "alley",
  "allow",
  "almost",
  "alone",
  "alpha",
  "already",
  "also",
  "alter",
  "always",
  "amateur",
  "amazing",
  "among",
  "amount",
  "amused",
  "analyst",
  "anchor",
  "ancient",
  "anger",
  "angle",
  "angry",
  "animal",
  "ankle",
  "announce",
  "annual",
  "another",
  "answer",
  "antenna",
  "antique",
  "anxiety",
  "any",
  "apart",
  "apology",
  "appear",
  "apple",
  "approve",
  "april",
  "arch",
  "arctic",
  "area",
  "arena",
  "argue",
  "arm",
  "armed",
  "armor",
  "army",
  "around",
  "arrange",
  "arrest",
  "arrive",
  "arrow",
  "art",
  "artefact",
  "artist",
  "artwork",
  "ask",
  "aspect",
  "assault",
  "asset",
  "assist",
  "assume",
  "asthma",
  "athlete",
  "atom",
  "attack",
  "attend",
  "attitude",
  "attract",
  "auction",
  "audit",
  "august",
  "aunt",
  "author",
  "auto",
  "autumn",
  "average",
  "avocado",
  "avoid",
  "awake",
  "aware",
  "away",
  "awesome",
  "awful",
  "awkward",
  "axis",
  "baby",
  "bachelor",
  "bacon",
  "badge",
  "bag",
  "balance",
  "balcony",
  "ball",
  "bamboo",
  "banana",
  "banner",
  "bar",
  "barely",
  "bargain",
  "barrel",
  "base",
  "basic",
  "basket",
  "battle",
  "beach",
  "bean",
  "beauty",
  "because",
  "become",
  "beef",
  "before",
  "begin",
  "behave",
  "behind",
  "believe",
  "below",
  "belt",
  "bench",
  "benefit",
  "best",
  "betray",
  "better",
  "between",
  "beyond",
  "bicycle",
  "bid",
  "bike",
  "bind",
  "biology",
  "bird",
  "birth",
  "bitter",
  "black",
  "blade",
  "blame",
  "blanket",
  "blast",
  "bleak",
  "bless",
  "blind",
  "blood",
  "blossom",
  "blouse",
  "blue",
  "blur",
  "blush",
  "board",
  "boat",
  "body",
  "boil",
  "bomb",
  "bone",
  "bonus",
  "book",
  "boost",
  "border",
  "boring",
  "borrow",
  "boss",
  "bottom",
  "bounce",
  "box",
  "boy",
  "bracket",
  "brain",
  "brand",
  "brass",
  "brave",
  "bread",
  "breeze",
  "brick",
  "bridge",
  "brief",
  "bright",
  "bring",
  "brisk",
  "broccoli",
  "broken",
  "bronze",
  "broom",
  "brother",
  "brown",
  "brush",
  "bubble",
  "buddy",
  "budget",
  "buffalo",
  "build",
  "bulb",
  "bulk",
  "bullet",
  "bundle",
  "bunker",
  "burden",
  "burger",
  "burst",
  "bus",
  "business",
  "busy",
  "butter",
  "buyer",
  "buzz",
  "cabbage",
  "cabin",
  "cable",
  "cactus",
  "cage",
  "cake",
  "call",
  "calm",
  "camera",
  "camp",
  "can",
  "canal",
  "cancel",
  "candy",
  "cannon",
  "canoe",
  "canvas",
  "canyon",
  "capable",
  "capital",
  "captain",
  "car",
  "carbon",
  "card",
  "cargo",
  "carpet",
  "carry",
  "cart",
  "case",
  "cash",
  "casino",
  "castle",
  "casual",
  "cat",
  "catalog",
  "catch",
  "category",
  "cattle",
  "caught",
  "cause",
  "caution",
  "cave",
  "ceiling",
  "celery",
  "cement",
  "census",
  "century",
  "cereal",
  "certain",
  "chair",
  "chalk",
  "champion",
  "change",
  "chaos",
  "chapter",
  "charge",
  "chase",
  "chat",
  "cheap",
  "check",
  "cheese",
  "chef",
  "cherry",
  "chest",
  "chicken",
  "chief",
  "child",
  "chimney",
  "choice",
  "choose",
  "chronic",
  "chuckle",
  "chunk",
  "churn",
  "cigar",
  "cinnamon",
  "circle",
  "citizen",
  "city",
  "civil",
  "claim",
  "clap",
  "clarify",
  "claw",
  "clay",
  "clean",
  "clerk",
  "clever",
  "click",
  "client",
  "cliff",
  "climb",
  "clinic",
  "clip",
  "clock",
  "clog",
  "close",
  "cloth",
  "cloud",
  "clown",
  "club",
  "clump",
  "cluster",
  "clutch",
  "coach",
  "coast",
  "coconut",
  "code",
  "coffee",
  "coil",
  "coin",
  "collect",
  "color",
  "column",
  "combine",
  "come",
  "comfort",
  "comic",
  "common",
  "company",
  "concert",
  "conduct",
  "confirm",
  "congress",
  "connect",
  "consider",
  "control",
  "convince",
  "cook",
  "cool",
  "copper",
  "copy",
  "coral",
  "core",
  "corn",
  "correct",
  "cost",
  "cotton",
  "couch",
  "country",
  "couple",
  "course",
  "cousin",
  "cover",
  "coyote",
  "crack",
  "cradle",
  "craft",
  "cram",
  "crane",
  "crash",
  "crater",
  "crawl",
  "crazy",
  "cream",
  "credit",
  "creek",
  "crew",
  "cricket",
  "crime",
  "crisp",
  "critic",
  "crop",
  "cross",
  "crouch",
  "crowd",
  "crucial",
  "cruel",
  "cruise",
  "crumble",
  "crunch",
  "crush",
  "cry",
  "crystal",
  "cube",
  "culture",
  "cup",
  "cupboard",
  "curious",
  "current",
  "curtain",
  "curve",
  "cushion",
  "custom",
  "cute",
  "cycle",
  "dad",
  "damage",
  "damp",
  "dance",
  "danger",
  "daring",
  "dash",
  "daughter",
  "dawn",
  "day",
  "deal",
  "debate",
  "debris",
  "decade",
  "december",
  "decide",
  "decline",
  "decorate",
  "decrease",
  "deer",
  "defense",
  "define",
  "defy",
  "degree",
  "delay",
  "deliver",
  "demand",
  "demise",
  "denial",
  "dentist",
  "deny",
  "depart",
  "depend",
  "deposit",
  "depth",
  "deputy",
  "derive",
  "describe",
  "desert",
  "design",
  "desk",
  "despair",
  "destroy",
  "detail",
  "detect",
  "develop",
  "device",
  "devote",
  "diagram",
  "dial",
  "diamond",
  "diary",
  "dice",
  "diesel",
  "diet",
  "differ",
  "digital",
  "dignity",
  "dilemma",
  "dinner",
  "dinosaur",
  "direct",
  "dirt",
  "disagree",
  "discover",
  "disease",
  "dish",
  "dismiss",
  "disorder",
  "display",
  "distance",
  "divert",
  "divide",
  "divorce",
  "dizzy",
  "doctor",
  "document",
  "dog",
  "doll",
  "dolphin",
  "domain",
  "donate",
  "donkey",
  "donor",
  "door",
  "dose",
  "double",
  "dove",
  "draft",
  "dragon",
  "drama",
  "drastic",
  "draw",
  "dream",
  "dress",
  "drift",
  "drill",
  "drink",
  "drip",
  "drive",
  "drop",
  "drum",
  "dry",
  "duck",
  "dumb",
  "dune",
  "during",
  "dust",
  "dutch",
  "duty",
  "dwarf",
  "dynamic",
  "eager",
  "eagle",
  "early",
  "earn",
  "earth",
  "easily",
  "east",
  "easy",
  "echo",
  "ecology",
  "economy",
  "edge",
  "edit",
  "educate",
  "effort",
  "egg",
  "eight",
  "either",
  "elbow",
  "elder",
  "electric",
  "elegant",
  "element",
  "elephant",
  "elevator",
  "elite",
  "else",
  "embark",
  "embody",
  "embrace",
  "emerge",
  "emotion",
  "employ",
  "empower",
  "empty",
  "enable",
  "enact",
  "end",
  "endless",
  "endorse",
  "enemy",
  "energy",
  "enforce",
  "engage",
  "engine",
  "enhance",
  "enjoy",
  "enlist",
  "enough",
  "enrich",
  "enroll",
  "ensure",
  "enter",
  "entire",
  "entry",
  "envelope",
  "episode",
  "equal",
  "equip",
  "era",
  "erase",
  "erode",
  "erosion",
  "error",
  "erupt",
  "escape",
  "essay",
  "essence",
  "estate",
  "eternal",
  "ethics",
  "evidence",
  "evil",
  "evoke",
  "evolve",
  "exact",
  "example",
  "excess",
  "exchange",
  "excite",
  "exclude",
  "excuse",
  "execute",
  "exercise",
  "exhaust",
  "exhibit",
  "exile",
  "exist",
  "exit",
  "exotic",
  "expand",
  "expect",
  "expire",
  "explain",
  "expose",
  "express",
  "extend",
  "extra",
  "eye",
  "eyebrow",
  "fabric",
  "face",
  "faculty",
  "fade",
  "faint",
  "faith",
  "fall",
  "false",
  "fame",
  "family",
  "famous",
  "fan",
  "fancy",
  "fantasy",
  "farm",
  "fashion",
  "fat",
  "fatal",
  "father",
  "fatigue",
  "fault",
  "favorite",
  "feature",
  "february",
  "federal",
  "fee",
  "feed",
  "feel",
  "female",
  "fence",
  "festival",
  "fetch",
  "fever",
  "few",
  "fiber",
  "fiction",
  "field",
  "figure",
  "file",
  "film",
  "filter",
  "final",
  "find",
  "fine",
  "finger",
  "finish",
  "fire",
  "firm",
  "first",
  "fiscal",
  "fish",
  "fit",
  "fitness",
  "fix",
  "flag",
  "flame",
  "flash",
  "flat",
  "flavor",
  "flee",
  "flight",
  "flip",
  "float",
  "flock",
  "floor",
  "flower",
  "fluid",
  "flush",
  "fly",
  "foam",
  "focus",
  "fog",
  "foil",
  "fold",
  "follow",
  "food",
  "foot",
  "force",
  "forest",
  "forget",
  "fork",
  "fortune",
  "forum",
  "forward",
  "fossil",
  "foster",
  "found",
  "fox",
  "fragile",
  "frame",
  "frequent",
  "fresh",
  "friend",
  "fringe",
  "frog",
  "front",
  "frost",
  "frown",
  "frozen",
  "fruit",
  "fuel",
  "fun",
  "funny",
  "furnace",
  "fury",
  "future",
  "gadget",
  "gain",
  "galaxy",
  "gallery",
  "game",
  "gap",
  "garage",
  "garbage",
  "garden",
  "garlic",
  "garment",
  "gas",
  "gasp",
  "gate",
  "gather",
  "gauge",
  "gaze",
  "general",
  "genius",
  "genre",
  "gentle",
  "genuine",
  "gesture",
  "ghost",
  "giant",
  "gift",
  "giggle",
  "ginger",
  "giraffe",
  "girl",
  "give",
  "glad",
  "glance",
  "glare",
  "glass",
  "glide",
  "glimpse",
  "globe",
  "gloom",
  "glory",
  "glove",
  "glow",
  "glue",
  "goat",
  "goddess",
  "gold",
  "good",
  "goose",
  "gorilla",
  "gospel",
  "gossip",
  "govern",
  "gown",
  "grab",
  "grace",
  "grain",
  "grant",
  "grape",
  "grass",
  "gravity",
  "great",
  "green",
  "grid",
  "grief",
  "grit",
  "grocery",
  "group",
  "grow",
  "grunt",
  "guard",
  "guess",
  "guide",
  "guilt",
  "guitar",
  "gun",
  "gym",
  "habit",
  "hair",
  "half",
  "hammer",
  "hamster",
  "hand",
  "happy",
  "harbor",
  "hard",
  "harsh",
  "harvest",
  "hat",
  "have",
  "hawk",
  "hazard",
  "head",
  "health",
  "heart",
  "heavy",
  "hedgehog",
  "height",
  "hello",
  "helmet",
  "help",
  "hen",
  "hero",
  "hidden",
  "high",
  "hill",
  "hint",
  "hip",
  "hire",
  "history",
  "hobby",
  "hockey",
  "hold",
  "hole",
  "holiday",
  "hollow",
  "home",
  "honey",
  "hood",
  "hope",
  "horn",
  "horror",
  "horse",
  "hospital",
  "host",
  "hotel",
  "hour",
  "hover",
  "hub",
  "huge",
  "human",
  "humble",
  "humor",
  "hundred",
  "hungry",
  "hunt",
  "hurdle",
  "hurry",
  "hurt",
  "husband",
  "hybrid",
  "ice",
  "icon",
  "idea",
  "identify",
  "idle",
  "ignore",
  "ill",
  "illegal",
  "illness",
  "image",
  "imitate",
  "immense",
  "immune",
  "impact",
  "impose",
  "improve",
  "impulse",
  "inch",
  "include",
  "income",
  "increase",
  "index",
  "indicate",
  "indoor",
  "industry",
  "infant",
  "inflict",
  "inform",
  "inhale",
  "inherit",
  "initial",
  "inject",
  "injury",
  "inmate",
  "inner",
  "innocent",
  "input",
  "inquiry",
  "insane",
  "insect",
  "inside",
  "inspire",
  "install",
  "intact",
  "interest",
  "into",
  "invest",
  "invite",
  "involve",
  "iron",
  "island",
  "isolate",
  "issue",
  "item",
  "ivory",
  "jacket",
  "jaguar",
  "jar",
  "jazz",
  "jealous",
  "jeans",
  "jelly",
  "jewel",
  "job",
  "join",
  "joke",
  "journey",
  "joy",
  "judge",
  "juice",
  "jump",
  "jungle",
  "junior",
  "junk",
  "just",
  "kangaroo",
  "keen",
  "keep",
  "ketchup",
  "key",
  "kick",
  "kid",
  "kidney",
  "kind",
  "kingdom",
  "kiss",
  "kit",
  "kitchen",
  "kite",
  "kitten",
  "kiwi",
  "knee",
  "knife",
  "knock",
  "know",
  "lab",
  "label",
  "labor",
  "ladder",
  "lady",
  "lake",
  "lamp",
  "language",
  "laptop",
  "large",
  "later",
  "latin",
  "laugh",
  "laundry",
  "lava",
  "law",
  "lawn",
  "lawsuit",
  "layer",
  "lazy",
  "leader",
  "leaf",
  "learn",
  "leave",
  "lecture",
  "left",
  "leg",
  "legal",
  "legend",
  "leisure",
  "lemon",
  "lend",
  "length",
  "lens",
  "leopard",
  "lesson",
  "letter",
  "level",
  "liar",
  "liberty",
  "library",
  "license",
  "life",
  "lift",
  "light",
  "like",
  "limb",
  "limit",
  "link",
  "lion",
  "liquid",
  "list",
  "little",
  "live",
  "lizard",
  "load",
  "loan",
  "lobster",
  "local",
  "lock",
  "logic",
  "lonely",
  "long",
  "loop",
  "lottery",
  "loud",
  "lounge",
  "love",
  "loyal",
  "lucky",
  "luggage",
  "lumber",
  "lunar",
  "lunch",
  "luxury",
  "lyrics",
  "machine",
  "mad",
  "magic",
  "magnet",
  "maid",
  "mail",
  "main",
  "major",
  "make",
  "mammal",
  "man",
  "manage",
  "mandate",
  "mango",
  "mansion",
  "manual",
  "maple",
  "marble",
  "march",
  "margin",
  "marine",
  "market",
  "marriage",
  "mask",
  "mass",
  "master",
  "match",
  "material",
  "math",
  "matrix",
  "matter",
  "maximum",
  "maze",
  "meadow",
  "mean",
  "measure",
  "meat",
  "mechanic",
  "medal",
  "media",
  "melody",
  "melt",
  "member",
  "memory",
  "mention",
  "menu",
  "mercy",
  "merge",
  "merit",
  "merry",
  "mesh",
  "message",
  "metal",
  "method",
  "middle",
  "midnight",
  "milk",
  "million",
  "mimic",
  "mind",
  "minimum",
  "minor",
  "minute",
  "miracle",
  "mirror",
  "misery",
  "miss",
  "mistake",
  "mix",
  "mixed",
  "mixture",
  "mobile",
  "model",
  "modify",
  "mom",
  "moment",
  "monitor",
  "monkey",
  "monster",
  "month",
  "moon",
  "moral",
  "more",
  "morning",
  "mosquito",
  "mother",
  "motion",
  "motor",
  "mountain",
  "mouse",
  "move",
  "movie",
  "much",
  "muffin",
  "mule",
  "multiply",
  "muscle",
  "museum",
  "mushroom",
  "music",
  "must",
  "mutual",
  "myself",
  "mystery",
  "myth",
  "naive",
  "name",
  "napkin",
  "narrow",
  "nasty",
  "nation",
  "nature",
  "near",
  "neck",
  "need",
  "negative",
  "neglect",
  "neither",
  "nephew",
  "nerve",
  "nest",
  "net",
  "network",
  "neutral",
  "never",
  "news",
  "next",
  "nice",
  "night",
  "noble",
  "noise",
  "nominee",
  "noodle",
  "normal",
  "north",
  "nose",
  "notable",
  "note",
  "nothing",
  "notice",
  "novel",
  "now",
  "nuclear",
  "number",
  "nurse",
  "nut",
  "oak",
  "obey",
  "object",
  "oblige",
  "obscure",
  "observe",
  "obtain",
  "obvious",
  "occur",
  "ocean",
  "october",
  "odor",
  "off",
  "offer",
  "office",
  "often",
  "oil",
  "okay",
  "old",
  "olive",
  "olympic",
  "omit",
  "once",
  "one",
  "onion",
  "online",
  "only",
  "open",
  "opera",
  "opinion",
  "oppose",
  "option",
  "orange",
  "orbit",
  "orchard",
  "order",
  "ordinary",
  "organ",
  "orient",
  "original",
  "orphan",
  "ostrich",
  "other",
  "outdoor",
  "outer",
  "output",
  "outside",
  "oval",
  "oven",
  "over",
  "own",
  "owner",
  "oxygen",
  "oyster",
  "ozone",
  "pact",
  "paddle",
  "page",
  "pair",
  "palace",
  "palm",
  "panda",
  "panel",
  "panic",
  "panther",
  "paper",
  "parade",
  "parent",
  "park",
  "parrot",
  "party",
  "pass",
  "patch",
  "path",
  "patient",
  "patrol",
  "pattern",
  "pause",
  "pave",
  "payment",
  "peace",
  "peanut",
  "pear",
  "peasant",
  "pelican",
  "pen",
  "penalty",
  "pencil",
  "people",
  "pepper",
  "perfect",
  "permit",
  "person",
  "pet",
  "phone",
  "photo",
  "phrase",
  "physical",
  "piano",
  "picnic",
  "picture",
  "piece",
  "pig",
  "pigeon",
  "pill",
  "pilot",
  "pink",
  "pioneer",
  "pipe",
  "pistol",
  "pitch",
  "pizza",
  "place",
  "planet",
  "plastic",
  "plate",
  "play",
  "please",
  "pledge",
  "pluck",
  "plug",
  "plunge",
  "poem",
  "poet",
  "point",
  "polar",
  "pole",
  "police",
  "pond",
  "pony",
  "pool",
  "popular",
  "portion",
  "position",
  "possible",
  "post",
  "potato",
  "pottery",
  "poverty",
  "powder",
  "power",
  "practice",
  "praise",
  "predict",
  "prefer",
  "prepare",
  "present",
  "pretty",
  "prevent",
  "price",
  "pride",
  "primary",
  "print",
  "priority",
  "prison",
  "private",
  "prize",
  "problem",
  "process",
  "produce",
  "profit",
  "program",
  "project",
  "promote",
  "proof",
  "property",
  "prosper",
  "protect",
  "proud",
  "provide",
  "public",
  "pudding",
  "pull",
  "pulp",
  "pulse",
  "pumpkin",
  "punch",
  "pupil",
  "puppy",
  "purchase",
  "purity",
  "purpose",
  "purse",
  "push",
  "put",
  "puzzle",
  "pyramid",
  "quality",
  "quantum",
  "quarter",
  "question",
  "quick",
  "quit",
  "quiz",
  "quote",
  "rabbit",
  "raccoon",
  "race",
  "rack",
  "radar",
  "radio",
  "rail",
  "rain",
  "raise",
  "rally",
  "ramp",
  "ranch",
  "random",
  "range",
  "rapid",
  "rare",
  "rate",
  "rather",
  "raven",
  "raw",
  "razor",
  "ready",
  "real",
  "reason",
  "rebel",
  "rebuild",
  "recall",
  "receive",
  "recipe",
  "record",
  "recycle",
  "reduce",
  "reflect",
  "reform",
  "refuse",
  "region",
  "regret",
  "regular",
  "reject",
  "relax",
  "release",
  "relief",
  "rely",
  "remain",
  "remember",
  "remind",
  "remove",
  "render",
  "renew",
  "rent",
  "reopen",
  "repair",
  "repeat",
  "replace",
  "report",
  "require",
  "rescue",
  "resemble",
  "resist",
  "resource",
  "response",
  "result",
  "retire",
  "retreat",
  "return",
  "reunion",
  "reveal",
  "review",
  "reward",
  "rhythm",
  "rib",
  "ribbon",
  "rice",
  "rich",
  "ride",
  "ridge",
  "rifle",
  "right",
  "rigid",
  "ring",
  "riot",
  "ripple",
  "risk",
  "ritual",
  "rival",
  "river",
  "road",
  "roast",
  "robot",
  "robust",
  "rocket",
  "romance",
  "roof",
  "rookie",
  "room",
  "rose",
  "rotate",
  "rough",
  "round",
  "route",
  "royal",
  "rubber",
  "rude",
  "rug",
  "rule",
  "run",
  "runway",
  "rural",
  "sad",
  "saddle",
  "sadness",
  "safe",
  "sail",
  "salad",
  "salmon",
  "salon",
  "salt",
  "salute",
  "same",
  "sample",
  "sand",
  "satisfy",
  "satoshi",
  "sauce",
  "sausage",
  "save",
  "say",
  "scale",
  "scan",
  "scare",
  "scatter",
  "scene",
  "scheme",
  "school",
  "science",
  "scissors",
  "scorpion",
  "scout",
  "scrap",
  "screen",
  "script",
  "scrub",
  "sea",
  "search",
  "season",
  "seat",
  "second",
  "secret",
  "section",
  "security",
  "seed",
  "seek",
  "segment",
  "select",
  "sell",
  "seminar",
  "senior",
  "sense",
  "sentence",
  "series",
  "service",
  "session",
  "settle",
  "setup",
  "seven",
  "shadow",
  "shaft",
  "shallow",
  "share",
  "shed",
  "shell",
  "sheriff",
  "shield",
  "shift",
  "shine",
  "ship",
  "shiver",
  "shock",
  "shoe",
  "shoot",
  "shop",
  "short",
  "shoulder",
  "shove",
  "shrimp",
  "shrug",
  "shuffle",
  "shy",
  "sibling",
  "sick",
  "side",
  "siege",
  "sight",
  "sign",
  "silent",
  "silk",
  "silly",
  "silver",
  "similar",
  "simple",
  "since",
  "sing",
  "siren",
  "sister",
  "situate",
  "six",
  "size",
  "skate",
  "sketch",
  "ski",
  "skill",
  "skin",
  "skirt",
  "skull",
  "slab",
  "slam",
  "sleep",
  "slender",
  "slice",
  "slide",
  "slight",
  "slim",
  "slogan",
  "slot",
  "slow",
  "slush",
  "small",
  "smart",
  "smile",
  "smoke",
  "smooth",
  "snack",
  "snake",
  "snap",
  "sniff",
  "snow",
  "soap",
  "soccer",
  "social",
  "sock",
  "soda",
  "soft",
  "solar",
  "soldier",
  "solid",
  "solution",
  "solve",
  "someone",
  "song",
  "soon",
  "sorry",
  "sort",
  "soul",
  "sound",
  "soup",
  "source",
  "south",
  "space",
  "spare",
  "spatial",
  "spawn",
  "speak",
  "special",
  "speed",
  "spell",
  "spend",
  "sphere",
  "spice",
  "spider",
  "spike",
  "spin",
  "spirit",
  "split",
  "spoil",
  "sponsor",
  "spoon",
  "sport",
  "spot",
  "spray",
  "spread",
  "spring",
  "spy",
  "square",
  "squeeze",
  "squirrel",
  "stable",
  "stadium",
  "staff",
  "stage",
  "stairs",
  "stamp",
  "stand",
  "start",
  "state",
  "stay",
  "steak",
  "steel",
  "stem",
  "step",
  "stereo",
  "stick",
  "still",
  "sting",
  "stock",
  "stomach",
  "stone",
  "stool",
  "story",
  "stove",
  "strategy",
  "street",
  "strike",
  "strong",
  "struggle",
  "student",
  "stuff",
  "stumble",
  "style",
  "subject",
  "submit",
  "subway",
  "success",
  "such",
  "sudden",
  "suffer",
  "sugar",
  "suggest",
  "suit",
  "summer",
  "sun",
  "sunny",
  "sunset",
  "super",
  "supply",
  "supreme",
  "sure",
  "surface",
  "surge",
  "surprise",
  "surround",
  "survey",
  "suspect",
  "sustain",
  "swallow",
  "swamp",
  "swap",
  "swarm",
  "swear",
  "sweet",
  "swift",
  "swim",
  "swing",
  "switch",
  "sword",
  "symbol",
  "symptom",
  "syrup",
  "system",
  "table",
  "tackle",
  "tag",
  "tail",
  "talent",
  "talk",
  "tank",
  "tape",
  "target",
  "task",
  "taste",
  "tattoo",
  "taxi",
  "teach",
  "team",
  "tell",
  "ten",
  "tenant",
  "tennis",
  "tent",
  "term",
  "test",
  "text",
  "thank",
  "that",
  "theme",
  "then",
  "theory",
  "there",
  "they",
  "thing",
  "this",
  "thought",
  "three",
  "thrive",
  "throw",
  "thumb",
  "thunder",
  "ticket",
  "tide",
  "tiger",
  "tilt",
  "timber",
  "time",
  "tiny",
  "tip",
  "tired",
  "tissue",
  "title",
  "toast",
  "tobacco",
  "today",
  "toddler",
  "toe",
  "together",
  "toilet",
  "token",
  "tomato",
  "tomorrow",
  "tone",
  "tongue",
  "tonight",
  "tool",
  "tooth",
  "top",
  "topic",
  "topple",
  "torch",
  "tornado",
  "tortoise",
  "toss",
  "total",
  "tourist",
  "toward",
  "tower",
  "town",
  "toy",
  "track",
  "trade",
  "traffic",
  "tragic",
  "train",
  "transfer",
  "trap",
  "trash",
  "travel",
  "tray",
  "treat",
  "tree",
  "trend",
  "trial",
  "tribe",
  "trick",
  "trigger",
  "trim",
  "trip",
  "trophy",
  "trouble",
  "truck",
  "true",
  "truly",
  "trumpet",
  "trust",
  "truth",
  "try",
  "tube",
  "tuition",
  "tumble",
  "tuna",
  "tunnel",
  "turkey",
  "turn",
  "turtle",
  "twelve",
  "twenty",
  "twice",
  "twin",
  "twist",
  "two",
  "type",
  "typical",
  "ugly",
  "umbrella",
  "unable",
  "unaware",
  "uncle",
  "uncover",
  "under",
  "undo",
  "unfair",
  "unfold",
  "unhappy",
  "uniform",
  "unique",
  "unit",
  "universe",
  "unknown",
  "unlock",
  "until",
  "unusual",
  "unveil",
  "update",
  "upgrade",
  "uphold",
  "upon",
  "upper",
  "upset",
  "urban",
  "urge",
  "usage",
  "use",
  "used",
  "useful",
  "useless",
  "usual",
  "utility",
  "vacant",
  "vacuum",
  "vague",
  "valid",
  "valley",
  "valve",
  "van",
  "vanish",
  "vapor",
  "various",
  "vast",
  "vault",
  "vehicle",
  "velvet",
  "vendor",
  "venture",
  "venue",
  "verb",
  "verify",
  "version",
  "very",
  "vessel",
  "veteran",
  "viable",
  "vibrant",
  "vicious",
  "victory",
  "video",
  "view",
  "village",
  "vintage",
  "violin",
  "virtual",
  "virus",
  "visa",
  "visit",
  "visual",
  "vital",
  "vivid",
  "vocal",
  "voice",
  "void",
  "volcano",
  "volume",
  "vote",
  "voyage",
  "wage",
  "wagon",
  "wait",
  "walk",
  "wall",
  "walnut",
  "want",
  "warfare",
  "warm",
  "warrior",
  "wash",
  "wasp",
  "waste",
  "water",
  "wave",
  "way",
  "wealth",
  "weapon",
  "wear",
  "weasel",
  "weather",
  "web",
  "wedding",
  "weekend",
  "weird",
  "welcome",
  "west",
  "wet",
  "whale",
  "what",
  "wheat",
  "wheel",
  "when",
  "where",
  "whip",
  "whisper",
  "wide",
  "width",
  "wife",
  "wild",
  "will",
  "win",
  "window",
  "wine",
  "wing",
  "wink",
  "winner",
  "winter",
  "wire",
  "wisdom",
  "wise",
  "wish",
  "witness",
  "wolf",
  "woman",
  "wonder",
  "wood",
  "wool",
  "word",
  "work",
  "world",
  "worry",
  "worth",
  "wrap",
  "wreck",
  "wrestle",
  "wrist",
  "write",
  "wrong",
  "yard",
  "year",
  "yellow",
  "you",
  "young",
  "youth",
  "zebra",
  "zero",
  "zone",
  "zoo"
];

================
File: src/lib/dids/DIDDocument.ts
================
import { type IJWK, type JsonWebKey2020, JsonWebKeyPair, X25519KeyAgreementKey2019,
  X25519KeyAgreementKey2020, Ed25519VerificationKey2018, Ed25519VerificationKey2020, 
  type IDIDDocumentVerificationMethod,
  type IDIDDocumentServiceDescriptor,
  type IDIDDocument} from "../crypto";

export class DIDDocumentVerificationMethod
  implements IDIDDocumentVerificationMethod
{
  id: string;
  type: "JsonWebKey2020" | "X25519KeyAgreementKey2019" | "X25519KeyAgreementKey2020" | "Ed25519VerificationKey2018" | "Ed25519VerificationKey2020";
  controller: string;
  publicKeyPem?: string;
  publicKeyJwk?: IJWK;
  publicKeyHex?: string;
  publicKeyBase64?: string;
  publicKeyBase58?: string;
  publicKeyMultibase?: string;

  constructor(document: any) {
    this.id = document.id;
    this.type = document.type;
    this.controller = document.controller;
    Object.assign(this, document);
  }

  async asJsonWebKey(): Promise<JsonWebKey2020> {
    switch (this.type) {
      case "JsonWebKey2020":
        return new JsonWebKeyPair(
          this.id,
          this.controller,
          this.publicKeyJwk
        );
      case "X25519KeyAgreementKey2019":
        if (!this.publicKeyBase58) {
          throw new Error('publicKeyBase58 not found')
        }
        return await new X25519KeyAgreementKey2019(
          this.id,
          this.controller,
          this.publicKeyBase58
        ).export({ privateKey: false, type: "JsonWebKey2020" });
      case "X25519KeyAgreementKey2020":
        if (!this.publicKeyMultibase) {
          throw new Error('publicKeyMultibase not found')
        }
        return await new X25519KeyAgreementKey2020(
          this.id,
          this.controller,
          this.publicKeyMultibase
        ).export({ privateKey: false, type: "JsonWebKey2020" });
      case "Ed25519VerificationKey2018":
        if (!this.publicKeyBase58) {
          throw new Error('publicKeyBase58 not found')
        }
        return await new Ed25519VerificationKey2018(
          this.id,
          this.controller,
          this.publicKeyBase58
        ).export({ privateKey: false, type: "JsonWebKey2020" });
      case "Ed25519VerificationKey2020":
        if (!this.publicKeyMultibase) {
          throw new Error('publicKeyMultibase not found')
        }
        return await new Ed25519VerificationKey2020(
          this.id,
          this.controller,
          this.publicKeyMultibase
        ).export({ privateKey: false, type: "JsonWebKey2020" });
      default:
        throw new Error(`verificationMethod type ${this.type} can't be exported as JsonWebKey2020`)
    }
  }

  toJSON(): object {
    switch (this.type) {
      case "JsonWebKey2020":
        return {
          id: this.id,
          type: this.type,
          controller: this.controller,
          publicKeyJwk: this.publicKeyJwk,
        };
      case "X25519KeyAgreementKey2019":
        return {
          id: this.id,
          type: this.type,
          controller: this.controller,
          publicKeyBase58: this.publicKeyBase58,
        };
      case "X25519KeyAgreementKey2020":
        return {
          id: this.id,
          type: this.type,
          controller: this.controller,
          publicKeyMultibase: this.publicKeyMultibase,
        };
      default:
        return this
    }
  }
}

export class DIDDocument implements IDIDDocument {
  document: object;
  "@context": string[];
  public get context() {
    return this['@context'];
  }
  id: string;
  controller?: string;
  alsoKnownAs?: string;
  verificationMethod: IDIDDocumentVerificationMethod[] = [];
  service: IDIDDocumentServiceDescriptor[] = [];
  authentication: IDIDDocumentVerificationMethod[] = [];
  assertionMethod: IDIDDocumentVerificationMethod[] = []
  keyAgreement: IDIDDocumentVerificationMethod[] = []
  capabilityInvocation: IDIDDocumentVerificationMethod[] = []
  capabilityDelegation: IDIDDocumentVerificationMethod[] = []

  constructor(document: any) {
    if (typeof document["@context"] === "undefined") {
      throw new Error("@context is required");
    }
    if (typeof document["id"] === "undefined") {
      throw new Error("id is required");
    }

    this.document = document;

    this["@context"] = document["@context"];
    this.id = document["id"];
    this.controller = document["controller"] ?? null;
    this.alsoKnownAs = document["alsoKnownAs"] ?? null;

    if (
      document["verificationMethod"] &&
      document["verificationMethod"].length > 0
    ) {
      this.verificationMethod = document["verificationMethod"].map(
        (v: IDIDDocumentVerificationMethod) =>
          new DIDDocumentVerificationMethod(v)
      );
    }

    if (document["authentication"] && document["authentication"].length > 0) {
      this.authentication = this.normalizeVerificationMethod(
        document["authentication"]
      );
    }

    if (document["keyAgreement"] && document["keyAgreement"].length > 0) {
      this.keyAgreement = this.normalizeVerificationMethod(
        document["keyAgreement"]
      );
    }

    if (document["assertionMethod"] && document["assertionMethod"].length > 0) {
      this.assertionMethod = this.normalizeVerificationMethod(
        document["assertionMethod"]
      );
    }

    if (
      document["capabilityInvocation"] &&
      document["capabilityInvocation"].length > 0
    ) {
      this.capabilityInvocation = this.normalizeVerificationMethod(
        document["capabilityInvocation"]
      );
    }

    if (
      document["capabilityDelegation"] &&
      document["capabilityDelegation"].length > 0
    ) {
      this.capabilityDelegation = this.normalizeVerificationMethod(
        document["capabilityDelegation"]
      );
    }

    if (document["service"] && document["service"].length > 0) {
      this.service = document["service"].map(
        (s: IDIDDocumentServiceDescriptor) => s
      );
    }
  }

  normalizeVerificationMethod(
    methods: (string | IDIDDocumentVerificationMethod)[]
  ): IDIDDocumentVerificationMethod[] {
    return methods.map((m: string | IDIDDocumentVerificationMethod) => {
      if (typeof m === "string") {
        const v = this.getVerificationMethodById(m);
        if (!v) {
          throw new Error(`Verification method: ${m} not found`);
        }
        return v;
      } else {
        return m as IDIDDocumentVerificationMethod;
      }
    });
  }

  getVerificationMethodById(id: string) {
    return this.verificationMethod?.find((v) => v.id === id);
  }

  getServiceById(id: string) {
    return this.service?.find((s) => s.id === id);
  }

  getServiceByType(type: string) {
    return this.service?.find((s) => s.type === type);
  }

  getKeyAgreementById(id: string) {
    return this.keyAgreement?.find((k) => k.id === id);
  }

  getAllKeyAgreements(): IDIDDocumentVerificationMethod[] {
    return this.keyAgreement ?? [];
  }

  getAuthenticationById(id: string) {
    return this.authentication?.find((k) => k.id === id);
  }

  getCapabilityInvocationById(id: string) {
    return this.capabilityInvocation?.find((k) => k.id === id);
  }

  getCapabilityDelegationById(id: string) {
    return this.capabilityDelegation?.find((k) => k.id === id);
  }

  getAssertionMethodById(id: string) {
    return this.assertionMethod?.find((k) => k.id === id);
  }

  toJSON(): object {
    let doc: any = { "@context": this["@context"], id: this.id };
    if (this.controller) {
      doc.controller = this.controller;
    }
    if (this.alsoKnownAs) {
      doc.alsoKnownAs = this.alsoKnownAs;
    }
    if (this.verificationMethod && this.verificationMethod.length > 0) {
      doc.verificationMethod = this.verificationMethod.map((x) => x.toJSON());
    }
    if (this.service && this.service.length > 0) {
      doc.service = this.service;
    }
    if (this.authentication && this.authentication.length > 0) {
      doc.authentication =
        typeof this.authentication[0] === "string"
          ? this.authentication
          : this.authentication.map((x) => x.id);
    }
    if (this.assertionMethod && this.assertionMethod.length > 0) {
      doc.assertionMethod =
        typeof this.assertionMethod[0] === "string"
          ? this.assertionMethod
          : this.assertionMethod.map((x) => x.id);
    }
    if (this.keyAgreement && this.keyAgreement.length > 0) {
      doc.keyAgreement =
        typeof this.keyAgreement[0] === "string"
          ? this.keyAgreement
          : this.keyAgreement.map((x) => x.id);
    }
    if (this.capabilityInvocation && this.capabilityInvocation.length > 0) {
      doc.capabilityInvocation =
        typeof this.capabilityInvocation[0] === "string"
          ? this.capabilityInvocation
          : this.capabilityInvocation.map((x) => x.id);
    }
    if (this.capabilityDelegation && this.capabilityDelegation.length > 0) {
      doc.capabilityDelegation =
        typeof this.capabilityDelegation[0] === "string"
          ? this.capabilityDelegation
          : this.capabilityDelegation.map((x) => x.id);
    }
    return doc;
  }
}

================
File: src/lib/dids/DIDResolver.ts
================
import { resolve as didPeer } from "@aviarytech/did-peer"

import { DIDDocument } from "./DIDDocument.js";
import type { IDIDDocument } from "../common/interfaces.js";

export class DIDNotFoundError extends Error {
  constructor(did: string) {
    super(did);
    this.message = `DID ${did} not found`
  }
}

export class DIDMethodNotSupported extends Error {
  constructor(method: string) {
    super(method)
    this.message = `DID method ${method} not supported by resolver`
  }
}

export class DIDResolver {
  async resolve(did: string): Promise<IDIDDocument> {
    try {
      let document: any;
      if (did.split(":").length < 3) {
        throw new Error(`${did} not a valid DID`)
      }
      if (did.startsWith('did:web:')) {
        const [_, method, id, ...extras] = did.split(":");
        let domain = id.split("#").length > 1 ? id.split("#")[0] : id;
        let path = extras.join('/')
        const [host, port] = domain.split('%3A');
        const resp = await fetch(
          `http${host.indexOf("localhost") >= 0 ? '' : "s"
          }://${host}${!port ? '' : `:${port}`}/${path === '' ? '.well-known' : path}/did.json`
        );
        document = await resp.json();
      }
      if (did.startsWith('did:peer:')) {
        try {
          document = await didPeer(did)
        } catch (e: any) {
          console.error(`could not resolve did:peer`, e.message)
        }
      }
      if (did.startsWith('did:key:')) {
        try {
          const [x, y, id] = did.split(':');
          const [pub, fingerprint] = id.split('#');
          const vm = `did:key:${pub}#${pub}`;
          document = {
            "@context": [
              "https://www.w3.org/ns/did/v1",
              "https://w3id.org/security/suites/ed25519-2020/v1"],
            "id": `did:key:${pub}`,
            "verificationMethod": [
              {
                "id": vm,
                "type": 'Ed25519VerificationKey2020',
                "controller": `did:key:${pub}`,
                "publicKeyMultibase": pub
              }
            ],
            "assertionMethod": [vm],
            "authentication": [vm]
          }
        } catch (e: any) {
          console.error(`could not resolve did:key`, e.message);
        }
      }
      if (!document) throw new DIDNotFoundError(did);
      if (typeof document === 'object') {
        return new DIDDocument(document)
      }
      return new DIDDocument(JSON.parse(document));
    } catch (e: any) {
      const [_, method] = did.split(":")
      if (e.message.indexOf("Unsupported iri") >= 0) throw new DIDMethodNotSupported(`did:${method}`)
      if (e.message.indexOf("status code 404") >= 0) throw new DIDNotFoundError(did)
      throw e;
    }
  }
}

================
File: src/lib/dids/index.ts
================
export * from "./DIDDocument"
export * from "./DIDResolver"
export * from "./Secret"
export * from "./SecretResolver"

================
File: src/lib/dids/Secret.ts
================
import  { type JsonWebKey2020, JsonWebKeyPair, X25519KeyAgreementKey2019, X25519KeyAgreementKey2020,
  Ed25519VerificationKey2018, Ed25519VerificationKey2020, 
  type ISecret} from "../crypto";

export class SecretTypeAsJWKNotSupportedError extends Error {
  constructor(type: string) {
    super(type);
    this.message = `Secret ${type} as JWK not supported`;
  }
}

export class SecretTypeNotFound extends Error {
  constructor(type: string) {
    super(type);
    this.message = `Secret type "${type}" not supported`;
  }
}

export class Secret implements ISecret {
  id: string;
  type: string;
  privateKeyPem?: string;
  publicKeyPem?: string;
  privateKeyJwk?: any;
  publicKeyJwk?: any;
  privateKeyHex?: string;
  publicKeyHex?: string;
  privateKeyBase64?: string;
  publicKeyBase64?: string;
  privateKeyBase58?: string;
  publicKeyBase58?: string;
  privateKeyMultibase?: string;
  publicKeyMultibase?: string;

  private key: JsonWebKeyPair | X25519KeyAgreementKey2019 | X25519KeyAgreementKey2020 | Ed25519VerificationKey2018 | Ed25519VerificationKey2020;

  constructor(document: any) {
    this.id = document.id;
    this.type = document.type;

    switch (this.type) {
      case "JsonWebKey2020":
        this.publicKeyJwk = document.publicKeyJwk;
        this.privateKeyJwk = document.privateKeyJwk;
        this.key = new JsonWebKeyPair(
          this.id,
          this.id,
          this.publicKeyJwk,
          this.privateKeyJwk
        );
        return this;
      case "X25519KeyAgreementKey2019":
        this.publicKeyBase58 = document.publicKeyBase58;
        this.privateKeyBase58 = document.privateKeyBase58;
        this.key = new X25519KeyAgreementKey2019(
          this.id,
          this.id,
          this.publicKeyBase58 as string,
          this.privateKeyBase58
        );
        return this;
      case "X25519KeyAgreementKey2020":
        this.publicKeyMultibase = document.publicKeyMultibase;
        this.privateKeyMultibase = document.privateKeyMultibase;
        this.key = new X25519KeyAgreementKey2020(
          this.id,
          this.id,
          this.publicKeyMultibase as string,
          this.privateKeyMultibase
        );
        return this;
      case "Ed25519VerificationKey2018":
        this.publicKeyBase58 = document.publicKeyBase58;
        this.privateKeyBase58 = document.privateKeyBase58;
        this.key = new Ed25519VerificationKey2018(
          this.id,
          this.id,
          this.publicKeyBase58 as string,
          this.privateKeyBase58
        );
        return this;
      case "Ed25519VerificationKey2020":
        this.publicKeyMultibase = document.publicKeyMultibase;
        this.privateKeyMultibase = document.privateKeyMultibase;
        this.key = new Ed25519VerificationKey2020(
          this.id,
          this.id,
          this.publicKeyMultibase as string,
          this.privateKeyMultibase
        );
        return this;
    }
    throw new SecretTypeNotFound(this.type);
  }

  async asJsonWebKey(): Promise<JsonWebKey2020> {
    switch (this.key.type) {
      case "JsonWebKey2020":
        return this.key.export({privateKey: true, type: "JsonWebKey2020"});
      case "X25519KeyAgreementKey2019":
      case "X25519KeyAgreementKey2020":
      case "Ed25519VerificationKey2018":
      case "Ed25519VerificationKey2020":
        return await this.key.export({
          privateKey: true,
          type: "JsonWebKey2020",
        });
    }
    throw new Error(`Verification Method ${this.key.type} not supported`)
  }
}

================
File: src/lib/dids/SecretResolver.ts
================
import { Secret } from "./Secret.js";
import { base64url, utf8, type Readable } from "../crypto";

export class JSONSecretResolver {
  private secrets: Secret[];

  constructor(json: object) {
    this.secrets = Array.isArray(json) ? json.map(j => new Secret(j)) : [new Secret(json)];
  }

  async resolve(id: string): Promise<Secret> {
    const secret = this.secrets.find(s => s.id === id)
    if (!secret) throw new Error(`Secret ${id} not found in provided secrets json`)
    return new Secret(secret);
  }
}

export class EnvironmentVariableSecretResolver {
  private secrets: Secret[];

  constructor(env: any) {
    if (!env.SECRETS) throw new Error('No (base64 encoded) SECRETS found in environment')
    this.secrets = JSON.parse(utf8.decode(base64url.decode(env.SECRETS)))
  }

  async resolve(id: string): Promise<Secret> {
    const secret = this.secrets.find(s => s.id === id)
    if (!secret) throw new Error(`Secret ${id} not found in SECRETS from environment`)
    return new Secret(secret);
  }
}

export class WalletSecretResolver {
  private secrets: Secret[] = [];

  constructor(store: Readable<any>) {
    var self = this;
    store.subscribe(r => {
      self.secrets = r
    })
  }

  async resolve(id: string): Promise<Secret> {
    try {
      const secret = this.secrets.find((s: any) => s.id === id)
      if (!secret) throw new Error(`Secret ${id} not found in store secrets`)
      return new Secret(secret);
    } catch (e: any) {
      console.error(e)
      throw new Error(e.message)
    }
  }
}

================
File: src/lib/vcs/canon.ts
================
import { sha256buffer } from "../crypto";
import jsonld from "jsonld";
import { Buffer } from 'buffer/index.js';


export async function canonize(input: any, { documentLoader }: any) {
  return await jsonld.canonize(input, {
    algorithm: 'URDNA2015',
    format: 'application/n-quads',
    documentLoader,
    useNative: false
  });
}

export async function canonizeProof(proof: any, { documentLoader }: any) {
  // `jws`,`signatureValue`,`proofValue` must not be included in the proof
  const { jws, signatureValue, proofValue, ...rest } = proof;
  return await canonize(rest, {
    documentLoader
  });
}

export async function createVerifyData({ document, proof, documentLoader }: any) {
  // concatenate hash of c14n proof options and hash of c14n document
  if (!proof['@context']) {
    proof['@context'] = document['@context']
  }
  const c14nProofOptions = await canonizeProof(proof, {
    documentLoader
  });
  const c14nDocument = await canonize(document, {
    documentLoader    
  });
  return Buffer.concat([sha256buffer(c14nProofOptions), sha256buffer(c14nDocument)]);
}

================
File: src/lib/vcs/index.ts
================
export { IssuanceService } from './issue';
export { VerificationService } from './verify';
export { PresentationService } from './present';

================
File: src/lib/vcs/issue.ts
================
import type { DocumentLoader, Credential, VerifiableCredential } from '../common/interfaces.js';
import { NotImplementedError } from '../common/errors.js';
import { ValidateCredential } from './validation.js';

export class IssuanceService {
	@ValidateCredential(0)
	static async issueCredential(
		credential: Credential,
		options: {
			type: 'vc-jwt' | 'vc-ld';
			suite: any;
			documentLoader: DocumentLoader;
		}
	): Promise<VerifiableCredential> {
		const { type, suite, documentLoader } = options;

		if (!documentLoader) {
			throw new TypeError('"documentLoader" parameter is required.');
		}

		if (!suite) {
			throw new TypeError('"suite" parameter is required.');
		}

		if (type === 'vc-jwt') {
			/* sign jwt vc */
			// TODO JWT
			// return suite.sign(LDCredentialToJWT(credential), { documentLoader });
		} else if (type === 'vc-ld') {
			/* sign linked data vc */
			const proof = await suite.createProof(credential, 'assertionMethod', documentLoader);
			return { ...credential, proof: [proof] };
		}
		throw new TypeError('"type" parameter is required and must be "vc-jwt" or "vc-ld".');
	}

	updateCredentialStatus() {
		throw new NotImplementedError('updateCredentialStatus not implemented yet');
	}
}

================
File: src/lib/vcs/jwt.ts
================
import type { JWTCredential, Credential } from '../common/interfaces';

export const LDCredentialToJWT = (credential: Credential): JWTCredential => {
	let newCred = {} as JWTCredential;

	/* copy credential subject id */
	if (credential.credentialSubject.id) {
		newCred.sub = credential.credentialSubject.id;
	}

	/* copy credential id */
	if (credential.id) {
		newCred.jti = credential.id;
	}

	/* copy issuer */
	if (typeof credential.issuer === 'string') {
		newCred.iss = credential.issuer;
	} else {
		newCred.iss = credential.issuer?.id ?? '';
	}

	/* copy issuance date */
	const issuanceDate = Math.floor(+new Date(credential.issuanceDate ?? new Date()) / 1000);
	newCred.nbf = issuanceDate;
	newCred.iat = issuanceDate;

	/* copy expiration date */
	if (credential.expirationDate) {
		newCred.exp = Math.floor(+new Date(credential.expirationDate) / 1000);
	}

	/* nonce */
	newCred.nonce = crypto.getRandomValues(new Uint8Array(12)).toString();
	/* copy the remaining claims into vc */
	newCred.vc = credential;

	return newCred;
};

================
File: src/lib/vcs/present.ts
================
import type {
	Credential,
	LinkedDataSuite,
	Presentation,
	VerifiableCredential,
	VerifiablePresentation
} from '../common/interfaces';
import { ValidateCredential, ValidatePresentation } from './validation.js';
import type { DocumentLoader } from '../common/interfaces';

export class PresentationService {
	@ValidateCredential(0)
	static async deriveCredential(
		credential: Credential | VerifiableCredential,
		options: {
			type: 'vc-jwt' | 'vc-ld';
			suite: any;
			documentLoader: DocumentLoader;
		},
		proofOptions?: any
	): Promise<VerifiableCredential> {
		const { type, suite, documentLoader } = options;

		if (!documentLoader) {
			throw new TypeError('"documentLoader" parameter is required.');
		}

		if (!suite) {
			throw new TypeError('"suite" parameter is required.');
		}

		if (type === 'vc-jwt') {
			/* sign jwt vc */
			// TODO JWT
			// return suite.sign(LDCredentialToJWT(credential), { documentLoader });
		} else if (type === 'vc-ld') {
			let newProof;
			if (typeof credential['proof'] === 'undefined') {
				newProof = await suite.createProof(
					credential,
					'assertionMethod',
					documentLoader,
					proofOptions
				);
			} else {
				let oldProof = (credential as VerifiableCredential).proof;
				if (!Array.isArray(oldProof)) {
					oldProof = [oldProof];
				}
				newProof = [
					await suite.createProof(credential, 'assertionMethod', documentLoader, proofOptions),
					...oldProof
				];
			}
			return { ...credential, proof: newProof };
		}
		throw new TypeError('"type" parameter is required and must be "vc-jwt" or "vc-ld".');
	}

	@ValidatePresentation(0)
	static async provePresentation(
		presentation: Presentation,
		options: {
			type: 'vc-jwt' | 'vc-ld';
			suite: LinkedDataSuite;
			documentLoader: DocumentLoader;
			domain?: string;
			challenge: string;
			[key: string]: any;
		}
	): Promise<VerifiablePresentation> {
		try {
			const { type, suite, documentLoader, ...opts } = options;

			if (type === 'vc-jwt') {
				/* sign jwt vc */
				// TODO JWT
				// return suite.sign(LDCredentialToJWT(credential), { documentLoader });
			} else if (type === 'vc-ld') {
				/* sign linked data vp */
				const proof = await suite.createProof(presentation, 'authentication', documentLoader, {
					domain: opts.domain,
					challenge: opts.challenge
				});
				return { ...presentation, proof };
			}
			throw new TypeError('"type" parameter is required and must be "vc-jwt" or "vc-ld".');
		} catch (e: any) {
			console.error(e.details ?? e.message ?? e);
			throw new Error('Failed to prove presentation');
		}
	}
}

================
File: src/lib/vcs/validation.ts
================
import { ValidationError } from '../common/errors';
import type { Credential, Presentation } from '../common/interfaces';

export const checkCredential = (credential: Credential) => {
	if (!credential['@context']) {
		throw new ValidationError('Verifiable Credentials MUST include a @context property.');
	}

	// TODO check jsonld is valid

	if (!credential.type) {
		throw new ValidationError('"type" property is required.');
	} else {
		let type = typeof credential.type === 'string' ? [credential.type] : credential.type;
		if (!type.includes('VerifiableCredential')) {
			throw new ValidationError('"type" property must contain "VerifiableCredential".');
		}
	}

	if (!credential.issuanceDate) { 
		throw new ValidationError('"issuanceDate" is required');
	}
	if (new Date(credential.issuanceDate).toISOString().slice(0, -5) + 'Z' !== credential.issuanceDate) {
		console.warn('"issuanceDate" is not an ISO date');
	}

	if (credential.expirationDate) {
		let expirationDate = new Date(credential.expirationDate).toISOString();
		if (expirationDate.slice(0, -5) + 'Z' !== credential.expirationDate) {
			console.warn('"expirationDate" is not an ISO date');
		}
	}

	let issuer = typeof credential.issuer === 'string' ? credential.issuer : credential.issuer?.id;
	if (!issuer) {
		throw new ValidationError('"issuer" is required');
	}

	if (credential.credentialStatus) {
		if (!credential.credentialStatus.id) {
			throw new Error('"credentialStatus" must include an id.');
		}
		if (!credential.credentialStatus.type) {
			throw new Error('"credentialStatus" must include a type.');
		}
	}
};

// index is the parameter index in the function that is being decorated
// TODO is there a better way to do this? possibly adding another decorator
// to the parameter and saving it for use here
export const ValidateCredential =
	(index: number) =>
	(target: Object, propertyKey: string, propertyDescriptor: PropertyDescriptor) => {
		let originalFunction: Function = propertyDescriptor.value;
		propertyDescriptor.value = function () {
			let credential: Credential = arguments[index];
			try {
				checkCredential(credential);
			} catch (e) {
				console.error(e);
				throw e;
			}
			console.log("TESRFDASF")

			return originalFunction.apply(this, arguments);
		};
		return propertyDescriptor;
	};

export const checkPresentation = (presentation: Presentation) => {
	if (!presentation['@context']) {
		throw new ValidationError('Verifiable Presentations MUST include a @context property.');
	}

	// TODO check jsonld is valid

	if (!presentation.type) {
		throw new ValidationError('"type" property is required.');
	} else {
		let type = typeof presentation.type === 'string' ? [presentation.type] : presentation.type;
		if (!type.includes('VerifiablePresentation')) {
			throw new ValidationError('"type" property must contain "VerifiablePresentation".');
		}
	}
};

export const ValidatePresentation =
	(index: number) =>
	(target: Object, propertyKey: string, propertyDescriptor: PropertyDescriptor) => {
		let originalFunction: Function = propertyDescriptor.value;
		propertyDescriptor.value = function () {
			let presentation: Presentation = arguments[index];

			try {
				checkPresentation(presentation);
			} catch (e) {
				console.error(e);
				throw e;
			}

			const vcs = Array.isArray(presentation.verifiableCredential)
				? presentation.verifiableCredential
				: [presentation.verifiableCredential];
			vcs.forEach((vc) => {
				try {
					checkCredential(vc);
				} catch (e) {
					console.error(e);
					throw e;
				}
			});

			return originalFunction.apply(this, arguments);
		};
		return propertyDescriptor;
	};

================
File: src/lib/vcs/verify.ts
================
import type {
	VerifiableCredential,
	VerifiablePresentation,
	VerificationResult,
  DocumentLoader
} from '../common/interfaces';

/* Verifier Service */
export class VerificationService {
	static async verifyCredential(
		verifiableCredential: VerifiableCredential,
		suite: any,
		documentLoader: DocumentLoader
	): Promise<VerificationResult> {
		let errors = [];
		let checks = [];
		let { proof, ...credential } = verifiableCredential;

		if (!Array.isArray(proof)) {
			proof = [proof];
		}
		for (let i = 0; i < proof.length; i++) {
			if (proof[i].type === suite.type) {
				const result = await suite.verifyProof(proof[i], credential, documentLoader);
				if (!result.verified) {
					errors.push(result.error);
				} else {
					checks.push(proof[i].proofPurpose);
				}
			}
		}
		if (checks.length === 0 && errors.length === 0) {
			throw new Error(`No proof types matched given suite: ${suite.type}`);
		}

		if (errors.length === 0) {
			return {
				verified: true,
				checks,
				warnings: undefined,
				errors: undefined
			};
		} else {
			return {
				verified: false,
				checks,
				warnings: undefined,
				errors
			};
		}
	}

	static async verifyPresentation(
		verifiablePresentation: VerifiablePresentation,
		suite: any,
		documentLoader: DocumentLoader
	): Promise<VerificationResult> {
		let errors = [];
		let checks = [];
		let { proof, ...presentation } = verifiablePresentation;

		if (!Array.isArray(proof)) {
			proof = [proof];
		}
		for (let i = 0; i < proof.length; i++) {
			console.log(proof[i].type);
			console.log(suite.type);
			if (proof[i].type === suite.type) {
				const result = await suite.verifyProof(proof[i], presentation, documentLoader);
				if (!result.verified) {
					errors.push(result.error);
				} else {
					checks.push(proof[i].proofPurpose);
				}
			}
		}

		if (checks.length === 0 && errors.length === 0) {
			throw new Error(`No proof types matched given suite: ${suite.type}`);
		}

		if (errors.length === 0) {
			return {
				verified: true,
				checks,
				warnings: undefined,
				errors: undefined
			};
		} else {
			return {
				verified: false,
				checks,
				warnings: undefined,
				errors
			};
		}
	}
}

================
File: src/tests/fixtures/credentials/case-1.json
================
{
	"@context": [
		"https://www.w3.org/2018/credentials/v1",
		"https://www.w3.org/2018/credentials/examples/v1",
		"https://w3c-ccg.github.io/lds-jws2020/contexts/lds-jws2020-v1.json",
		"https://w3id.org/security/suites/ed25519-2020/v1"
	],
	"id": "http://example.gov/credentials/3732",
	"type": ["VerifiableCredential", "UniversityDegreeCredential"],
	"issuer": { "id": "did:example:123" },
	"issuanceDate": "2020-03-10T04:24:12.164Z",
	"credentialSubject": {
		"id": "did:example:456",
		"degree": {
			"type": "BachelorDegree",
			"name": "Bachelor of Science and Arts"
		}
	}
}

================
File: src/tests/fixtures/credentials/case-10.json
================
{
  "@context": [
    "https://www.w3.org/2018/credentials/v1",
    "https://w3id.org/vaccination/v1"
  ],
  "type": ["VerifiableCredential", "VaccinationCertificate"],
  "id": "urn:uvci:af5vshde843jf831j128fj",
  "name": "COVID-19 Vaccination Certificate",
  "description": "COVID-19 Vaccination Certificate",
  "issuanceDate": "2019-12-03T12:19:52Z",
  "expirationDate": "2029-12-03T12:19:52Z",
  "issuer": "did:key:z6MkiY62766b1LJkExWMsM3QG4WtX7QpY823dxoYzr9qZvJ3",
  "credentialSubject": {
    "id": "did:example:123",
    "type": "VaccinationEvent",
    "batchNumber": "1183738569",
    "administeringCentre": "MoH",
    "healthProfessional": "MoH",
    "countryOfVaccination": "NZ",
    "recipient": {
      "type": "VaccineRecipient",
      "givenName": "JOHN",
      "familyName": "SMITH",
      "gender": "Male",
      "birthDate": "1958-07-17"
    },
    "vaccine": {
      "type": "Vaccine",
      "disease": "COVID-19",
      "atcCode": "J07BX03",
      "medicinalProductName": "COVID-19 Vaccine Moderna",
      "marketingAuthorizationHolder": "Moderna Biotech"
    }
  }
}

================
File: src/tests/fixtures/credentials/case-2.json
================
{
  "@context": [
    "https://www.w3.org/2018/credentials/v1",
    "https://w3id.org/vaccination/v1"
  ],
  "type": ["VerifiableCredential", "VaccinationCertificate"],
  "id": "urn:uvci:af5vshde843jf831j128fj",
  "name": "COVID-19 Vaccination Certificate",
  "description": "COVID-19 Vaccination Certificate",
  "issuanceDate": "2019-12-03T12:19:52Z",
  "expirationDate": "2029-12-03T12:19:52Z",
  "issuer": "did:key:z6MkiY62766b1LJkExWMsM3QG4WtX7QpY823dxoYzr9qZvJ3",
  "credentialSubject": {
    "id": "did:example:123",
    "type": "VaccinationEvent",
    "batchNumber": "1183738569",
    "administeringCentre": "MoH",
    "healthProfessional": "MoH",
    "countryOfVaccination": "NZ",
    "recipient": {
      "type": "VaccineRecipient",
      "givenName": "JOHN",
      "familyName": "SMITH",
      "gender": "Male",
      "birthDate": "1958-07-17"
    },
    "vaccine": {
      "type": "Vaccine",
      "disease": "COVID-19",
      "atcCode": "J07BX03",
      "medicinalProductName": "COVID-19 Vaccine Moderna",
      "marketingAuthorizationHolder": "Moderna Biotech"
    }
  }
}

================
File: src/tests/fixtures/crypto/contexts/credentials-examples.json
================
{
  "@context": [
    {
      "@version": 1.1
    },
    "https://www.w3.org/ns/odrl.jsonld",
    {
      "ex": "https://example.org/examples#",
      "schema": "http://schema.org/",
      "rdf": "http://www.w3.org/1999/02/22-rdf-syntax-ns#",

      "3rdPartyCorrelation": "ex:3rdPartyCorrelation",
      "AllVerifiers": "ex:AllVerifiers",
      "Archival": "ex:Archival",
      "BachelorDegree": "ex:BachelorDegree",
      "Child": "ex:Child",
      "CLCredentialDefinition2019": "ex:CLCredentialDefinition2019",
      "CLSignature2019": "ex:CLSignature2019",
      "IssuerPolicy": "ex:IssuerPolicy",
      "HolderPolicy": "ex:HolderPolicy",
      "Mother": "ex:Mother",
      "RelationshipCredential": "ex:RelationshipCredential",
      "UniversityDegreeCredential": "ex:UniversityDegreeCredential",
      "ZkpExampleSchema2018": "ex:ZkpExampleSchema2018",

      "issuerData": "ex:issuerData",
      "attributes": "ex:attributes",
      "signature": "ex:signature",
      "signatureCorrectnessProof": "ex:signatureCorrectnessProof",
      "primaryProof": "ex:primaryProof",
      "nonRevocationProof": "ex:nonRevocationProof",

      "alumniOf": { "@id": "schema:alumniOf", "@type": "rdf:HTML" },
      "child": { "@id": "ex:child", "@type": "@id" },
      "degree": "ex:degree",
      "degreeType": "ex:degreeType",
      "degreeSchool": "ex:degreeSchool",
      "college": "ex:college",
      "name": { "@id": "schema:name", "@type": "rdf:HTML" },
      "givenName": "schema:givenName",
      "familyName": "schema:familyName",
      "parent": { "@id": "ex:parent", "@type": "@id" },
      "referenceId": "ex:referenceId",
      "documentPresence": "ex:documentPresence",
      "evidenceDocument": "ex:evidenceDocument",
      "spouse": "schema:spouse",
      "subjectPresence": "ex:subjectPresence",
      "verifier": { "@id": "ex:verifier", "@type": "@id" }
    }
  ]
}

================
File: src/tests/fixtures/crypto/contexts/credentials.json
================
{
  "@context": {
    "@version": 1.1,
    "@protected": true,

    "id": "@id",
    "type": "@type",

    "VerifiableCredential": {
      "@id": "https://www.w3.org/2018/credentials#VerifiableCredential",
      "@context": {
        "@version": 1.1,
        "@protected": true,

        "id": "@id",
        "type": "@type",

        "cred": "https://www.w3.org/2018/credentials#",
        "sec": "https://w3id.org/security#",
        "xsd": "http://www.w3.org/2001/XMLSchema#",

        "credentialSchema": {
          "@id": "cred:credentialSchema",
          "@type": "@id",
          "@context": {
            "@version": 1.1,
            "@protected": true,

            "id": "@id",
            "type": "@type",

            "cred": "https://www.w3.org/2018/credentials#",

            "JsonSchemaValidator2018": "cred:JsonSchemaValidator2018"
          }
        },
        "credentialStatus": { "@id": "cred:credentialStatus", "@type": "@id" },
        "credentialSubject": {
          "@id": "cred:credentialSubject",
          "@type": "@id"
        },
        "evidence": { "@id": "cred:evidence", "@type": "@id" },
        "expirationDate": {
          "@id": "cred:expirationDate",
          "@type": "xsd:dateTime"
        },
        "holder": { "@id": "cred:holder", "@type": "@id" },
        "issued": { "@id": "cred:issued", "@type": "xsd:dateTime" },
        "issuer": { "@id": "cred:issuer", "@type": "@id" },
        "issuanceDate": { "@id": "cred:issuanceDate", "@type": "xsd:dateTime" },
        "proof": { "@id": "sec:proof", "@type": "@id", "@container": "@graph" },
        "refreshService": {
          "@id": "cred:refreshService",
          "@type": "@id",
          "@context": {
            "@version": 1.1,
            "@protected": true,

            "id": "@id",
            "type": "@type",

            "cred": "https://www.w3.org/2018/credentials#",

            "ManualRefreshService2018": "cred:ManualRefreshService2018"
          }
        },
        "termsOfUse": { "@id": "cred:termsOfUse", "@type": "@id" },
        "validFrom": { "@id": "cred:validFrom", "@type": "xsd:dateTime" },
        "validUntil": { "@id": "cred:validUntil", "@type": "xsd:dateTime" }
      }
    },

    "VerifiablePresentation": {
      "@id": "https://www.w3.org/2018/credentials#VerifiablePresentation",
      "@context": {
        "@version": 1.1,
        "@protected": true,

        "id": "@id",
        "type": "@type",

        "cred": "https://www.w3.org/2018/credentials#",
        "sec": "https://w3id.org/security#",

        "holder": { "@id": "cred:holder", "@type": "@id" },
        "proof": { "@id": "sec:proof", "@type": "@id", "@container": "@graph" },
        "verifiableCredential": {
          "@id": "cred:verifiableCredential",
          "@type": "@id",
          "@container": "@graph"
        }
      }
    },

    "EcdsaSecp256k1Signature2019": {
      "@id": "https://w3id.org/security#EcdsaSecp256k1Signature2019",
      "@context": {
        "@version": 1.1,
        "@protected": true,

        "id": "@id",
        "type": "@type",

        "sec": "https://w3id.org/security#",
        "xsd": "http://www.w3.org/2001/XMLSchema#",

        "challenge": "sec:challenge",
        "created": {
          "@id": "http://purl.org/dc/terms/created",
          "@type": "xsd:dateTime"
        },
        "domain": "sec:domain",
        "expires": { "@id": "sec:expiration", "@type": "xsd:dateTime" },
        "jws": "sec:jws",
        "nonce": "sec:nonce",
        "proofPurpose": {
          "@id": "sec:proofPurpose",
          "@type": "@vocab",
          "@context": {
            "@version": 1.1,
            "@protected": true,

            "id": "@id",
            "type": "@type",

            "sec": "https://w3id.org/security#",

            "assertionMethod": {
              "@id": "sec:assertionMethod",
              "@type": "@id",
              "@container": "@set"
            },
            "authentication": {
              "@id": "sec:authenticationMethod",
              "@type": "@id",
              "@container": "@set"
            }
          }
        },
        "proofValue": "sec:proofValue",
        "verificationMethod": {
          "@id": "sec:verificationMethod",
          "@type": "@id"
        }
      }
    },

    "EcdsaSecp256r1Signature2019": {
      "@id": "https://w3id.org/security#EcdsaSecp256r1Signature2019",
      "@context": {
        "@version": 1.1,
        "@protected": true,

        "id": "@id",
        "type": "@type",

        "sec": "https://w3id.org/security#",
        "xsd": "http://www.w3.org/2001/XMLSchema#",

        "challenge": "sec:challenge",
        "created": {
          "@id": "http://purl.org/dc/terms/created",
          "@type": "xsd:dateTime"
        },
        "domain": "sec:domain",
        "expires": { "@id": "sec:expiration", "@type": "xsd:dateTime" },
        "jws": "sec:jws",
        "nonce": "sec:nonce",
        "proofPurpose": {
          "@id": "sec:proofPurpose",
          "@type": "@vocab",
          "@context": {
            "@version": 1.1,
            "@protected": true,

            "id": "@id",
            "type": "@type",

            "sec": "https://w3id.org/security#",

            "assertionMethod": {
              "@id": "sec:assertionMethod",
              "@type": "@id",
              "@container": "@set"
            },
            "authentication": {
              "@id": "sec:authenticationMethod",
              "@type": "@id",
              "@container": "@set"
            }
          }
        },
        "proofValue": "sec:proofValue",
        "verificationMethod": {
          "@id": "sec:verificationMethod",
          "@type": "@id"
        }
      }
    },

    "Ed25519Signature2018": {
      "@id": "https://w3id.org/security#Ed25519Signature2018",
      "@context": {
        "@version": 1.1,
        "@protected": true,

        "id": "@id",
        "type": "@type",

        "sec": "https://w3id.org/security#",
        "xsd": "http://www.w3.org/2001/XMLSchema#",

        "challenge": "sec:challenge",
        "created": {
          "@id": "http://purl.org/dc/terms/created",
          "@type": "xsd:dateTime"
        },
        "domain": "sec:domain",
        "expires": { "@id": "sec:expiration", "@type": "xsd:dateTime" },
        "jws": "sec:jws",
        "nonce": "sec:nonce",
        "proofPurpose": {
          "@id": "sec:proofPurpose",
          "@type": "@vocab",
          "@context": {
            "@version": 1.1,
            "@protected": true,

            "id": "@id",
            "type": "@type",

            "sec": "https://w3id.org/security#",

            "assertionMethod": {
              "@id": "sec:assertionMethod",
              "@type": "@id",
              "@container": "@set"
            },
            "authentication": {
              "@id": "sec:authenticationMethod",
              "@type": "@id",
              "@container": "@set"
            }
          }
        },
        "proofValue": "sec:proofValue",
        "verificationMethod": {
          "@id": "sec:verificationMethod",
          "@type": "@id"
        }
      }
    },

    "RsaSignature2018": {
      "@id": "https://w3id.org/security#RsaSignature2018",
      "@context": {
        "@version": 1.1,
        "@protected": true,

        "challenge": "sec:challenge",
        "created": {
          "@id": "http://purl.org/dc/terms/created",
          "@type": "xsd:dateTime"
        },
        "domain": "sec:domain",
        "expires": { "@id": "sec:expiration", "@type": "xsd:dateTime" },
        "jws": "sec:jws",
        "nonce": "sec:nonce",
        "proofPurpose": {
          "@id": "sec:proofPurpose",
          "@type": "@vocab",
          "@context": {
            "@version": 1.1,
            "@protected": true,

            "id": "@id",
            "type": "@type",

            "sec": "https://w3id.org/security#",

            "assertionMethod": {
              "@id": "sec:assertionMethod",
              "@type": "@id",
              "@container": "@set"
            },
            "authentication": {
              "@id": "sec:authenticationMethod",
              "@type": "@id",
              "@container": "@set"
            }
          }
        },
        "proofValue": "sec:proofValue",
        "verificationMethod": {
          "@id": "sec:verificationMethod",
          "@type": "@id"
        }
      }
    },

    "proof": {
      "@id": "https://w3id.org/security#proof",
      "@type": "@id",
      "@container": "@graph"
    }
  }
}

================
File: src/tests/fixtures/crypto/contexts/dids.json
================
{
  "@context": {
    "@protected": true,
    "id": "@id",
    "type": "@type",

    "alsoKnownAs": {
      "@id": "https://www.w3.org/ns/activitystreams#alsoKnownAs",
      "@type": "@id"
    },
    "assertionMethod": {
      "@id": "https://w3id.org/security#assertionMethod",
      "@type": "@id",
      "@container": "@set"
    },
    "authentication": {
      "@id": "https://w3id.org/security#authenticationMethod",
      "@type": "@id",
      "@container": "@set"
    },
    "capabilityDelegation": {
      "@id": "https://w3id.org/security#capabilityDelegationMethod",
      "@type": "@id",
      "@container": "@set"
    },
    "capabilityInvocation": {
      "@id": "https://w3id.org/security#capabilityInvocationMethod",
      "@type": "@id",
      "@container": "@set"
    },
    "controller": {
      "@id": "https://w3id.org/security#controller",
      "@type": "@id"
    },
    "keyAgreement": {
      "@id": "https://w3id.org/security#keyAgreementMethod",
      "@type": "@id",
      "@container": "@set"
    },
    "service": {
      "@id": "https://www.w3.org/ns/did#service",
      "@type": "@id",
      "@context": {
        "@protected": true,
        "id": "@id",
        "type": "@type",
        "serviceEndpoint": {
          "@id": "https://www.w3.org/ns/did#serviceEndpoint",
          "@type": "@id"
        }
      }
    },
    "verificationMethod": {
      "@id": "https://w3id.org/security#verificationMethod",
      "@type": "@id"
    }
  }
}

================
File: src/tests/fixtures/crypto/contexts/ed255192020.json
================
{
	"@context": {
		"id": "@id",
		"type": "@type",
		"@protected": true,
		"proof": {
			"@id": "https://w3id.org/security#proof",
			"@type": "@id",
			"@container": "@graph"
		},
		"Ed25519VerificationKey2020": {
			"@id": "https://w3id.org/security#Ed25519VerificationKey2020",
			"@context": {
				"@protected": true,
				"id": "@id",
				"type": "@type",
				"controller": {
					"@id": "https://w3id.org/security#controller",
					"@type": "@id"
				},
				"revoked": {
					"@id": "https://w3id.org/security#revoked",
					"@type": "http://www.w3.org/2001/XMLSchema#dateTime"
				},
				"publicKeyMultibase": {
					"@id": "https://w3id.org/security#publicKeyMultibase",
					"@type": "https://w3id.org/security#multibase"
				}
			}
		},
		"Ed25519Signature2020": {
			"@id": "https://w3id.org/security#Ed25519Signature2020",
			"@context": {
				"@protected": true,
				"id": "@id",
				"type": "@type",
				"challenge": "https://w3id.org/security#challenge",
				"created": {
					"@id": "http://purl.org/dc/terms/created",
					"@type": "http://www.w3.org/2001/XMLSchema#dateTime"
				},
				"domain": "https://w3id.org/security#domain",
				"expires": {
					"@id": "https://w3id.org/security#expiration",
					"@type": "http://www.w3.org/2001/XMLSchema#dateTime"
				},
				"nonce": "https://w3id.org/security#nonce",
				"proofPurpose": {
					"@id": "https://w3id.org/security#proofPurpose",
					"@type": "@vocab",
					"@context": {
						"@protected": true,
						"id": "@id",
						"type": "@type",
						"assertionMethod": {
							"@id": "https://w3id.org/security#assertionMethod",
							"@type": "@id",
							"@container": "@set"
						},
						"authentication": {
							"@id": "https://w3id.org/security#authenticationMethod",
							"@type": "@id",
							"@container": "@set"
						},
						"capabilityInvocation": {
							"@id": "https://w3id.org/security#capabilityInvocationMethod",
							"@type": "@id",
							"@container": "@set"
						},
						"capabilityDelegation": {
							"@id": "https://w3id.org/security#capabilityDelegationMethod",
							"@type": "@id",
							"@container": "@set"
						},
						"keyAgreement": {
							"@id": "https://w3id.org/security#keyAgreementMethod",
							"@type": "@id",
							"@container": "@set"
						}
					}
				},
				"proofValue": {
					"@id": "https://w3id.org/security#proofValue",
					"@type": "https://w3id.org/security#multibase"
				},
				"verificationMethod": {
					"@id": "https://w3id.org/security#verificationMethod",
					"@type": "@id"
				}
			}
		}
	}
}

================
File: src/tests/fixtures/crypto/contexts/jws2020.json
================
{
  "@context": {
    "JsonWebKey2020": "https://w3id.org/security#JsonWebKey2020",
    "JsonWebSignature2020": {
      "@id": "https://w3id.org/security#JsonWebSignature2020",
      "@context": {
        "@protected": true,

        "id": "@id",
        "type": "@type",

        "challenge": "https://w3id.org/security#challenge",
        "created": {
          "@id": "http://purl.org/dc/terms/created",
          "@type": "http://www.w3.org/2001/XMLSchema#dateTime"
        },
        "domain": "https://w3id.org/security#domain",
        "expires": {
          "@id": "https://w3id.org/security#expiration",
          "@type": "http://www.w3.org/2001/XMLSchema#dateTime"
        },
        "jws": "https://w3id.org/security#jws",
        "nonce": "https://w3id.org/security#nonce",
        "proofPurpose": {
          "@id": "https://w3id.org/security#proofPurpose",
          "@type": "@vocab",
          "@context": {
            "@protected": true,

            "id": "@id",
            "type": "@type",

            "assertionMethod": {
              "@id": "https://w3id.org/security#assertionMethod",
              "@type": "@id",
              "@container": "@set"
            },
            "authentication": {
              "@id": "https://w3id.org/security#authenticationMethod",
              "@type": "@id",
              "@container": "@set"
            }
          }
        },
        "proofValue": "https://w3id.org/security#proofValue",
        "verificationMethod": {
          "@id": "https://w3id.org/security#verificationMethod",
          "@type": "@id"
        }
      }
    }
  }
}

================
File: src/tests/fixtures/crypto/contexts/odrl.json
================
{
  "@context": {
    "odrl": "http://www.w3.org/ns/odrl/2/",
    "rdf": "http://www.w3.org/1999/02/22-rdf-syntax-ns#",
    "rdfs": "http://www.w3.org/2000/01/rdf-schema#",
    "owl": "http://www.w3.org/2002/07/owl#",
    "skos": "http://www.w3.org/2004/02/skos/core#",
    "dct": "http://purl.org/dc/terms/",
    "xsd": "http://www.w3.org/2001/XMLSchema#",
    "vcard": "http://www.w3.org/2006/vcard/ns#",
    "foaf": "http://xmlns.com/foaf/0.1/",
    "schema": "http://schema.org/",
    "cc": "http://creativecommons.org/ns#",

    "uid": "@id",
    "type": "@type",

    "Policy": "odrl:Policy",
    "Rule": "odrl:Rule",
    "profile": { "@type": "@id", "@id": "odrl:profile" },

    "inheritFrom": { "@type": "@id", "@id": "odrl:inheritFrom" },

    "ConflictTerm": "odrl:ConflictTerm",
    "conflict": { "@type": "@vocab", "@id": "odrl:conflict" },
    "perm": "odrl:perm",
    "prohibit": "odrl:prohibit",
    "invalid": "odrl:invalid",

    "Agreement": "odrl:Agreement",
    "Assertion": "odrl:Assertion",
    "Offer": "odrl:Offer",
    "Privacy": "odrl:Privacy",
    "Request": "odrl:Request",
    "Set": "odrl:Set",
    "Ticket": "odrl:Ticket",

    "Asset": "odrl:Asset",
    "AssetCollection": "odrl:AssetCollection",
    "relation": { "@type": "@id", "@id": "odrl:relation" },
    "hasPolicy": { "@type": "@id", "@id": "odrl:hasPolicy" },

    "target": { "@type": "@id", "@id": "odrl:target" },
    "output": { "@type": "@id", "@id": "odrl:output" },

    "partOf": { "@type": "@id", "@id": "odrl:partOf" },
    "source": { "@type": "@id", "@id": "odrl:source" },

    "Party": "odrl:Party",
    "PartyCollection": "odrl:PartyCollection",
    "function": { "@type": "@vocab", "@id": "odrl:function" },
    "PartyScope": "odrl:PartyScope",

    "assignee": { "@type": "@id", "@id": "odrl:assignee" },
    "assigner": { "@type": "@id", "@id": "odrl:assigner" },
    "assigneeOf": { "@type": "@id", "@id": "odrl:assigneeOf" },
    "assignerOf": { "@type": "@id", "@id": "odrl:assignerOf" },
    "attributedParty": { "@type": "@id", "@id": "odrl:attributedParty" },
    "attributingParty": { "@type": "@id", "@id": "odrl:attributingParty" },
    "compensatedParty": { "@type": "@id", "@id": "odrl:compensatedParty" },
    "compensatingParty": { "@type": "@id", "@id": "odrl:compensatingParty" },
    "consentingParty": { "@type": "@id", "@id": "odrl:consentingParty" },
    "consentedParty": { "@type": "@id", "@id": "odrl:consentedParty" },
    "informedParty": { "@type": "@id", "@id": "odrl:informedParty" },
    "informingParty": { "@type": "@id", "@id": "odrl:informingParty" },
    "trackingParty": { "@type": "@id", "@id": "odrl:trackingParty" },
    "trackedParty": { "@type": "@id", "@id": "odrl:trackedParty" },
    "contractingParty": { "@type": "@id", "@id": "odrl:contractingParty" },
    "contractedParty": { "@type": "@id", "@id": "odrl:contractedParty" },

    "Action": "odrl:Action",
    "action": { "@type": "@vocab", "@id": "odrl:action" },
    "includedIn": { "@type": "@id", "@id": "odrl:includedIn" },
    "implies": { "@type": "@id", "@id": "odrl:implies" },

    "Permission": "odrl:Permission",
    "permission": { "@type": "@id", "@id": "odrl:permission" },

    "Prohibition": "odrl:Prohibition",
    "prohibition": { "@type": "@id", "@id": "odrl:prohibition" },

    "obligation": { "@type": "@id", "@id": "odrl:obligation" },

    "use": "odrl:use",
    "grantUse": "odrl:grantUse",
    "aggregate": "odrl:aggregate",
    "annotate": "odrl:annotate",
    "anonymize": "odrl:anonymize",
    "archive": "odrl:archive",
    "concurrentUse": "odrl:concurrentUse",
    "derive": "odrl:derive",
    "digitize": "odrl:digitize",
    "display": "odrl:display",
    "distribute": "odrl:distribute",
    "execute": "odrl:execute",
    "extract": "odrl:extract",
    "give": "odrl:give",
    "index": "odrl:index",
    "install": "odrl:install",
    "modify": "odrl:modify",
    "move": "odrl:move",
    "play": "odrl:play",
    "present": "odrl:present",
    "print": "odrl:print",
    "read": "odrl:read",
    "reproduce": "odrl:reproduce",
    "sell": "odrl:sell",
    "stream": "odrl:stream",
    "textToSpeech": "odrl:textToSpeech",
    "transfer": "odrl:transfer",
    "transform": "odrl:transform",
    "translate": "odrl:translate",

    "Duty": "odrl:Duty",
    "duty": { "@type": "@id", "@id": "odrl:duty" },
    "consequence": { "@type": "@id", "@id": "odrl:consequence" },
    "remedy": { "@type": "@id", "@id": "odrl:remedy" },

    "acceptTracking": "odrl:acceptTracking",
    "attribute": "odrl:attribute",
    "compensate": "odrl:compensate",
    "delete": "odrl:delete",
    "ensureExclusivity": "odrl:ensureExclusivity",
    "include": "odrl:include",
    "inform": "odrl:inform",
    "nextPolicy": "odrl:nextPolicy",
    "obtainConsent": "odrl:obtainConsent",
    "reviewPolicy": "odrl:reviewPolicy",
    "uninstall": "odrl:uninstall",
    "watermark": "odrl:watermark",

    "Constraint": "odrl:Constraint",
    "LogicalConstraint": "odrl:LogicalConstraint",
    "constraint": { "@type": "@id", "@id": "odrl:constraint" },
    "refinement": { "@type": "@id", "@id": "odrl:refinement" },
    "Operator": "odrl:Operator",
    "operator": { "@type": "@vocab", "@id": "odrl:operator" },
    "RightOperand": "odrl:RightOperand",
    "rightOperand": "odrl:rightOperand",
    "rightOperandReference": {
      "@type": "xsd:anyURI",
      "@id": "odrl:rightOperandReference"
    },
    "LeftOperand": "odrl:LeftOperand",
    "leftOperand": { "@type": "@vocab", "@id": "odrl:leftOperand" },
    "unit": "odrl:unit",
    "dataType": { "@type": "xsd:anyType", "@id": "odrl:datatype" },
    "status": "odrl:status",

    "absolutePosition": "odrl:absolutePosition",
    "absoluteSpatialPosition": "odrl:absoluteSpatialPosition",
    "absoluteTemporalPosition": "odrl:absoluteTemporalPosition",
    "absoluteSize": "odrl:absoluteSize",
    "count": "odrl:count",
    "dateTime": "odrl:dateTime",
    "delayPeriod": "odrl:delayPeriod",
    "deliveryChannel": "odrl:deliveryChannel",
    "elapsedTime": "odrl:elapsedTime",
    "event": "odrl:event",
    "fileFormat": "odrl:fileFormat",
    "industry": "odrl:industry:",
    "language": "odrl:language",
    "media": "odrl:media",
    "meteredTime": "odrl:meteredTime",
    "payAmount": "odrl:payAmount",
    "percentage": "odrl:percentage",
    "product": "odrl:product",
    "purpose": "odrl:purpose",
    "recipient": "odrl:recipient",
    "relativePosition": "odrl:relativePosition",
    "relativeSpatialPosition": "odrl:relativeSpatialPosition",
    "relativeTemporalPosition": "odrl:relativeTemporalPosition",
    "relativeSize": "odrl:relativeSize",
    "resolution": "odrl:resolution",
    "spatial": "odrl:spatial",
    "spatialCoordinates": "odrl:spatialCoordinates",
    "systemDevice": "odrl:systemDevice",
    "timeInterval": "odrl:timeInterval",
    "unitOfCount": "odrl:unitOfCount",
    "version": "odrl:version",
    "virtualLocation": "odrl:virtualLocation",

    "eq": "odrl:eq",
    "gt": "odrl:gt",
    "gteq": "odrl:gteq",
    "lt": "odrl:lt",
    "lteq": "odrl:lteq",
    "neq": "odrl:neg",
    "isA": "odrl:isA",
    "hasPart": "odrl:hasPart",
    "isPartOf": "odrl:isPartOf",
    "isAllOf": "odrl:isAllOf",
    "isAnyOf": "odrl:isAnyOf",
    "isNoneOf": "odrl:isNoneOf",
    "or": "odrl:or",
    "xone": "odrl:xone",
    "and": "odrl:and",
    "andSequence": "odrl:andSequence",

    "policyUsage": "odrl:policyUsage"
  }
}

================
File: src/tests/fixtures/crypto/contexts/vaccination.json
================
{
  "@context": {
      "@version": 1.1,
      "@protected": true,
      "id": "@id",
      "type": "@type",
      "description": "http://schema.org/description",
      "identifier": "http://schema.org/identifier",
      "name": "http://schema.org/name",
      "image": "http://schema.org/image",
      "VaccinationCertificate": {
          "@id": "https://w3id.org/vaccination#VaccinationCertificate",
          "@context": {
              "@version": 1.1,
              "@protected": true,
              "id": "@id",
              "type": "@type",
              "description": "http://schema.org/description",
              "identifier": "http://schema.org/identifier",
              "name": "http://schema.org/name",
              "image": "http://schema.org/image"
          }
      },
      "VaccinationEvent": {
          "@id": "https://w3id.org/vaccination#VaccinationEvent",
          "@context": {
              "@version": 1.1,
              "@protected": true,
              "id": "@id",
              "type": "@type",
              "administeringCentre": "https://w3id.org/vaccination#administeringCentre",
              "batchNumber": "https://w3id.org/vaccination#batchNumber",
              "countryOfVaccination": "https://w3id.org/vaccination#countryOfVaccination",
              "dateOfVaccination": {
                  "@id": "https://w3id.org/vaccination#dateOfVaccination",
                  "@type": "http://www.w3.org/2001/XMLSchema#dateTime"
              },
              "healthProfessional": "https://w3id.org/vaccination#healthProfessional",
              "nextVaccinationDate": {
                  "@id": "https://w3id.org/vaccination#nextVaccinationDate",
                  "@type": "http://www.w3.org/2001/XMLSchema#dateTime"
              },
              "order": "https://w3id.org/vaccination#order",
              "recipient": {
                  "@id": "https://w3id.org/vaccination#recipient",
                  "@type": "https://w3id.org/vaccination#VaccineRecipient"
              },
              "vaccine": {
                  "@id": "https://w3id.org/vaccination#VaccineEventVaccine",
                  "@type": "https://w3id.org/vaccination#Vaccine"
              }
          }
      },
      "VaccineRecipient": {
          "@id": "https://w3id.org/vaccination#VaccineRecipient",
          "@context": {
              "@version": 1.1,
              "@protected": true,
              "id": "@id",
              "type": "@type",
              "birthDate": {
                  "@id": "http://schema.org/birthDate",
                  "@type": "http://www.w3.org/2001/XMLSchema#dateTime"
              },
              "familyName": "http://schema.org/familyName",
              "gender": "http://schema.org/gender",
              "givenName": "http://schema.org/givenName"
          }
      },
      "Vaccine": {
          "@id": "https://w3id.org/vaccination#Vaccine",
          "@context": {
              "@version": 1.1,
              "@protected": true,
              "id": "@id",
              "type": "@type",
              "atcCode": "https://w3id.org/vaccination#atc-code",
              "disease": "https://w3id.org/vaccination#disease",
              "event": {
                  "@id": "https://w3id.org/vaccination#VaccineRecipientVaccineEvent",
                  "@type": "https://w3id.org/vaccination#VaccineEvent"
              },
              "marketingAuthorizationHolder": "https://w3id.org/vaccination#marketingAuthorizationHolder",
              "medicinalProductName": "https://w3id.org/vaccination#medicinalProductName"
          }
      }
  }
}

================
File: src/tests/fixtures/crypto/didDocuments/ed255192020.json
================
{
	"@context": ["https://www.w3.org/ns/did/v1", "https://w3id.org/security/suites/ed25519-2020/v1"],
	"id": "did:key:z6MknCCLeeHBUaHu4aHSVLDCYQW9gjVJ7a63FpMvtuVMy53T",
	"verificationMethod": [
		{
			"id": "did:key:z6MknCCLeeHBUaHu4aHSVLDCYQW9gjVJ7a63FpMvtuVMy53T#z6MknCCLeeHBUaHu4aHSVLDCYQW9gjVJ7a63FpMvtuVMy53T",
			"type": "Ed25519VerificationKey2018",
			"controller": "did:key:z6MknCCLeeHBUaHu4aHSVLDCYQW9gjVJ7a63FpMvtuVMy53T",
			"publicKeyMultibase": "z6MknCCLeeHBUaHu4aHSVLDCYQW9gjVJ7a63FpMvtuVMy53T"
		}
	],
	"authentication": [
		"did:key:z6MknCCLeeHBUaHu4aHSVLDCYQW9gjVJ7a63FpMvtuVMy53T#z6MknCCLeeHBUaHu4aHSVLDCYQW9gjVJ7a63FpMvtuVMy53T"
	],
	"assertionMethod": [
		"did:key:z6MknCCLeeHBUaHu4aHSVLDCYQW9gjVJ7a63FpMvtuVMy53T#z6MknCCLeeHBUaHu4aHSVLDCYQW9gjVJ7a63FpMvtuVMy53T"
	]
}

================
File: src/tests/fixtures/crypto/proofs/case-1.json
================
{
  "type": "JsonWebSignature2020",
  "proofPurpose": "assertionMethod",
  "verificationMethod": "did:example:123#key-1",
  "created": "2024-09-27T02:33:54.577Z",
  "jws": "eyJiNjQiOmZhbHNlLCJjcml0IjpbImI2NCJdLCJhbGciOiJFUzI1NksifQ..OSFrWIIqO_kaUTm-LzEWtj7-MH5ASzlhyP0Q0ONOQ0UKf18jaWdN5a_pk4v_GljYwryevH1mnkoKKTS7V8IiIA"
}

================
File: src/tests/fixtures/crypto/proofs/case-2.json
================
{
  "type": "JsonWebSignature2020",
  "proofPurpose": "assertionMethod",
  "verificationMethod": "did:example:123#key-1",
  "created": "2024-09-27T03:06:20.746Z",
  "jws": "eyJiNjQiOmZhbHNlLCJjcml0IjpbImI2NCJdLCJhbGciOiJFUzI1NksifQ..HJg04Eg3Q4EnRez6bQX5dZgeFH6qmvT5IkLxeH05k2pyBjujgf77uD23mGyTf6MAMnkJWJe3sWjRAw1ZV1d6qg"
}

================
File: src/tests/fixtures/crypto/proofs/with-challenge-and-domain.json
================
{
  "type": "JsonWebSignature2020",
  "proofPurpose": "assertionMethod",
  "created": "2021-11-26T17:55:42Z",
  "challenge": "challenge123",
  "domain": "domain123",
  "verificationMethod": "did:example:123#key-1",
  "jws": "eyJiNjQiOmZhbHNlLCJjcml0IjpbImI2NCJdLCJhbGciOiJFUzI1NksifQ..NRq4A3HJuWbTAln3vPsC_9HEwl9RwQde2ho8y_MUlow0U39zCEK7l7_OFPZ59vTPcQw_kWxV1fGhwSVERF7Yyg"
}

================
File: src/tests/fixtures/crypto/controller.json
================
{
  "@context": [
    "https://www.w3.org/ns/did/v1",
    "https://w3c-ccg.github.io/lds-jws2020/contexts/lds-jws2020-v1.json"
  ],
  "id": "did:example:123",
  "verificationMethod": [
    {
      "id": "did:example:123#key-1",
      "type": "JsonWebKey2020",
      "controller": "did:example:123",
      "publicKeyJwk": {
        "kty": "EC",
        "crv": "secp256k1",
        "x": "BuzCc8bUShI3GfVz-WLISZDGq7wnVB4h_nvNQcWn7Jw",
        "y": "dLrbspB9PZvZF0dr42nCmF38192dQKglvB52IZBM-vs"
      },
      "privateKeyJwk": {
        "kty": "EC",
        "crv": "secp256k1",
        "x": "BuzCc8bUShI3GfVz-WLISZDGq7wnVB4h_nvNQcWn7Jw",
        "y": "dLrbspB9PZvZF0dr42nCmF38192dQKglvB52IZBM-vs",
        "d": "ts22WN9V4DHvonMysnyhdkOBwX9bVCusl1GXImD9Pic"
      }
    }
  ],
  "assertionMethod": ["did:example:123#key-1"],
  "authentication": ["did:example:123#key-1"]
}

================
File: src/tests/fixtures/crypto/documentLoader.ts
================
import jws from "./contexts/jws2020.json";
import credentialExamples from "./contexts/credentials-examples.json";
import credentials from "./contexts/credentials.json";
import ed255192020 from "./contexts/ed255192020.json"
import didDoc from "./didDocuments/ed255192020.json"
import dids from "./contexts/dids.json";
import odrl from "./contexts/odrl.json";
import controller from "./controller.json";
import vax from "./contexts/vaccination.json";

const documents: any = {
  "https://w3c-ccg.github.io/lds-jws2020/contexts/lds-jws2020-v1.json": jws,
  "https://www.w3.org/2018/credentials/examples/v1": credentialExamples,
  "https://www.w3.org/2018/credentials/v1": credentials,
  "https://www.w3.org/ns/did/v1": dids,
  "https://www.w3.org/ns/odrl.jsonld": odrl,
  "https://w3id.org/vaccination/v1": vax,
  "https://w3id.org/security/suites/ed25519-2020/v1": ed255192020
};

export const documentLoader = async (iri: string): Promise<{ document: any; documentUrl: string; contextUrl: string }> => {
  try {
    if (iri.startsWith("did:example:123")) {
      return {
        document: controller,
        documentUrl: "did:example:123",
        contextUrl: ''
      };
    }
    if (iri.startsWith('did:key:z6MknCCLeeHBUaHu4aHSVLDCYQW9gjVJ7a63FpMvtuVMy53T')) {
      return {
        document: didDoc,
        documentUrl: "did:key:z6MknCCLeeHBUaHu4aHSVLDCYQW9gjVJ7a63FpMvtuVMy53T",
        contextUrl: ''
      }
    }
    return {
      document: documents[iri],
      documentUrl: iri,
      contextUrl: ''
    };
  } catch (e) {
    console.error(e, iri);
    return {
      document: null,
      documentUrl: iri,
      contextUrl: ''    };
  }
};

================
File: src/tests/fixtures/crypto/HD.json
================
{
	"secp256k1": [
		[
			"000102030405060708090a0b0c0d0e0f",
			"m",
			"xprv9s21ZrQH143K3QTDL4LXw2F7HEK3wJUD2nW2nRk4stbPy6cq3jPPqjiChkVvvNKmPGJxWUtg6LnF5kejMRNNU3TGtRBeJgk33yuGBxrMPHi"
		],
		[
			"000102030405060708090a0b0c0d0e0f",
			"m/0'",
			"xprv9uHRZZhk6KAJC1avXpDAp4MDc3sQKNxDiPvvkX8Br5ngLNv1TxvUxt4cV1rGL5hj6KCesnDYUhd7oWgT11eZG7XnxHrnYeSvkzY7d2bhkJ7"
		],
		[
			"000102030405060708090a0b0c0d0e0f",
			"m/0'/1",
			"xprv9wTYmMFdV23N2TdNG573QoEsfRrWKQgWeibmLntzniatZvR9BmLnvSxqu53Kw1UmYPxLgboyZQaXwTCg8MSY3H2EU4pWcQDnRnrVA1xe8fs"
		],
		[
			"000102030405060708090a0b0c0d0e0f",
			"m/0'/1/2'",
			"xprv9z4pot5VBttmtdRTWfWQmoH1taj2axGVzFqSb8C9xaxKymcFzXBDptWmT7FwuEzG3ryjH4ktypQSAewRiNMjANTtpgP4mLTj34bhnZX7UiM"
		],
		[
			"000102030405060708090a0b0c0d0e0f",
			"m/0'/1/2'/2",
			"xprvA2JDeKCSNNZky6uBCviVfJSKyQ1mDYahRjijr5idH2WwLsEd4Hsb2Tyh8RfQMuPh7f7RtyzTtdrbdqqsunu5Mm3wDvUAKRHSC34sJ7in334"
		],
		[
			"000102030405060708090a0b0c0d0e0f",
			"m/0'/1/2'/2/1000000000",
			"xprvA41z7zogVVwxVSgdKUHDy1SKmdb533PjDz7J6N6mV6uS3ze1ai8FHa8kmHScGpWmj4WggLyQjgPie1rFSruoUihUZREPSL39UNdE3BBDu76"
		],
		[
			"fffcf9f6f3f0edeae7e4e1dedbd8d5d2cfccc9c6c3c0bdbab7b4b1aeaba8a5a29f9c999693908d8a8784817e7b7875726f6c696663605d5a5754514e4b484542",
			"m",
			"xprv9s21ZrQH143K31xYSDQpPDxsXRTUcvj2iNHm5NUtrGiGG5e2DtALGdso3pGz6ssrdK4PFmM8NSpSBHNqPqm55Qn3LqFtT2emdEXVYsCzC2U"
		],
		[
			"fffcf9f6f3f0edeae7e4e1dedbd8d5d2cfccc9c6c3c0bdbab7b4b1aeaba8a5a29f9c999693908d8a8784817e7b7875726f6c696663605d5a5754514e4b484542",
			"m/0",
			"xprv9vHkqa6EV4sPZHYqZznhT2NPtPCjKuDKGY38FBWLvgaDx45zo9WQRUT3dKYnjwih2yJD9mkrocEZXo1ex8G81dwSM1fwqWpWkeS3v86pgKt"
		],
		[
			"fffcf9f6f3f0edeae7e4e1dedbd8d5d2cfccc9c6c3c0bdbab7b4b1aeaba8a5a29f9c999693908d8a8784817e7b7875726f6c696663605d5a5754514e4b484542",
			"m/0/2147483647'",
			"xprv9wSp6B7kry3Vj9m1zSnLvN3xH8RdsPP1Mh7fAaR7aRLcQMKTR2vidYEeEg2mUCTAwCd6vnxVrcjfy2kRgVsFawNzmjuHc2YmYRmagcEPdU9"
		],
		[
			"fffcf9f6f3f0edeae7e4e1dedbd8d5d2cfccc9c6c3c0bdbab7b4b1aeaba8a5a29f9c999693908d8a8784817e7b7875726f6c696663605d5a5754514e4b484542",
			"m/0/2147483647'/1",
			"xprv9zFnWC6h2cLgpmSA46vutJzBcfJ8yaJGg8cX1e5StJh45BBciYTRXSd25UEPVuesF9yog62tGAQtHjXajPPdbRCHuWS6T8XA2ECKADdw4Ef"
		],
		[
			"fffcf9f6f3f0edeae7e4e1dedbd8d5d2cfccc9c6c3c0bdbab7b4b1aeaba8a5a29f9c999693908d8a8784817e7b7875726f6c696663605d5a5754514e4b484542",
			"m/0/2147483647'/1/2147483646'",
			"xprvA1RpRA33e1JQ7ifknakTFpgNXPmW2YvmhqLQYMmrj4xJXXWYpDPS3xz7iAxn8L39njGVyuoseXzU6rcxFLJ8HFsTjSyQbLYnMpCqE2VbFWc"
		],
		[
			"fffcf9f6f3f0edeae7e4e1dedbd8d5d2cfccc9c6c3c0bdbab7b4b1aeaba8a5a29f9c999693908d8a8784817e7b7875726f6c696663605d5a5754514e4b484542",
			"m/0/2147483647'/1/2147483646'/2",
			"xprvA2nrNbFZABcdryreWet9Ea4LvTJcGsqrMzxHx98MMrotbir7yrKCEXw7nadnHM8Dq38EGfSh6dqA9QWTyefMLEcBYJUuekgW4BYPJcr9E7j"
		],
		[
			"4b381541583be4423346c643850da4b320e46a87ae3d2a4e6da11eba819cd4acba45d239319ac14f863b8d5ab5a0d0c64d2e8a1e7d1457df2e5a3c51c73235be",
			"m",
			"xprv9s21ZrQH143K25QhxbucbDDuQ4naNntJRi4KUfWT7xo4EKsHt2QJDu7KXp1A3u7Bi1j8ph3EGsZ9Xvz9dGuVrtHHs7pXeTzjuxBrCmmhgC6"
		],
		[
			"4b381541583be4423346c643850da4b320e46a87ae3d2a4e6da11eba819cd4acba45d239319ac14f863b8d5ab5a0d0c64d2e8a1e7d1457df2e5a3c51c73235be",
			"m/0'",
			"xprv9uPDJpEQgRQfDcW7BkF7eTya6RPxXeJCqCJGHuCJ4GiRVLzkTXBAJMu2qaMWPrS7AANYqdq6vcBcBUdJCVVFceUvJFjaPdGZ2y9WACViL4L"
		],
		[
			"3ddd5602285899a946114506157c7997e5444528f3003f6134712147db19b678",
			"m",
			"xprv9s21ZrQH143K48vGoLGRPxgo2JNkJ3J3fqkirQC2zVdk5Dgd5w14S7fRDyHH4dWNHUgkvsvNDCkvAwcSHNAQwhwgNMgZhLtQC63zxwhQmRv"
		],
		[
			"3ddd5602285899a946114506157c7997e5444528f3003f6134712147db19b678",
			"m/0'",
			"xprv9vB7xEWwNp9kh1wQRfCCQMnZUEG21LpbR9NPCNN1dwhiZkjjeGRnaALmPXCX7SgjFTiCTT6bXes17boXtjq3xLpcDjzEuGLQBM5ohqkao9G"
		],
		[
			"3ddd5602285899a946114506157c7997e5444528f3003f6134712147db19b678",
			"m/0'/1'",
			"xprv9xJocDuwtYCMNAo3Zw76WENQeAS6WGXQ55RCy7tDJ8oALr4FWkuVoHJeHVAcAqiZLE7Je3vZJHxspZdFHfnBEjHqU5hG1Jaj32dVoS6XLT1"
		]
	],
	"ed25519": [
		{
			"seed": "000102030405060708090a0b0c0d0e0f",
			"path": "m",
			"fingerprint": "00000000",
			"chainCode": "90046a93de5380a72b5e45010748567d5ea02bbf6522f979e05c0d8d8ca9fffb",
			"privateKey": "2b4be7f19ee27bbf30c667b642d5f4aa69fd169872f8fc3059c08ebae2eb19e7",
			"publicKey": "00a4b2856bfec510abab89753fac1ac0e1112364e7d250545963f135f2a33188ed"
		},
		{
			"seed": "000102030405060708090a0b0c0d0e0f",
			"path": "m/0'",
			"fingerprint": "ddebc675",
			"chainCode": "8b59aa11380b624e81507a27fedda59fea6d0b779a778918a2fd3590e16e9c69",
			"privateKey": "68e0fe46dfb67e368c75379acec591dad19df3cde26e63b93a8e704f1dade7a3",
			"publicKey": "008c8a13df77a28f3445213a0f432fde644acaa215fc72dcdf300d5efaa85d350c"
		},
		{
			"seed": "000102030405060708090a0b0c0d0e0f",
			"path": "m/0'/1'",
			"fingerprint": "13dab143",
			"chainCode": "a320425f77d1b5c2505a6b1b27382b37368ee640e3557c315416801243552f14",
			"privateKey": "b1d0bad404bf35da785a64ca1ac54b2617211d2777696fbffaf208f746ae84f2",
			"publicKey": "001932a5270f335bed617d5b935c80aedb1a35bd9fc1e31acafd5372c30f5c1187"
		},
		{
			"seed": "000102030405060708090a0b0c0d0e0f",
			"path": "m/0'/1'/2'",
			"fingerprint": "ebe4cb29",
			"chainCode": "2e69929e00b5ab250f49c3fb1c12f252de4fed2c1db88387094a0f8c4c9ccd6c",
			"privateKey": "92a5b23c0b8a99e37d07df3fb9966917f5d06e02ddbd909c7e184371463e9fc9",
			"publicKey": "00ae98736566d30ed0e9d2f4486a64bc95740d89c7db33f52121f8ea8f76ff0fc1"
		},
		{
			"seed": "000102030405060708090a0b0c0d0e0f",
			"path": "m/0'/1'/2'/2'",
			"fingerprint": "316ec1c6",
			"chainCode": "8f6d87f93d750e0efccda017d662a1b31a266e4a6f5993b15f5c1f07f74dd5cc",
			"privateKey": "30d1dc7e5fc04c31219ab25a27ae00b50f6fd66622f6e9c913253d6511d1e662",
			"publicKey": "008abae2d66361c879b900d204ad2cc4984fa2aa344dd7ddc46007329ac76c429c"
		},
		{
			"seed": "000102030405060708090a0b0c0d0e0f",
			"path": "m/0'/1'/2'/2'/1000000000'",
			"fingerprint": "d6322ccd",
			"chainCode": "68789923a0cac2cd5a29172a475fe9e0fb14cd6adb5ad98a3fa70333e7afa230",
			"privateKey": "8f94d394a8e8fd6b1bc2f3f49f5c47e385281d5c17e65324b0f62483e37e8793",
			"publicKey": "003c24da049451555d51a7014a37337aa4e12d41e485abccfa46b47dfb2af54b7a"
		},
		{
			"seed": "fffcf9f6f3f0edeae7e4e1dedbd8d5d2cfccc9c6c3c0bdbab7b4b1aeaba8a5a29f9c999693908d8a8784817e7b7875726f6c696663605d5a5754514e4b484542",
			"path": "m",
			"fingerprint": "00000000",
			"chainCode": "ef70a74db9c3a5af931b5fe73ed8e1a53464133654fd55e7a66f8570b8e33c3b",
			"privateKey": "171cb88b1b3c1db25add599712e36245d75bc65a1a5c9e18d76f9f2b1eab4012",
			"publicKey": "008fe9693f8fa62a4305a140b9764c5ee01e455963744fe18204b4fb948249308a"
		},
		{
			"seed": "fffcf9f6f3f0edeae7e4e1dedbd8d5d2cfccc9c6c3c0bdbab7b4b1aeaba8a5a29f9c999693908d8a8784817e7b7875726f6c696663605d5a5754514e4b484542",
			"path": "m/0'",
			"fingerprint": "31981b50",
			"chainCode": "0b78a3226f915c082bf118f83618a618ab6dec793752624cbeb622acb562862d",
			"privateKey": "1559eb2bbec5790b0c65d8693e4d0875b1747f4970ae8b650486ed7470845635",
			"publicKey": "0086fab68dcb57aa196c77c5f264f215a112c22a912c10d123b0d03c3c28ef1037"
		},
		{
			"seed": "fffcf9f6f3f0edeae7e4e1dedbd8d5d2cfccc9c6c3c0bdbab7b4b1aeaba8a5a29f9c999693908d8a8784817e7b7875726f6c696663605d5a5754514e4b484542",
			"path": "m/0'/2147483647'",
			"fingerprint": "1e9411b1",
			"chainCode": "138f0b2551bcafeca6ff2aa88ba8ed0ed8de070841f0c4ef0165df8181eaad7f",
			"privateKey": "ea4f5bfe8694d8bb74b7b59404632fd5968b774ed545e810de9c32a4fb4192f4",
			"publicKey": "005ba3b9ac6e90e83effcd25ac4e58a1365a9e35a3d3ae5eb07b9e4d90bcf7506d"
		},
		{
			"seed": "fffcf9f6f3f0edeae7e4e1dedbd8d5d2cfccc9c6c3c0bdbab7b4b1aeaba8a5a29f9c999693908d8a8784817e7b7875726f6c696663605d5a5754514e4b484542",
			"path": "m/0'/2147483647'/1'",
			"fingerprint": "fcadf38c",
			"chainCode": "73bd9fff1cfbde33a1b846c27085f711c0fe2d66fd32e139d3ebc28e5a4a6b90",
			"privateKey": "3757c7577170179c7868353ada796c839135b3d30554bbb74a4b1e4a5a58505c",
			"publicKey": "002e66aa57069c86cc18249aecf5cb5a9cebbfd6fadeab056254763874a9352b45"
		},
		{
			"seed": "fffcf9f6f3f0edeae7e4e1dedbd8d5d2cfccc9c6c3c0bdbab7b4b1aeaba8a5a29f9c999693908d8a8784817e7b7875726f6c696663605d5a5754514e4b484542",
			"path": "m/0'/2147483647'/1'/2147483646'",
			"fingerprint": "aca70953",
			"chainCode": "0902fe8a29f9140480a00ef244bd183e8a13288e4412d8389d140aac1794825a",
			"privateKey": "5837736c89570de861ebc173b1086da4f505d4adb387c6a1b1342d5e4ac9ec72",
			"publicKey": "00e33c0f7d81d843c572275f287498e8d408654fdf0d1e065b84e2e6f157aab09b"
		},
		{
			"seed": "fffcf9f6f3f0edeae7e4e1dedbd8d5d2cfccc9c6c3c0bdbab7b4b1aeaba8a5a29f9c999693908d8a8784817e7b7875726f6c696663605d5a5754514e4b484542",
			"path": "m/0'/2147483647'/1'/2147483646'/2'",
			"fingerprint": "422c654b",
			"chainCode": "5d70af781f3a37b829f0d060924d5e960bdc02e85423494afc0b1a41bbe196d4",
			"privateKey": "551d333177df541ad876a60ea71f00447931c0a9da16f227c11ea080d7391b8d",
			"publicKey": "0047150c75db263559a70d5778bf36abbab30fb061ad69f69ece61a72b0cfa4fc0"
		}
	]
}

================
File: src/tests/fixtures/crypto/jwe.json
================
{
  "protected": "eyJlbmMiOiJYQzIwUCJ9",
  "recipients": [
    {
      "header": {
        "kid": "did:web:example.com#key-1",
        "alg": "ECDH-ES+A256KW",
        "epk": {
          "kty": "OKP",
          "crv": "X25519",
          "x": "cnH1NvXclLKcSzyRQRBHe6C1y-eDkwAcYwq-2OeI8Dc"
        },
        "apu": "cnH1NvXclLKcSzyRQRBHe6C1y-eDkwAcYwq-2OeI8Dc",
        "apv": "ZGlkOndlYjpleGFtcGxlLmNvbSNrZXktMQ"
      },
      "encrypted_key": "1MRE81TLjF5lbgVUfkYIC3on-ZqEq_gEHSxuIAMkbHtv-G55F_uy0w"
    }
  ],
  "iv": "MFiewXghyS2jQi8ydF_fSXAPWe92gQC3",
  "ciphertext": "gZdpPtuGuju9gAeHPnKHJjtcaRetfg",
  "tag": "3aPitcnoY5dNw3gCcb_Vsw"
}

================
File: src/tests/fixtures/crypto/jws.json
================
{
  "jws": "eyJiNjQiOmZhbHNlLCJjcml0IjpbImI2NCJdLCJhbGciOiJFUzI1NksifQ..JMlLTOtSOvAQCiKI_-X6c6LWIOvfqjZyhABWgZHrrewVcJHiRe-GZM0BohARUZghmVJpnhJey4NYyYy2dN7aPg"
}

================
File: src/tests/fixtures/crypto/mnemonic.json
================
{
	"english": [
		[
			"00000000000000000000000000000000",
			"abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about",
			"c55257c360c07c72029aebc1b53c05ed0362ada38ead3e3e9efa3708e53495531f09a6987599d18264c1e1c92f2cf141630c7a3c4ab7c81b2f001698e7463b04",
			"xprv9s21ZrQH143K3h3fDYiay8mocZ3afhfULfb5GX8kCBdno77K4HiA15Tg23wpbeF1pLfs1c5SPmYHrEpTuuRhxMwvKDwqdKiGJS9XFKzUsAF"
		],
		[
			"7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f",
			"legal winner thank year wave sausage worth useful legal winner thank yellow",
			"2e8905819b8723fe2c1d161860e5ee1830318dbf49a83bd451cfb8440c28bd6fa457fe1296106559a3c80937a1c1069be3a3a5bd381ee6260e8d9739fce1f607",
			"xprv9s21ZrQH143K2gA81bYFHqU68xz1cX2APaSq5tt6MFSLeXnCKV1RVUJt9FWNTbrrryem4ZckN8k4Ls1H6nwdvDTvnV7zEXs2HgPezuVccsq"
		],
		[
			"80808080808080808080808080808080",
			"letter advice cage absurd amount doctor acoustic avoid letter advice cage above",
			"d71de856f81a8acc65e6fc851a38d4d7ec216fd0796d0a6827a3ad6ed5511a30fa280f12eb2e47ed2ac03b5c462a0358d18d69fe4f985ec81778c1b370b652a8",
			"xprv9s21ZrQH143K2shfP28KM3nr5Ap1SXjz8gc2rAqqMEynmjt6o1qboCDpxckqXavCwdnYds6yBHZGKHv7ef2eTXy461PXUjBFQg6PrwY4Gzq"
		],
		[
			"ffffffffffffffffffffffffffffffff",
			"zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo wrong",
			"ac27495480225222079d7be181583751e86f571027b0497b5b5d11218e0a8a13332572917f0f8e5a589620c6f15b11c61dee327651a14c34e18231052e48c069",
			"xprv9s21ZrQH143K2V4oox4M8Zmhi2Fjx5XK4Lf7GKRvPSgydU3mjZuKGCTg7UPiBUD7ydVPvSLtg9hjp7MQTYsW67rZHAXeccqYqrsx8LcXnyd"
		],
		[
			"000000000000000000000000000000000000000000000000",
			"abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon agent",
			"035895f2f481b1b0f01fcf8c289c794660b289981a78f8106447707fdd9666ca06da5a9a565181599b79f53b844d8a71dd9f439c52a3d7b3e8a79c906ac845fa",
			"xprv9s21ZrQH143K3mEDrypcZ2usWqFgzKB6jBBx9B6GfC7fu26X6hPRzVjzkqkPvDqp6g5eypdk6cyhGnBngbjeHTe4LsuLG1cCmKJka5SMkmU"
		],
		[
			"7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f",
			"legal winner thank year wave sausage worth useful legal winner thank year wave sausage worth useful legal will",
			"f2b94508732bcbacbcc020faefecfc89feafa6649a5491b8c952cede496c214a0c7b3c392d168748f2d4a612bada0753b52a1c7ac53c1e93abd5c6320b9e95dd",
			"xprv9s21ZrQH143K3Lv9MZLj16np5GzLe7tDKQfVusBni7toqJGcnKRtHSxUwbKUyUWiwpK55g1DUSsw76TF1T93VT4gz4wt5RM23pkaQLnvBh7"
		],
		[
			"808080808080808080808080808080808080808080808080",
			"letter advice cage absurd amount doctor acoustic avoid letter advice cage absurd amount doctor acoustic avoid letter always",
			"107d7c02a5aa6f38c58083ff74f04c607c2d2c0ecc55501dadd72d025b751bc27fe913ffb796f841c49b1d33b610cf0e91d3aa239027f5e99fe4ce9e5088cd65",
			"xprv9s21ZrQH143K3VPCbxbUtpkh9pRG371UCLDz3BjceqP1jz7XZsQ5EnNkYAEkfeZp62cDNj13ZTEVG1TEro9sZ9grfRmcYWLBhCocViKEJae"
		],
		[
			"ffffffffffffffffffffffffffffffffffffffffffffffff",
			"zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo when",
			"0cd6e5d827bb62eb8fc1e262254223817fd068a74b5b449cc2f667c3f1f985a76379b43348d952e2265b4cd129090758b3e3c2c49103b5051aac2eaeb890a528",
			"xprv9s21ZrQH143K36Ao5jHRVhFGDbLP6FCx8BEEmpru77ef3bmA928BxsqvVM27WnvvyfWywiFN8K6yToqMaGYfzS6Db1EHAXT5TuyCLBXUfdm"
		],
		[
			"0000000000000000000000000000000000000000000000000000000000000000",
			"abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon art",
			"bda85446c68413707090a52022edd26a1c9462295029f2e60cd7c4f2bbd3097170af7a4d73245cafa9c3cca8d561a7c3de6f5d4a10be8ed2a5e608d68f92fcc8",
			"xprv9s21ZrQH143K32qBagUJAMU2LsHg3ka7jqMcV98Y7gVeVyNStwYS3U7yVVoDZ4btbRNf4h6ibWpY22iRmXq35qgLs79f312g2kj5539ebPM"
		],
		[
			"7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f",
			"legal winner thank year wave sausage worth useful legal winner thank year wave sausage worth useful legal winner thank year wave sausage worth title",
			"bc09fca1804f7e69da93c2f2028eb238c227f2e9dda30cd63699232578480a4021b146ad717fbb7e451ce9eb835f43620bf5c514db0f8add49f5d121449d3e87",
			"xprv9s21ZrQH143K3Y1sd2XVu9wtqxJRvybCfAetjUrMMco6r3v9qZTBeXiBZkS8JxWbcGJZyio8TrZtm6pkbzG8SYt1sxwNLh3Wx7to5pgiVFU"
		],
		[
			"8080808080808080808080808080808080808080808080808080808080808080",
			"letter advice cage absurd amount doctor acoustic avoid letter advice cage absurd amount doctor acoustic avoid letter advice cage absurd amount doctor acoustic bless",
			"c0c519bd0e91a2ed54357d9d1ebef6f5af218a153624cf4f2da911a0ed8f7a09e2ef61af0aca007096df430022f7a2b6fb91661a9589097069720d015e4e982f",
			"xprv9s21ZrQH143K3CSnQNYC3MqAAqHwxeTLhDbhF43A4ss4ciWNmCY9zQGvAKUSqVUf2vPHBTSE1rB2pg4avopqSiLVzXEU8KziNnVPauTqLRo"
		],
		[
			"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
			"zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo vote",
			"dd48c104698c30cfe2b6142103248622fb7bb0ff692eebb00089b32d22484e1613912f0a5b694407be899ffd31ed3992c456cdf60f5d4564b8ba3f05a69890ad",
			"xprv9s21ZrQH143K2WFF16X85T2QCpndrGwx6GueB72Zf3AHwHJaknRXNF37ZmDrtHrrLSHvbuRejXcnYxoZKvRquTPyp2JiNG3XcjQyzSEgqCB"
		],
		[
			"9e885d952ad362caeb4efe34a8e91bd2",
			"ozone drill grab fiber curtain grace pudding thank cruise elder eight picnic",
			"274ddc525802f7c828d8ef7ddbcdc5304e87ac3535913611fbbfa986d0c9e5476c91689f9c8a54fd55bd38606aa6a8595ad213d4c9c9f9aca3fb217069a41028",
			"xprv9s21ZrQH143K2oZ9stBYpoaZ2ktHj7jLz7iMqpgg1En8kKFTXJHsjxry1JbKH19YrDTicVwKPehFKTbmaxgVEc5TpHdS1aYhB2s9aFJBeJH"
		],
		[
			"6610b25967cdcca9d59875f5cb50b0ea75433311869e930b",
			"gravity machine north sort system female filter attitude volume fold club stay feature office ecology stable narrow fog",
			"628c3827a8823298ee685db84f55caa34b5cc195a778e52d45f59bcf75aba68e4d7590e101dc414bc1bbd5737666fbbef35d1f1903953b66624f910feef245ac",
			"xprv9s21ZrQH143K3uT8eQowUjsxrmsA9YUuQQK1RLqFufzybxD6DH6gPY7NjJ5G3EPHjsWDrs9iivSbmvjc9DQJbJGatfa9pv4MZ3wjr8qWPAK"
		],
		[
			"68a79eaca2324873eacc50cb9c6eca8cc68ea5d936f98787c60c7ebc74e6ce7c",
			"hamster diagram private dutch cause delay private meat slide toddler razor book happy fancy gospel tennis maple dilemma loan word shrug inflict delay length",
			"64c87cde7e12ecf6704ab95bb1408bef047c22db4cc7491c4271d170a1b213d20b385bc1588d9c7b38f1b39d415665b8a9030c9ec653d75e65f847d8fc1fc440",
			"xprv9s21ZrQH143K2XTAhys3pMNcGn261Fi5Ta2Pw8PwaVPhg3D8DWkzWQwjTJfskj8ofb81i9NP2cUNKxwjueJHHMQAnxtivTA75uUFqPFeWzk"
		],
		[
			"c0ba5a8e914111210f2bd131f3d5e08d",
			"scheme spot photo card baby mountain device kick cradle pact join borrow",
			"ea725895aaae8d4c1cf682c1bfd2d358d52ed9f0f0591131b559e2724bb234fca05aa9c02c57407e04ee9dc3b454aa63fbff483a8b11de949624b9f1831a9612",
			"xprv9s21ZrQH143K3FperxDp8vFsFycKCRcJGAFmcV7umQmcnMZaLtZRt13QJDsoS5F6oYT6BB4sS6zmTmyQAEkJKxJ7yByDNtRe5asP2jFGhT6"
		],
		[
			"6d9be1ee6ebd27a258115aad99b7317b9c8d28b6d76431c3",
			"horn tenant knee talent sponsor spell gate clip pulse soap slush warm silver nephew swap uncle crack brave",
			"fd579828af3da1d32544ce4db5c73d53fc8acc4ddb1e3b251a31179cdb71e853c56d2fcb11aed39898ce6c34b10b5382772db8796e52837b54468aeb312cfc3d",
			"xprv9s21ZrQH143K3R1SfVZZLtVbXEB9ryVxmVtVMsMwmEyEvgXN6Q84LKkLRmf4ST6QrLeBm3jQsb9gx1uo23TS7vo3vAkZGZz71uuLCcywUkt"
		],
		[
			"9f6a2878b2520799a44ef18bc7df394e7061a224d2c33cd015b157d746869863",
			"panda eyebrow bullet gorilla call smoke muffin taste mesh discover soft ostrich alcohol speed nation flash devote level hobby quick inner drive ghost inside",
			"72be8e052fc4919d2adf28d5306b5474b0069df35b02303de8c1729c9538dbb6fc2d731d5f832193cd9fb6aeecbc469594a70e3dd50811b5067f3b88b28c3e8d",
			"xprv9s21ZrQH143K2WNnKmssvZYM96VAr47iHUQUTUyUXH3sAGNjhJANddnhw3i3y3pBbRAVk5M5qUGFr4rHbEWwXgX4qrvrceifCYQJbbFDems"
		],
		[
			"23db8160a31d3e0dca3688ed941adbf3",
			"cat swing flag economy stadium alone churn speed unique patch report train",
			"deb5f45449e615feff5640f2e49f933ff51895de3b4381832b3139941c57b59205a42480c52175b6efcffaa58a2503887c1e8b363a707256bdd2b587b46541f5",
			"xprv9s21ZrQH143K4G28omGMogEoYgDQuigBo8AFHAGDaJdqQ99QKMQ5J6fYTMfANTJy6xBmhvsNZ1CJzRZ64PWbnTFUn6CDV2FxoMDLXdk95DQ"
		],
		[
			"8197a4a47f0425faeaa69deebc05ca29c0a5b5cc76ceacc0",
			"light rule cinnamon wrap drastic word pride squirrel upgrade then income fatal apart sustain crack supply proud access",
			"4cbdff1ca2db800fd61cae72a57475fdc6bab03e441fd63f96dabd1f183ef5b782925f00105f318309a7e9c3ea6967c7801e46c8a58082674c860a37b93eda02",
			"xprv9s21ZrQH143K3wtsvY8L2aZyxkiWULZH4vyQE5XkHTXkmx8gHo6RUEfH3Jyr6NwkJhvano7Xb2o6UqFKWHVo5scE31SGDCAUsgVhiUuUDyh"
		],
		[
			"066dca1a2bb7e8a1db2832148ce9933eea0f3ac9548d793112d9a95c9407efad",
			"all hour make first leader extend hole alien behind guard gospel lava path output census museum junior mass reopen famous sing advance salt reform",
			"26e975ec644423f4a4c4f4215ef09b4bd7ef924e85d1d17c4cf3f136c2863cf6df0a475045652c57eb5fb41513ca2a2d67722b77e954b4b3fc11f7590449191d",
			"xprv9s21ZrQH143K3rEfqSM4QZRVmiMuSWY9wugscmaCjYja3SbUD3KPEB1a7QXJoajyR2T1SiXU7rFVRXMV9XdYVSZe7JoUXdP4SRHTxsT1nzm"
		],
		[
			"f30f8c1da665478f49b001d94c5fc452",
			"vessel ladder alter error federal sibling chat ability sun glass valve picture",
			"2aaa9242daafcee6aa9d7269f17d4efe271e1b9a529178d7dc139cd18747090bf9d60295d0ce74309a78852a9caadf0af48aae1c6253839624076224374bc63f",
			"xprv9s21ZrQH143K2QWV9Wn8Vvs6jbqfF1YbTCdURQW9dLFKDovpKaKrqS3SEWsXCu6ZNky9PSAENg6c9AQYHcg4PjopRGGKmdD313ZHszymnps"
		],
		[
			"c10ec20dc3cd9f652c7fac2f1230f7a3c828389a14392f05",
			"scissors invite lock maple supreme raw rapid void congress muscle digital elegant little brisk hair mango congress clump",
			"7b4a10be9d98e6cba265566db7f136718e1398c71cb581e1b2f464cac1ceedf4f3e274dc270003c670ad8d02c4558b2f8e39edea2775c9e232c7cb798b069e88",
			"xprv9s21ZrQH143K4aERa2bq7559eMCCEs2QmmqVjUuzfy5eAeDX4mqZffkYwpzGQRE2YEEeLVRoH4CSHxianrFaVnMN2RYaPUZJhJx8S5j6puX"
		],
		[
			"f585c11aec520db57dd353c69554b21a89b20fb0650966fa0a9d6f74fd989d8f",
			"void come effort suffer camp survey warrior heavy shoot primary clutch crush open amazing screen patrol group space point ten exist slush involve unfold",
			"01f5bced59dec48e362f2c45b5de68b9fd6c92c6634f44d6d40aab69056506f0e35524a518034ddc1192e1dacd32c1ed3eaa3c3b131c88ed8e7e54c49a5d0998",
			"xprv9s21ZrQH143K39rnQJknpH1WEPFJrzmAqqasiDcVrNuk926oizzJDDQkdiTvNPr2FYDYzWgiMiC63YmfPAa2oPyNB23r2g7d1yiK6WpqaQS"
		]
	]
}

================
File: src/tests/fixtures/crypto/plaintext.json
================
{
  "body": "hello world"
}

================
File: src/tests/fixtures/keypairs/case-2.json
================
{
	"id": "did:key:z6MkhE7zSTFdUbBDjfzX4zYV1DPMG8QPd5S723xdAyUF3rgR#z6MkhE7zSTFdUbBDjfzX4zYV1DPMG8QPd5S723xdAyUF3rgR",
	"type": "Ed25519VerificationKey2020",
	"controller": "did:key:z6MkhE7zSTFdUbBDjfzX4zYV1DPMG8QPd5S723xdAyUF3rgR",
	"publicKeyMultibase": "z6MkhE7zSTFdUbBDjfzX4zYV1DPMG8QPd5S723xdAyUF3rgR"
}

================
File: src/tests/fixtures/keypairs/EcdsaSecp256k1VerificationKey2019.json
================
{
  "id": "did:key:zQ3shVCkb7inzoon2xbs7ZJbeMPwSiv8DrNAqX169uHDuUFTM#zQ3shVCkb7inzoon2xbs7ZJbeMPwSiv8DrNAqX169uHDuUFTM",
  "type": "EcdsaSecp256k1VerificationKey2019",
  "controller": "did:key:zQ3shVCkb7inzoon2xbs7ZJbeMPwSiv8DrNAqX169uHDuUFTM",
  "publicKeyBase58": "jFbaGaKXVAZ9iWBhBDibXoa159wFZp8Jb5LMbwYnFmbd",
  "privateKeyBase58": "4sse87M91Z3XBvxuAd9TSnHNvf69at8mHRQYwbXGVyCg"
}

================
File: src/tests/fixtures/keypairs/Ed25519VerificationKey2018.json
================
{
	"id": "did:key:z6Mkoeab4xjDUGuEmBshPh3vQxsZhTiinVU83xM9UJYSsFi4#z6Mkoeab4xjDUGuEmBshPh3vQxsZhTiinVU83xM9UJYSsFi4",
	"type": "Ed25519VerificationKey2018",
	"controller": "did:key:z6Mkoeab4xjDUGuEmBshPh3vQxsZhTiinVU83xM9UJYSsFi4",
	"publicKeyBase58": "ACKYUiUn8jQmeh2zi865ZsKZstSsNcDmMwSDe2aRx2vg",
	"privateKeyBase58": "4jSWjHAYBxgaio2oC7USLPJ9aeGMBdp9jdNzAX3vn2zu5v2d6YSHgDUoZxpxK4S77qxRhNHd6V1xzNQjAStwSUvG"
}

================
File: src/tests/fixtures/keypairs/Ed25519VerificationKey2020.json
================
{
	"id": "did:key:z6MknCCLeeHBUaHu4aHSVLDCYQW9gjVJ7a63FpMvtuVMy53T#z6MknCCLeeHBUaHu4aHSVLDCYQW9gjVJ7a63FpMvtuVMy53T",
	"type": "Ed25519VerificationKey2020",
	"controller": "did:key:z6MknCCLeeHBUaHu4aHSVLDCYQW9gjVJ7a63FpMvtuVMy53T",
	"publicKeyMultibase": "z6MknCCLeeHBUaHu4aHSVLDCYQW9gjVJ7a63FpMvtuVMy53T",
	"privateKeyMultibase": "zrv2EET2WWZ8T1Jbg4fEH5cQxhbUS22XxdweypUbjWVzv1YD6VqYuW6LH7heQCNYQCuoKaDwvv2qCWz3uBzG2xesqmf"
}

================
File: src/tests/fixtures/keypairs/JsonWebKey2020.json
================
{
  "id": "did:example:123#key-1",
  "type": "JsonWebKey2020",
  "controller": "did:example:123",
  "publicKeyJwk": {
    "kty": "EC",
    "crv": "secp256k1",
    "x": "BuzCc8bUShI3GfVz-WLISZDGq7wnVB4h_nvNQcWn7Jw",
    "y": "dLrbspB9PZvZF0dr42nCmF38192dQKglvB52IZBM-vs"
  },
  "privateKeyJwk": {
    "kty": "EC",
    "crv": "secp256k1",
    "x": "BuzCc8bUShI3GfVz-WLISZDGq7wnVB4h_nvNQcWn7Jw",
    "y": "dLrbspB9PZvZF0dr42nCmF38192dQKglvB52IZBM-vs",
    "d": "ts22WN9V4DHvonMysnyhdkOBwX9bVCusl1GXImD9Pic"
  }
}

================
File: src/tests/fixtures/keypairs/X25519KeyAgreementKey2019.json
================
{
  "id": "did:web:example.com#key-1",
  "type": "X25519KeyAgreementKey2019",
  "publicKeyBase58": "3zSE11h82KtPYPj8p9cTgzr6yDWFYEsfM19xc1K5vjKY",
  "privateKeyBase58": "66pGmEHd7fBfQa9ap27vWSouHAmipbmmw6GduBwNRY6y"
}

================
File: src/tests/fixtures/keypairs/X25519KeyAgreementKey2020.json
================
{
	"id": "did:example:1234#z6LSeRSE5Em5oJpwdk3NBaLVERBS332ULC7EQq5EtMsmXhsM",
	"controller": "did:example:1234",
	"type": "X25519KeyAgreementKey2020",
	"publicKeyMultibase": "z6LSeRSE5Em5oJpwdk3NBaLVERBS332ULC7EQq5EtMsmXhsM",
	"privateKeyMultibase": "z3weeMD56C1T347EmB6kYNS7trpQwjvtQCpCYRpqGz6mcemT"
}

================
File: src/tests/fixtures/presentations/case-10.json
================
{
  "@context": ["https://www.w3.org/2018/credentials/v1"],
  "type": ["VerifiablePresentation"],
  "verifiableCredential": [
    {
      "@context": [
        "https://www.w3.org/2018/credentials/v1",
        "https://w3id.org/vaccination/v1"
      ],
      "type": ["VerifiableCredential", "VaccinationCertificate"],
      "id": "urn:uvci:af5vshde843jf831j128fj",
      "name": "COVID-19 Vaccination Certificate",
      "description": "COVID-19 Vaccination Certificate",
      "issuanceDate": "2019-12-03T12:19:52Z",
      "expirationDate": "2029-12-03T12:19:52Z",
      "issuer": "did:key:z6MkiY62766b1LJkExWMsM3QG4WtX7QpY823dxoYzr9qZvJ3",
      "credentialSubject": {
        "id": "did:example:123",
        "type": "VaccinationEvent",
        "batchNumber": "1183738569",
        "administeringCentre": "MoH",
        "healthProfessional": "MoH",
        "countryOfVaccination": "NZ",
        "recipient": {
          "type": "VaccineRecipient",
          "givenName": "JOHN",
          "familyName": "SMITH",
          "gender": "Male",
          "birthDate": "1958-07-17"
        },
        "vaccine": {
          "type": "Vaccine",
          "disease": "COVID-19",
          "atcCode": "J07BX03",
          "medicinalProductName": "COVID-19 Vaccine Moderna",
          "marketingAuthorizationHolder": "Moderna Biotech"
        }
      },
      "proof": {
        "type": "JsonWebSignature2020",
        "proofPurpose": "assertionMethod",
        "created": "2021-11-26T05:19:33Z",
        "verificationMethod": "did:example:123#key-1",
        "jws": "eyJiNjQiOmZhbHNlLCJjcml0IjpbImI2NCJdLCJhbGciOiJFUzI1NksifQ..qckXOnj8LXFGqqknJJ6DLBq3289x7IBH1H-ERtwJb4bSLCqtJJNA0Xrxz4rti6QYk-cSCwFSAlTK9hjDQvNCnQ"
      }
    }
  ]
}

================
File: src/tests/fixtures/verifiableCredentials/case-10.json
================
{
  "@context": [
    "https://www.w3.org/2018/credentials/v1",
    "https://w3id.org/vaccination/v1"
  ],
  "type": ["VerifiableCredential", "VaccinationCertificate"],
  "id": "urn:uvci:af5vshde843jf831j128fj",
  "name": "COVID-19 Vaccination Certificate",
  "description": "COVID-19 Vaccination Certificate",
  "issuanceDate": "2019-12-03T12:19:52Z",
  "expirationDate": "2029-12-03T12:19:52Z",
  "issuer": "did:key:z6MkiY62766b1LJkExWMsM3QG4WtX7QpY823dxoYzr9qZvJ3",
  "credentialSubject": {
    "id": "did:example:123",
    "type": "VaccinationEvent",
    "batchNumber": "1183738569",
    "administeringCentre": "MoH",
    "healthProfessional": "MoH",
    "countryOfVaccination": "NZ",
    "recipient": {
      "type": "VaccineRecipient",
      "givenName": "JOHN",
      "familyName": "SMITH",
      "gender": "Male",
      "birthDate": "1958-07-17"
    },
    "vaccine": {
      "type": "Vaccine",
      "disease": "COVID-19",
      "atcCode": "J07BX03",
      "medicinalProductName": "COVID-19 Vaccine Moderna",
      "marketingAuthorizationHolder": "Moderna Biotech"
    }
  },
  "proof": {
    "type": "JsonWebSignature2020",
    "proofPurpose": "assertionMethod",
    "created": "2021-11-26T05:19:33Z",
    "verificationMethod": "did:example:123#key-1",
    "jws": "eyJiNjQiOmZhbHNlLCJjcml0IjpbImI2NCJdLCJhbGciOiJFUzI1NksifQ..qckXOnj8LXFGqqknJJ6DLBq3289x7IBH1H-ERtwJb4bSLCqtJJNA0Xrxz4rti6QYk-cSCwFSAlTK9hjDQvNCnQ"
  }
}

================
File: src/tests/fixtures/verifiablePresentations/case-10.json
================
{
  "@context": ["https://www.w3.org/2018/credentials/v1"],
  "type": ["VerifiablePresentation"],
  "verifiableCredential": [
    {
      "@context": [
        "https://www.w3.org/2018/credentials/v1",
        "https://w3id.org/vaccination/v1"
      ],
      "type": ["VerifiableCredential", "VaccinationCertificate"],
      "id": "urn:uvci:af5vshde843jf831j128fj",
      "name": "COVID-19 Vaccination Certificate",
      "description": "COVID-19 Vaccination Certificate",
      "issuanceDate": "2019-12-03T12:19:52Z",
      "expirationDate": "2029-12-03T12:19:52Z",
      "issuer": "did:key:z6MkiY62766b1LJkExWMsM3QG4WtX7QpY823dxoYzr9qZvJ3",
      "credentialSubject": {
        "id": "did:example:123",
        "type": "VaccinationEvent",
        "batchNumber": "1183738569",
        "administeringCentre": "MoH",
        "healthProfessional": "MoH",
        "countryOfVaccination": "NZ",
        "recipient": {
          "type": "VaccineRecipient",
          "givenName": "JOHN",
          "familyName": "SMITH",
          "gender": "Male",
          "birthDate": "1958-07-17"
        },
        "vaccine": {
          "type": "Vaccine",
          "disease": "COVID-19",
          "atcCode": "J07BX03",
          "medicinalProductName": "COVID-19 Vaccine Moderna",
          "marketingAuthorizationHolder": "Moderna Biotech"
        }
      },
      "proof": {
        "type": "JsonWebSignature2020",
        "proofPurpose": "assertionMethod",
        "created": "2021-11-26T05:19:33Z",
        "verificationMethod": "did:example:123#key-1",
        "jws": "eyJiNjQiOmZhbHNlLCJjcml0IjpbImI2NCJdLCJhbGciOiJFUzI1NksifQ..qckXOnj8LXFGqqknJJ6DLBq3289x7IBH1H-ERtwJb4bSLCqtJJNA0Xrxz4rti6QYk-cSCwFSAlTK9hjDQvNCnQ"
      }
    }
  ],
  "proof": {
    "type": "JsonWebSignature2020",
    "proofPurpose": "authentication",
    "created": "2021-11-26T19:09:31Z",
    "challenge": "1235",
    "domain": "1",
    "verificationMethod": "did:example:123#key-1",
    "jws": "eyJiNjQiOmZhbHNlLCJjcml0IjpbImI2NCJdLCJhbGciOiJFUzI1NksifQ..WKXXWKjLAuCZxpBg71cAeSc89QhlZs9oIG_pURgkkarVLyjZf3P21N0RHi0wsdPs5QhLsgLh0tehZSN8SRx9qQ"
  }
}

================
File: src/tests/mocks/MockSignatureSuite.ts
================
import type { DocumentLoader, JWTCredential, LinkedDataSuite, ProofVerificationResult } from "../../lib/crypto";


export class MockSignatureSuite implements LinkedDataSuite {
	type = 'mock';
	date = new Date().toISOString();
	context = 'mock';

	async getVerificationMethod() {
		return null;
	}

	async createProof(
		credential: Credential | JWTCredential,
		purpose: string,
		documentLoader: DocumentLoader
	): Promise<any> {
		return {};
	}

	async verifyProof(
		proofDocument: any,
		document: any,
		documentLoader: DocumentLoader
	): Promise<ProofVerificationResult> {
		return { verified: true };
	}
}

================
File: src/tests/unit/crypto/Ed25519VerificationKey2018.test.ts
================
import { Ed25519VerificationKey2018 } from '../../../lib/crypto/keypairs/Ed25519VerificationKey2018';
import { base58, base64url } from '../../../lib/crypto/utils/encoding';
import { describe, expect, it } from 'bun:test';
import { documentLoader } from '../../fixtures/crypto/documentLoader';

describe('Ed25519VerificationKey2018', () => {
	it('resolves as JWK', async () => {
		const ed25519 = require('../../fixtures/keypairs/Ed25519VerificationKey2018.json');

		const key = new Ed25519VerificationKey2018(
			ed25519.id,
			ed25519.controller,
			ed25519.publicKeyBase58,
			ed25519.privateKeyBase58
		);

		const jwk = await key.export({ privateKey: true, type: 'JsonWebKey2020' });
		expect(jwk.privateKeyJwk!.crv).toBe('Ed25519');
		expect(jwk.privateKeyJwk!.kty).toBe('OKP');
		expect(jwk.privateKeyJwk!.x).toBe(base64url.encode(base58.decode(ed25519.publicKeyBase58)));
		expect(jwk.privateKeyJwk!.d).toBe(base64url.encode(base58.decode(ed25519.privateKeyBase58)));
	});

	it('w/o private key resolves as JWK', async () => {
		const ed25519 = require('../../fixtures/keypairs/Ed25519VerificationKey2018.json');
		const { privateKeyBase58, ...newKey } = ed25519

		const key = new Ed25519VerificationKey2018(
			newKey.id,
			newKey.controller,
			newKey.publicKeyBase58,
			newKey.privateKeyBase58
		);

		const jwk = await key.export({ privateKey: true, type: 'JsonWebKey2020' });
		expect(jwk.publicKeyJwk!.crv).toBe('Ed25519');
		expect(jwk.publicKeyJwk!.kty).toBe('OKP');
		expect(jwk.publicKeyJwk!.x).toBe(base64url.encode(base58.decode(ed25519.publicKeyBase58)));
	});

	it(`Can create proof w/ challenge`, async () => {
		const credential = require(`../../fixtures/credentials/case-1.json`);
		const ed25519 = require('../../fixtures/keypairs/Ed25519VerificationKey2018.json');
		const key = new Ed25519VerificationKey2018(
			ed25519.id,
			ed25519.controller,
			ed25519.publicKeyBase58,
			ed25519.privateKeyBase58
		);

		const result = await key.createProof(
			credential,
			'assertionMethod',
			documentLoader,
			{challenge: 'challenge123'}
		);

		expect(result.challenge).toBe('challenge123');
		expect(result.domain).toBeUndefined();
		expect(result.jws).toBeDefined();
	});
});

================
File: src/tests/unit/crypto/Ed25519VerificationKey2020.test.ts
================
import * as vc from '@digitalbazaar/vc';

import { MULTICODEC_ED25519_PRIV_HEADER, MULTICODEC_ED25519_PUB_HEADER, base64url, multibase } from '../../../lib/crypto/utils/encoding';
import { describe, expect, it } from 'bun:test';

import { HDKey } from 'micro-ed25519-hdkey';
import { Ed25519VerificationKey2020 as dbKey } from '@digitalbazaar/ed25519-verification-key-2020';
import { Ed25519Signature2020 as dbSuite } from '@digitalbazaar/ed25519-signature-2020';
import { documentLoader } from '../../fixtures/crypto/documentLoader';
import { Ed25519VerificationKey2020 } from '../../../lib/crypto';

describe('Ed25519VerificationKey2020', () => {
	it('fromBase58', async () => {
		const key = 'ByHnpUCFb1vAfh9CFZ8ZkmUZguURW8nSw889hy6rD8L7';
		const keypair = Ed25519VerificationKey2020.fromBase58({ publicKeyBase58: key })
	})
	it('resolves as JWK', async () => {
		const ed25519 = require('../../fixtures/keypairs/Ed25519VerificationKey2020.json');

		const key = new Ed25519VerificationKey2020(
			ed25519.id,
			ed25519.controller,
			ed25519.publicKeyMultibase,
			ed25519.privateKeyMultibase
		);

		const jwk = await key.export({ privateKey: true, type: 'JsonWebKey2020' });
		expect(jwk.privateKeyJwk!.crv).toBe('Ed25519');
		expect(jwk.privateKeyJwk!.kty).toBe('OKP');
		expect(jwk.privateKeyJwk!.x).toBe(base64url.encode(multibase.decode(MULTICODEC_ED25519_PUB_HEADER, ed25519.publicKeyMultibase)));
		expect(jwk.privateKeyJwk!.d).toBe(base64url.encode(multibase.decode(MULTICODEC_ED25519_PRIV_HEADER, ed25519.privateKeyMultibase)));
	});

	it('w/o private key resolves as JWK', async () => {
		const ed25519 = require('../../fixtures/keypairs/Ed25519VerificationKey2020.json');
		const { privateKeyMultibase, ...newKey } = ed25519;

		const key = new Ed25519VerificationKey2020(
			newKey.id,
			newKey.controller,
			newKey.publicKeyMultibase,
			newKey.privateKeyMultibase
		);

		const jwk = await key.export({ privateKey: true, type: 'JsonWebKey2020' });
		expect(jwk.publicKeyJwk.crv).toEqual('Ed25519');
		expect(jwk.publicKeyJwk.kty).toEqual('OKP');
	});

	it('can generate', async () => {
		const key = await Ed25519VerificationKey2020.generate()
		expect(key.publicKey.length).toEqual(32)
		expect(key).toHaveProperty('publicKey')
		expect(key).toHaveProperty('privateKey')
	})

	it('can create from hd key', async () => {
		const hd = HDKey.fromMasterSeed('fffcf9f6f3f0edeae7e4e1dedbd8d5d2cfccc9c6c3c0bdbab7b4b1aeaba8a5a29f9c999693908d8a8784817e7b7875726f6c696663605d5a5754514e4b484542')
		// const key = Ed25519VerificationKey2020.fromHD(hd)
		// expect(key.publicKey.length).toEqual(32)
		// expect(key.privateKey!.length).toEqual(64)
		// expect(key.controller).toEqual('did:key:z6Mkp92myXtWkQYxhFmDxqkTwURYZAEjUm9iAuZxyjYzmfSy')
	})

	it('can create valid proof from hd key', async () => {
		const hd = HDKey.fromMasterSeed('fffcf9f6f3f0edeae7e4e1dedbd8d5d2cfccc9c6c3c0bdbab7b4b1aeaba8a5a29f9c999693908d8a8784817e7b7875726f6c696663605d5a5754514e4b484542')
		const credential = require(`../../fixtures/credentials/case-1.json`);
		// const key = Ed25519VerificationKey2020.fromHD(hd)
		// expect(key.publicKey.length).toEqual(32)
		// expect(key.privateKey!.length).toEqual(64)
		// expect(key.controller).toEqual('did:key:z6Mkp92myXtWkQYxhFmDxqkTwURYZAEjUm9iAuZxyjYzmfSy')
		// const result = await key.createProof(
		// 	credential,
		// 	'assertionMethod',
		// 	documentLoader,
		// 	{ challenge: 'challenge123' }
		// );
		// const verification = await key.verifyProof(result, credential, documentLoader)
		// expect(verification.verified).toBeTruthy()
	})


	it(`Can create proof w/ challenge`, async () => {
		const credential = require(`../../fixtures/credentials/case-1.json`);
		const ed25519 = require('../../fixtures/keypairs/Ed25519VerificationKey2020.json');
		const key = new Ed25519VerificationKey2020(
			ed25519.id,
			ed25519.controller,
			ed25519.publicKeyMultibase,
			ed25519.privateKeyMultibase
		);

		const result = await key.createProof(
			credential,
			'assertionMethod',
			documentLoader,
			{ challenge: 'challenge123' }
		);

		expect(result.challenge).toBe('challenge123');
		expect(result.domain).toBeUndefined();
		expect(result).toHaveProperty('proofValue')
	});

	it(`Can verify proof case-1`, async () => {
		const credential = require(`../../fixtures/credentials/case-1.json`);
		const ed25519 = require('../../fixtures/keypairs/Ed25519VerificationKey2020.json');
		const key = new Ed25519VerificationKey2020(
			ed25519.id,
			ed25519.controller,
			ed25519.publicKeyMultibase,
			ed25519.privateKeyMultibase
		);

		const proof = await key.createProof(
			credential,
			'assertionMethod',
			documentLoader,
			{ challenge: 'challenge123' }
		);

		const result = await key.verifyProof(proof, credential, documentLoader)
		expect(result.verified).toBeTruthy()
	});

	it(`debug`, async () => {
		const ed25519 = require('../../fixtures/keypairs/Ed25519VerificationKey2020.json');
		const key = new Ed25519VerificationKey2020(
			ed25519.id,
			ed25519.controller,
			ed25519.publicKeyMultibase,
			ed25519.privateKeyMultibase
		);
		const p = {
			'@context': [
				'https://www.w3.org/2018/credentials/v1',
				"https://w3id.org/security/suites/ed25519-2020/v1"
			],
			holder: key.controller,
			type: ['VerifiablePresentation'],
			verifiableCredential: []
		};
		let proof = await key.createProof(p, 'authentication', documentLoader, { challenge: '72Jd0frtFmvKjQV65BFz4', domain: 'https://localhost:51433' })
		expect(proof.challenge).toBe('72Jd0frtFmvKjQV65BFz4')
		let verify = await key.verifyProof(proof, p, documentLoader)
		expect(verify.verified).toBeTruthy()
		// {
		// 	type: 'vc-ld',
		// 	suite: key,
		// 	challenge: 'challenge',
		// 	domain: 'domain',
		// 	documentLoader
		// });
	})

	it(`Can create proof that verifies with digital bazaar`, async () => {
		const ed25519 = { ...require('../../fixtures/keypairs/Ed25519VerificationKey2020.json') };
		const credential = { ...require(`../../fixtures/credentials/case-1.json`), issuer: { id: ed25519.controller } };
		const key = new Ed25519VerificationKey2020(
			ed25519.id,
			ed25519.controller,
			ed25519.publicKeyMultibase,
			ed25519.privateKeyMultibase
		);

		const result = await key.createProof(
			credential,
			'assertionMethod',
			documentLoader,
			{ challenge: 'challenge123', domain: 'http://domain.com' }
		);

		expect(result.challenge).toBe('challenge123');
		expect(result.domain).toBe('http://domain.com');
		expect(result).toHaveProperty('proofValue');
		const keyPair = new dbKey({
			id: ed25519.id,
			controller: ed25519.controller,
			publicKeyMultibase: ed25519.publicKeyMultibase,
		});
		const suite = new dbSuite({ key: keyPair });
		const res = await vc.verifyCredential({
			credential: { ...credential, proof: result },
			challenge: 'challenge123',
			domain: 'http://domain.com',
			suite,
			documentLoader
		});
		expect(res.verified).toBeTruthy()
	});
});

================
File: src/tests/unit/crypto/HD.test.ts
================
import { deriveKeyAtPathFromMaster, seedToHD } from "../../../lib/crypto/keypairs/HD";
import { describe, expect, it } from "bun:test";
import hdFixtures from '../../fixtures/crypto/HD.json';
import { mnemonicToSeed } from "../../../lib/crypto/mnemonic";
import { MULTICODEC_SECP256K1_PUB_HEADER, multibase } from "../../../lib/crypto";

describe('HD tests', () => {
  let i = 0;
  for (const vector of hdFixtures.secp256k1) {
    it(`${i}: can convert hex seed (${vector[0].slice(0, 12)}...) to xpriv (${vector[2].slice(0, 12)}...) with path ${vector[1]}`, () => {
        const key = seedToHD(vector[0])
        const derived = deriveKeyAtPathFromMaster(key, vector[1])
        expect(derived.privateExtendedKey).toBe(vector[2])
    })
    i++
  }
})

================
File: src/tests/unit/crypto/JsonWebKey2020.test.ts
================
import { describe, expect, it, beforeAll } from 'bun:test';
import { JsonWebKeyPair } from '../../../lib/crypto';

let jwk2020: any;

describe('JsonWebKey2020', () => {
	beforeAll(() => {
		jwk2020 = require('../../fixtures/keypairs/JsonWebKey2020.json');
	})
	it('resolves as JWK', async () => {
		const jwk = new JsonWebKeyPair(
			jwk2020.id,
			jwk2020.controller,
			jwk2020.publicKeyJwk,
			jwk2020.privateKeyJwk
		);

		expect(jwk.id).toBe(jwk2020.id);
		expect(jwk.controller).toBe(jwk2020.controller);
		expect(jwk.publicKeyJwk).toBe(jwk2020.publicKeyJwk);
		expect(jwk.privateKeyJwk).toBe(jwk2020.privateKeyJwk);
	});

	it('w/o private key resolves as JWK', async () => {
		const { privateKeyJwk, ...newjwk } = jwk2020;

		const jwk = new JsonWebKeyPair(
			newjwk.id,
			newjwk.controller,
			newjwk.publicKeyJwk,
			newjwk.privateKeyJwk
		);

		expect(jwk.id).toBe(newjwk.id);
		expect(jwk.controller).toBe(newjwk.controller);
		expect(jwk.publicKeyJwk).toBe(newjwk.publicKeyJwk);
		expect(jwk.privateKeyJwk).toBe(newjwk.privateKeyJwk);
	});

	it('exports as LD', async () => {
		const jwk = new JsonWebKeyPair(
			jwk2020.id,
			jwk2020.controller,
			jwk2020.publicKeyJwk,
			jwk2020.privateKeyJwk
		);

		const keypair = await jwk.exportAsLD({
			privateKey: true
		});

		expect(keypair.type).toBe('Multikey');
		expect(keypair.id).toBe(jwk2020.id);
		expect(keypair).toHaveProperty('publicKeyMultibase');
		expect(keypair).toHaveProperty('privateKeyMultibase');
	});

	it('generates as X25519KeyAgreementKey2019', async () => {
		const keypair = await JsonWebKeyPair.generate({ kty: 'OKP', crv: 'X25519' });
		expect(keypair.type).toBe('X25519KeyAgreementKey2019');
		expect(keypair).toHaveProperty('publicKeyBase58');
		expect(keypair).toHaveProperty('privateKeyBase58');
	});
});

================
File: src/tests/unit/crypto/JWE.test.ts
================
import { describe, it, expect } from 'bun:test';
import { JsonWebEncryptionSuite, X25519KeyAgreementKey2019 } from '../../../lib/crypto';

const plaintext = require('../../fixtures/crypto/plaintext.json');
const jwe = require('../../fixtures/crypto/jwe.json');
const key = require('../../fixtures/keypairs/X25519KeyAgreementKey2019.json');
const key2 = require('../../fixtures/keypairs/X25519KeyAgreementKey2020.json')

describe('JWE', () => {
	it('Can encrypt data w/ base58 key', async () => {
		const cipher = new JsonWebEncryptionSuite();
		const recipients = [
			{
				header: {
					kid: key.id,
					alg: 'ECDH-ES+A256KW'
				}
			}
		];
		const publicKeyResolver = () => key;

		const result = await cipher.encrypt({
			data: plaintext,
			recipients,
			publicKeyResolver
		});
		expect(result).toHaveProperty('protected');
		expect(result.recipients.length).toBe(1);
		expect(result).toHaveProperty('iv');
		expect(result).toHaveProperty('ciphertext');
		expect(result).toHaveProperty('tag');
	});

	it('Can encrypt data w/ multibase key', async () => {
		const cipher = new JsonWebEncryptionSuite();
		const recipients = [
			{
				header: {
					kid: key2.id,
					alg: 'ECDH-ES+A256KW'
				}
			}
		];
		const publicKeyResolver = () => key2;

		const result = await cipher.encrypt({
			data: plaintext,
			recipients,
			publicKeyResolver
		});
		expect(result).toHaveProperty('protected');
		expect(result.recipients.length).toBe(1);
		expect(result).toHaveProperty('iv');
		expect(result).toHaveProperty('ciphertext');
		expect(result).toHaveProperty('tag');
	});

	it('Can decrypt data', async () => {
		const cipher = new JsonWebEncryptionSuite();
		const keyAgreementKey = new X25519KeyAgreementKey2019(
			key.id,
			key.controller,
			key.publicKeyBase58,
			key.privateKeyBase58
		);

		const result = await cipher.decrypt({
			jwe,
			keyAgreementKey
		});

		expect(result.body).toBe('hello world');
	});
});

================
File: src/tests/unit/crypto/JWS.test.ts
================
import { describe, it, expect } from 'bun:test';
import { Buffer } from 'buffer/index.js';
import { documentLoader } from '../../fixtures/crypto/documentLoader';
import { JsonWebSignature2020Suite } from '../../../lib/crypto/JWS/Suite';
import { JsonWebKeyPair } from '../../../lib/crypto';

const plaintext = require('../../fixtures/crypto/plaintext.json');
const jwk2020 = require('../../fixtures/keypairs/JsonWebKey2020.json');
const jws = require('../../fixtures/crypto/jws.json');

describe('JWS', () => {
	it('Can sign data', async () => {
		const key = await JsonWebKeyPair.fromJWK(jwk2020);
		const suite = new JsonWebSignature2020Suite({
			key,
			date: new Date().toISOString()
		});

		const result = await suite.sign(Buffer.from(plaintext.body, 'utf-8'));

		expect(result).toBe(jws.jws);
		expect(result).toContain('..');
	});

	it('Can verify data', async () => {
		const key = await JsonWebKeyPair.fromJWK(jwk2020);
		const suite = new JsonWebSignature2020Suite({
			key,
			date: new Date().toISOString()
		});

		const result = await suite.verify(Buffer.from(plaintext.body, 'utf-8'), key, { jws: jws.jws });

		expect(result.verified).toBeTrue();
	});

	it(`Can create proof w/ challenge`, async () => {
		const credential = require(`../../fixtures/credentials/case-1.json`);
		const key = await JsonWebKeyPair.fromJWK(jwk2020);
		const suite = new JsonWebSignature2020Suite({
			key,
			date: new Date().toISOString()
		});

		const result = await suite.createProof(
			credential,
			'assertionMethod',
			documentLoader,
			{challenge: 'challenge123'}
		);

		expect(result.challenge).toBe('challenge123');
		expect(result.domain).toBeUndefined();
	});

	it(`Can create proof w/ domain`, async () => {
		const credential = require(`../../fixtures/credentials/case-1.json`);
		const key = await JsonWebKeyPair.fromJWK(jwk2020);
		const suite = new JsonWebSignature2020Suite({
			key,
			date: new Date().toISOString()
		});

		const result = await suite.createProof(
			credential,
			'assertionMethod',
			documentLoader,{domain: 'domain123'}
		);

		expect(result.domain).toBe('domain123');
		expect(result.challenge).toBeUndefined();
	});

	it(`Can create proof w/ challenge & domain`, async () => {
		const credential = require(`../../fixtures/credentials/case-1.json`);
		const key = await JsonWebKeyPair.fromJWK(jwk2020);
		const suite = new JsonWebSignature2020Suite({
			key,
			date: new Date().toISOString()
		});

		const result = await suite.createProof(
			credential,
			'assertionMethod',
			documentLoader,
			{
				domain: 'domain123',
				challenge: 'challenge123'
			}
		);

		expect(result.domain).toBe('domain123');
		expect(result.challenge).toBe('challenge123');
	});

	it(`Can verify proof w/ challenge & domain`, async () => {
		const credential = require(`../../fixtures/credentials/case-1.json`);
		const proof = require('../../fixtures/crypto/proofs/with-challenge-and-domain.json');
		const key = await JsonWebKeyPair.fromJWK(jwk2020);
		const suite = new JsonWebSignature2020Suite({
			key,
			date: new Date().toISOString()
		});

		const result = await suite.verifyProof(proof, credential, documentLoader);

		expect(result.verified).toBeTrue();
	});

	// cases
	['1', '2'].forEach((v) => {
		it(`Can create proof: case-${v}`, async () => {
			const credential = require(`../../fixtures/credentials/case-${v}.json`);
			const key = await JsonWebKeyPair.fromJWK(jwk2020);
			const suite = new JsonWebSignature2020Suite({
				key,
				date: new Date().toISOString()
			});
			
			const result = await suite.createProof(credential, 'assertionMethod', documentLoader);
			expect(result.proofPurpose).toBe('assertionMethod');
			expect(result.type).toBe('JsonWebSignature2020');
			expect(result).toHaveProperty('created');
			expect(result.verificationMethod).toBe(jwk2020.id);
			expect(result).toHaveProperty('jws');
			expect(result.jws).toContain('..');
		});

		it(`Can verify proof: case-${v}`, async () => {
			const credential = require(`../../fixtures/credentials/case-${v}.json`);
			const proof = require(`../../fixtures/crypto/proofs/case-${v}.json`);
			const key = await JsonWebKeyPair.fromJWK(jwk2020);
			const suite = new JsonWebSignature2020Suite({
				key,
				date: new Date().toISOString()
			});

			const result = await suite.verifyProof(proof, credential, documentLoader);

			expect(result.verified).toBeTrue();
		});

		it(`Can create and verify proof: case-${v}`, async () => {
			const credential = require(`../../fixtures/credentials/case-${v}.json`);
			const key = await JsonWebKeyPair.fromJWK(jwk2020);
			const suite = new JsonWebSignature2020Suite({
				key,
				date: new Date().toISOString()
			});

			const proof = await suite.createProof(credential, 'assertionMethod', documentLoader);
			const result = await suite.verifyProof(proof, credential, documentLoader);

			expect(result.verified).toBeTrue();
		});
	});
});

================
File: src/tests/unit/crypto/JWT.test.ts
================
import { beforeEach, describe, expect, test } from 'bun:test'
import { JWTSuite } from '../../../lib/crypto/JWT/Suite';
import { JsonWebKeyPair } from '../../../lib/crypto';

let jwk2020: any;

describe('JWT', () => {
    beforeEach(() => {
		jwk2020 = require('../../fixtures/keypairs/JsonWebKey2020.json');
	})
    test('createJWT will create a JWT', async () => {
        const key = await JsonWebKeyPair.fromJWK(jwk2020)
        const suite = new JWTSuite({key, alg: 'ES256K'})
        const signed = await suite.sign({claim: 'yes'})
        console.log(signed)
        expect(signed.split('.').length).toBe(3)
    })

    test('verifyJWT will verify a JWT', async () => {
        const key = await JsonWebKeyPair.fromJWK(jwk2020)
        const suite = new JWTSuite({key, alg: 'ES256K'})
        debugger;
        const verified = await suite.verify('eyJhbGciOiJFUzI1NksiLCJ0eXAiOiJKV1QiLCJraWQiOiJkaWQ6ZXhhbXBsZToxMjMja2V5LTEifQ.eyJjbGFpbSI6InllcyJ9.3Z6A07kFWRwadAe0pmH-uX2lOT0K6QRlT0OljtubWfIS3SKyjl52QnqzvEg2pHHF6mO0USl2dCKvtmYxPj6NGA')
        console.log(verified)
        expect(verified.verified).toBeTruthy()
        expect(verified.errors).toHaveLength(0)
    })

    test('verifyJWT will error on malformed JWT', async () => {
        const key = await JsonWebKeyPair.fromJWK(jwk2020)
        const suite = new JWTSuite({key, alg: 'ES256K'})
        const verified = await suite.verify('a51eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ0ZXN0Ijoib2siLCJpYXQiOjE2NTc3NTIzMDB9._E8d8OA7OPxQcEigW-neaF2lVju9OpjqryiVL8OZA7I')
        expect(verified.errors[0].length).toBeGreaterThan(1)
        expect(verified.verified).toBeFalsy()
    })
})

================
File: src/tests/unit/crypto/mnemonic.test.ts
================
import { entropyToMnemonic, mnemonicToEntropy, mnemonicToSeed } from "../../../lib/crypto/mnemonic";
import { describe, expect, test } from "bun:test";
import vectors from '../../fixtures/crypto/mnemonic.json'

describe('mnemonic tests', () => {
  test('can generate 12 words', () => {
    for (const vector of vectors.english) {
        const mnemonic = entropyToMnemonic(vector[0])
        expect(mnemonic).toBe(vector[1])
    }
  })

  test('can recover 12 words', () => {
    for (const vector of vectors.english) {
        const entropy = mnemonicToEntropy(vector[1])
        expect(entropy).toBe(vector[0])
    }
  })

  test('can convert 12 words to seed hex', () => {
    for (const vector of vectors.english) {
        const seed = mnemonicToSeed(vector[1], "TREZOR")
        expect(seed).toBe(vector[2])
    }
  })
})

================
File: src/tests/unit/crypto/Multikey.test.ts
================
import { expect, test, describe } from 'bun:test';
import * as ed25519 from '@stablelib/ed25519';
import * as secp from '@noble/secp256k1';
import { KeyType, Multikey } from '../../../lib/crypto/keypairs/Multikey';

describe('Multikey', () => {
  // Generate real Ed25519 key pair
  const ed25519KeyPair = ed25519.generateKeyPair();
  const ed25519PublicKey = ed25519KeyPair.publicKey;
  const ed25519PrivateKey = ed25519KeyPair.secretKey;

  // Generate real Secp256k1 key pair
  const secp256k1PrivateKey = secp.utils.randomPrivateKey();
  const secp256k1PublicKey = secp.getPublicKey(secp256k1PrivateKey);

  test('should create an Ed25519 Multikey', () => {
    const multikey = new Multikey(KeyType.Ed25519, 'did:example:123#key-1', 'did:example:123', ed25519PublicKey, ed25519PrivateKey);
    expect(multikey.type).toBe('Multikey');
    expect(multikey.publicKeyMultibase).toStartWith('z');
    expect(multikey.privateKeyMultibase).toStartWith('z');
  });

  test('should create a Secp256k1 Multikey', () => {
    const multikey = new Multikey(KeyType.Secp256k1, 'did:example:456#key-2', 'did:example:456', secp256k1PublicKey, secp256k1PrivateKey);
    expect(multikey.type).toBe('Multikey');
    expect(multikey.publicKeyMultibase).toStartWith('z');
    expect(multikey.privateKeyMultibase).toStartWith('z');
  });

  test('should decode Ed25519 public key', () => {
    const multikey = new Multikey(KeyType.Ed25519, 'did:example:123#key-1', 'did:example:123', ed25519PublicKey, ed25519PrivateKey);
    const decoded = Multikey.decodePublicKey(multikey.publicKeyMultibase);
    expect(decoded.keyType).toBe(KeyType.Ed25519);
    expect(decoded.publicKey).toEqual(ed25519PublicKey);
  });

  test('should decode Secp256k1 public key', () => {
    const multikey = new Multikey(KeyType.Secp256k1, 'did:example:456#key-2', 'did:example:456', secp256k1PublicKey, secp256k1PrivateKey);
    const decoded = Multikey.decodePublicKey(multikey.publicKeyMultibase);
    expect(decoded.keyType).toBe(KeyType.Secp256k1);
    expect(decoded.publicKey).toEqual(secp256k1PublicKey);
  });

  test('should decode Ed25519 private key', () => {
    const multikey = new Multikey(KeyType.Ed25519, 'did:example:123#key-1', 'did:example:123', ed25519PublicKey, ed25519PrivateKey);
    const decoded = Multikey.decodePrivateKey(multikey.privateKeyMultibase!);
    expect(decoded.keyType).toBe(KeyType.Ed25519);
    expect(decoded.privateKey).toEqual(ed25519PrivateKey);
  });

  test('should decode Secp256k1 private key', () => {
    const multikey = new Multikey(KeyType.Secp256k1, 'did:example:456#key-2', 'did:example:456', secp256k1PublicKey, secp256k1PrivateKey);
    const decoded = Multikey.decodePrivateKey(multikey.privateKeyMultibase!);
    expect(decoded.keyType).toBe(KeyType.Secp256k1);
    expect(decoded.privateKey).toEqual(secp256k1PrivateKey);
  });

  test('should generate correct JSON representation', () => {
    const multikey = new Multikey(KeyType.Ed25519, 'did:example:123#key-1', 'did:example:123', ed25519PublicKey, ed25519PrivateKey);
    const json = multikey.toJSON();
    expect(json['@context']).toEqual(['https://w3id.org/security/multikey/v1']);
    expect(json.id).toBe('did:example:123#key-1');
    expect(json.type).toBe('Multikey');
    expect(json.controller).toBe('did:example:123');
    expect(json.publicKeyMultibase).toBeDefined();
    expect(json.privateKeyMultibase).toBeDefined();
  });

  test('should sign and verify with Ed25519 key', async () => {
    const multikey = new Multikey(KeyType.Ed25519, 'did:example:123#key-1', 'did:example:123', ed25519PublicKey, ed25519PrivateKey);
    const data = new TextEncoder().encode('Hello, world!');
    const signature = await multikey.sign(data);
    const isValid = await multikey.verify(data, signature);
    expect(isValid).toBe(true);
  });

  test('should sign with Secp256k1 key and return Uint8Array', async () => {
    const multikey = new Multikey(KeyType.Secp256k1, 'did:example:456#key-2', 'did:example:456', secp256k1PublicKey, secp256k1PrivateKey);
    const data = new TextEncoder().encode('Hello, world!');
    const signature = await multikey.sign(data);
    expect(signature).toBeInstanceOf(Uint8Array);
    expect(signature.length).toBe(64);
  });

  test('should sign and verify with Secp256k1 key', async () => {
    const multikey = new Multikey(KeyType.Secp256k1, 'did:example:456#key-2', 'did:example:456', secp256k1PublicKey, secp256k1PrivateKey);
    const data = new TextEncoder().encode('Hello, world!');
    const signature = await multikey.sign(data);
    const isValid = await multikey.verify(data, signature);
    expect(isValid).toBe(true);
  });

  test('should fail to verify with incorrect data', async () => {
    const multikey = new Multikey(KeyType.Ed25519, 'did:example:123#key-1', 'did:example:123', ed25519PublicKey, ed25519PrivateKey);
    const data = new TextEncoder().encode('Hello, world!');
    const signature = await multikey.sign(data);
    const incorrectData = new TextEncoder().encode('Hello, World!');
    const isValid = await multikey.verify(incorrectData, signature);
    expect(isValid).toBe(false);
  });

  test('should throw error when trying to sign without private key', async () => {
    const multikey = new Multikey(KeyType.Ed25519, 'did:example:789#key-3', 'did:example:789', ed25519PublicKey);
    const data = new TextEncoder().encode('Hello, world!');
    expect(multikey.sign(data)).rejects.toThrow('No private key available for signing');
  });

  test('should throw error for unsupported key type', () => {
    expect(() => {
      new Multikey('UnsupportedType' as KeyType, 'did:example:789#key-3', 'did:example:789', new Uint8Array(32));
    }).toThrow('Unsupported key type');
  });
});

================
File: src/tests/unit/crypto/Secp256k1KeyPair.test.ts
================
import { describe, expect, test } from "bun:test"
import { Secp256k1KeyPair } from "../../../lib/crypto";

const key = require('../../fixtures/keypairs/EcdsaSecp256k1VerificationKey2019.json');

describe('Secp256k1 KeyPair tests', () => {
	test('should construct from object', async () => {
		const keypair = Secp256k1KeyPair.from(key);

		expect(keypair.id).toBe(key.id);
		expect(keypair.privateKeyBase58).toBe(key.privateKeyBase58);
		expect(keypair.publicKeyBase58).toBe(key.publicKeyBase58);
		expect(keypair.type).toBe(key.type);
		expect(keypair.controller).toBe(key.controller);
	});

	test('should sign and verify', async () => {
		const msg = 'hello tester';
		const encoder = new TextEncoder();
		const encodedMsg = encoder.encode(msg);
		const keypair = Secp256k1KeyPair.from(key);

		const signature = await keypair.sign(encodedMsg);
		const verified = await keypair.verify(encodedMsg, signature);

		expect(verified).toBeTrue();
	});

	test('generates', async () => {
		let keypair = await Secp256k1KeyPair.generate();
		expect(keypair).toHaveProperty('privateKey');
		expect(keypair).toHaveProperty('publicKey');
	});

	test('exports as JWK', async () => {
		const keypair = await Secp256k1KeyPair.generate();
		const jwk = await keypair.export({
			privateKey: true,
			type: 'JsonWebKey2020'
		});
		expect(jwk).toHaveProperty('privateKeyJwk');
		expect(jwk.privateKeyJwk).toHaveProperty('d');
		expect(jwk).toHaveProperty('publicKeyJwk');
		expect(jwk.publicKeyJwk).toHaveProperty('x');
		expect(jwk.publicKeyJwk).toHaveProperty('y');
	});
	
	test('exports as JWK w/o private key', async () => {
		const keypair = await Secp256k1KeyPair.generate();
		const jwkJustPub = await keypair.export();
		expect(jwkJustPub).toHaveProperty('publicKeyJwk');
		expect(jwkJustPub.publicKeyJwk).toHaveProperty('x');
		expect(jwkJustPub.publicKeyJwk).toHaveProperty('y');
		expect(jwkJustPub.privateKeyJwk).toBeUndefined();
	});

	test('from xpub', async () => {
		const xpub = 'xpub6CUGRUonZSQ4TWtTMmzXdrXDtypWKiKrhko4egpiMZbpiaQL2jkwSB1icqYh2cfDfVxdx4df189oLKnC5fSwqPfgyP3hooxujYzAu3fDVmz';
		const keypair = await Secp256k1KeyPair.fromXpub(xpub);
		expect(keypair!.id).toContain('zQ3shizorZPFPkPVctdMRanf441efDPxWhPu9e4fq5ZwtHN5D')
	})
});

================
File: src/tests/unit/crypto/X25519KeyAgreementKey2019.test.ts
================
import { describe, expect, test } from 'bun:test';
import { X25519KeyAgreementKey2019 } from '../../../lib/crypto/keypairs/X25519KeyAgreementKey2019';
import { base58, base64url } from '../../../lib/crypto/utils/encoding';

describe('X25519KeyAgreementKey2019', () => {
	test('resolves as JWK', async () => {
		const x25519key = require('../../fixtures/keypairs/X25519KeyAgreementKey2019.json');

		const key = new X25519KeyAgreementKey2019(
			x25519key.id,
			x25519key.controller,
			x25519key.publicKeyBase58,
			x25519key.privateKeyBase58
		);

		const jwk = await key.export({ privateKey: true, type: 'JsonWebKey2020' });
		expect(jwk.privateKeyJwk!.crv).toBe('X25519');
		expect(jwk.privateKeyJwk!.kty).toBe('OKP');
		expect(jwk.privateKeyJwk!.x).toBe(base64url.encode(base58.decode(x25519key.publicKeyBase58)));
		expect(jwk.privateKeyJwk!.d).toBe(base64url.encode(base58.decode(x25519key.privateKeyBase58)));
	});

	test('w/o private key resolves as JWK', async () => {
		let x25519key = require('../../fixtures/keypairs/X25519KeyAgreementKey2019.json');
		x25519key = {
			...x25519key,
			privateKeyBase58: undefined
		};

		const key = new X25519KeyAgreementKey2019(
			x25519key.id,
			x25519key.controller,
			x25519key.publicKeyBase58,
			x25519key.privateKeyBase58
		);

		const jwk = await key.export({ privateKey: true, type: 'JsonWebKey2020' });
		expect(jwk.publicKeyJwk!.crv).toBe('X25519');
		expect(jwk.publicKeyJwk!.kty).toBe('OKP');
		expect(jwk.publicKeyJwk!.x).toBe(base64url.encode(base58.decode(x25519key.publicKeyBase58)));
	});
});

================
File: src/tests/unit/crypto/X25519KeyAgreementKey2020.test.ts
================
import { describe, expect, test } from 'bun:test';
import { base64url, multibase, MULTICODEC_X25519_PRIV_HEADER, MULTICODEC_X25519_PUB_HEADER, X25519KeyAgreementKey2020 } from '../../../lib/crypto';

describe('X25519KeyAgreementKey2020', () => {
	test('resolves as JWK', async () => {
		const x25519key = require('../../fixtures/keypairs/X25519KeyAgreementKey2020.json');

		const key = new X25519KeyAgreementKey2020(
			x25519key.id,
			x25519key.controller,
			x25519key.publicKeyMultibase,
			x25519key.privateKeyMultibase
		);

		const jwk = await key.export({ privateKey: true, type: 'JsonWebKey2020' });
		expect(jwk.privateKeyJwk!.crv).toBe('X25519');
		expect(jwk.privateKeyJwk!.kty).toBe('OKP');
		expect(jwk.privateKeyJwk!.x).toBe(base64url.encode(multibase.decode(MULTICODEC_X25519_PUB_HEADER, x25519key.publicKeyMultibase)));
		expect(jwk.privateKeyJwk!.d).toBe(base64url.encode(multibase.decode(MULTICODEC_X25519_PRIV_HEADER, x25519key.privateKeyMultibase)));
	});

	test('w/o private key resolves as JWK', async () => {
		let x25519key = require('../../fixtures/keypairs/X25519KeyAgreementKey2020.json');
		x25519key = {
			...x25519key,
			privateKeyMultibase: undefined
		};

		const key = new X25519KeyAgreementKey2020(
			x25519key.id,
			x25519key.controller,
			x25519key.publicKeyMultibase,
			x25519key.privateKeyMultibase
		);

		const jwk = await key.export({ privateKey: true, type: 'JsonWebKey2020' });
		expect(jwk.publicKeyJwk!.crv).toBe('X25519');
		expect(jwk.publicKeyJwk!.kty).toBe('OKP');
		expect(jwk.publicKeyJwk!.x).toBe(base64url.encode(multibase.decode(MULTICODEC_X25519_PUB_HEADER, x25519key.publicKeyMultibase)));
	});

	test('can generate', async () => {
		const key = await X25519KeyAgreementKey2020.generate()
		expect(key).toHaveProperty('publicKey')
		expect(key).toHaveProperty('privateKey')
	})
});

================
File: src/tests/unit/dids/did-document-verification-method.test.ts
================
import { DIDDocumentVerificationMethod } from "../../../lib/dids";
import { describe, expect, it } from "bun:test"

describe("DIDDocumentVerificationMethod", () => {
  it("can initialize from json", async () => {
    const json = {
      "id": "did:web:example.com#key-2",
      "controller": "did:web:example.com",
      "type": "JsonWebKey2020",
      "publicKeyJwk": {
        "kty": "OKP",
        "crv": "X25519",
        "x": "fQwRvPeImgps_58yMWoaYeoEIYZW_XDgpmKMQHn7ozQ"
      }
    };

    const v = new DIDDocumentVerificationMethod(json);

    expect(v.id).toBe("did:web:example.com#key-2");
    expect(v.controller).toBe("did:web:example.com");
    expect(v.type).toBe("JsonWebKey2020");
  });

  it("can export json of unknown type", async () => {
    const v = new DIDDocumentVerificationMethod({id: 'test', type: 'unknownCryptoSuite'});
    expect(v.id).toBe("test");
    expect(v.type).toBe("unknownCryptoSuite" as any);
  });
});

================
File: src/tests/unit/dids/did-document.test.ts
================
import { DIDDocument } from "../../../lib/dids";
import { describe, expect, it } from "bun:test";

describe("DIDDocument", () => {
  it("can initialize from json", async () => {
    const json = {
      "@context": [
        "https://www.w3.org/ns/did/v1",
        "https://w3id.org/security/suites/jws-2020/v1"
      ],
      "id": "did:web:example.com",
      "verificationMethod": [
        {
          "id": "did:web:example.com#key-0",
          "controller": "did:web:example.com",
          "type": "JsonWebKey2020",
          "publicKeyJwk": {
            "kty": "OKP",
            "crv": "Ed25519",
            "x": "-1DbVcaL159vjV1vuKDixdJ0FppLbGarLw_sGJ9OqfQ"
          }
        },
        {
          "id": "did:web:example.com#key-2",
          "controller": "did:web:example.com",
          "type": "JsonWebKey2020",
          "publicKeyJwk": {
            "kty": "OKP",
            "crv": "X25519",
            "x": "fQwRvPeImgps_58yMWoaYeoEIYZW_XDgpmKMQHn7ozQ"
          }
        }
      ],
      "authentication": ["did:web:example.com#key-0"],
      "assertionMethod": ["did:web:example.com#key-0"],
      "keyAgreement": ["did:web:example.com#key-2"],
      "service": [
        {
          "id": "did:web:example.com#didcomm",
          "type": "DIDCommMessaging",
          "serviceEndpoint": "http://example.com/didcomm",
          "routingKeys": ["did:web:example.com#key-2"]
        }
      ]
    };

    const didDoc = new DIDDocument(json);

    expect(didDoc.id).toBe("did:web:example.com");
    expect(didDoc.context).toContain("https://www.w3.org/ns/did/v1");
    expect(didDoc.context).toContain(
      "https://w3id.org/security/suites/jws-2020/v1"
    );
    expect(didDoc.verificationMethod).toHaveLength(2);
    expect(didDoc.authentication[0].controller).toBe("did:web:example.com");
    expect(didDoc.authentication[0].id).toBe("did:web:example.com#key-0");
    expect(didDoc.service[0].type).toBe("DIDCommMessaging");
    expect(didDoc.service[0].id).toBe("did:web:example.com#didcomm");
  });

  it("can get all key agreement keys", async () => {
    const json = {
      "@context": [
        "https://www.w3.org/ns/did/v1",
        "https://w3id.org/security/suites/jws-2020/v1"
      ],
      "id": "did:web:example.com",
      "verificationMethod": [
        {
          "id": "did:web:example.com#key-2",
          "controller": "did:web:example.com",
          "type": "JsonWebKey2020",
          "publicKeyJwk": {
            "kty": "OKP",
            "crv": "X25519",
            "x": "fQwRvPeImgps_58yMWoaYeoEIYZW_XDgpmKMQHn7ozQ"
          }
        }
      ],
      "keyAgreement": ["did:web:example.com#key-2"]
    };
    const didDoc = new DIDDocument(json);

    const kaks = didDoc.getAllKeyAgreements();

    expect(kaks.length).toBe(1);
    expect(kaks[0]).toMatchObject({
      id: "did:web:example.com#key-2",
      controller: "did:web:example.com",
      type: "JsonWebKey2020",
      publicKeyJwk: {
        kty: "OKP",
        crv: "X25519",
        x: "fQwRvPeImgps_58yMWoaYeoEIYZW_XDgpmKMQHn7ozQ",
      },
    });
  });
});

================
File: src/tests/unit/dids/did-resolver.test.ts
================
import { describe, it, expect, afterEach } from "bun:test";
import { mock, clearMocks } from "bun-bagel";
import type { MockOptions } from "bun-bagel";
import { DIDMethodNotSupported, DIDNotFoundError, DIDResolver } from "../../../lib/dids";

describe('DIDResolver', () => {
  afterEach(() => {
    clearMocks();
  });

  it("throws DIDNotFound when did not resolved", async () => {
    const resolver = new DIDResolver();
    const options: MockOptions = {
      response: {
        status: 404
      }
    };
    mock("https://example.com/.well-known/did.json", options);

    try {
      const did = await resolver.resolve("did:web:example.com");
      expect(true).toBeFalsy()
    } catch (e) {
      expect(e instanceof DIDNotFoundError).toBeTruthy();
    }
  });

  it("throws not supported when did method not found", async () => {
    const resolver = new DIDResolver();

    let res, err;
    try {
      res = await resolver.resolve("did:fake:example.com");
    } catch (e: any) {
      err = e;
    }
    expect(err.message).toBe('DID did:fake:example.com not found');
  });
});

describe('did:web', () => {
  afterEach(() => {
    clearMocks();
  });

  it("can resolve a web did", async () => {
    const didDoc = {
      "@context": ["https://www.w3.org/ns/did/v1"],
      "id": "did:web:example.com",
      "verificationMethod": []
    };
    const options: MockOptions = {
      response: {
        status: 200,
        headers: { 'Content-Type': 'application/json' },
        data: didDoc
      }
    };
    mock("https://example.com/.well-known/did.json", options);

    const resolver = new DIDResolver();
    const did = await resolver.resolve("did:web:example.com");

    expect(did["@context"]).toContain("https://www.w3.org/ns/did/v1");
  });

  it("can resolve a web did w/ a path", async () => {
    const didDoc = {
      "@context": ["https://www.w3.org/ns/did/v1"],
      "id": "did:web:example.com:user:123",
      "verificationMethod": []
    };
    const options: MockOptions = {
      response: {
        status: 200,
        headers: { 'Content-Type': 'application/json' },
        data: didDoc
      }
    };
    mock("https://example.com/user/123/did.json", options);

    const resolver = new DIDResolver();
    const did = await resolver.resolve("did:web:example.com:user:123");

    expect(did["@context"]).toContain("https://www.w3.org/ns/did/v1");
  });

  it("can resolve a web did w/ a port", async () => {
    const didDoc = {
      "@context": ["https://www.w3.org/ns/did/v1"],
      "id": "did:web:example.com%3A3000:user:123",
      "verificationMethod": []
    };
    const options: MockOptions = {
      response: {
        status: 200,
        headers: { 'Content-Type': 'application/json' },
        data: didDoc
      }
    };
    mock("https://example.com:3000/user/123/did.json", options);

    const resolver = new DIDResolver();
    const did = await resolver.resolve("did:web:example.com%3A3000:user:123");

    expect(did["@context"]).toContain("https://www.w3.org/ns/did/v1");
  });

  it("can resolve a web did w/ http on localhost", async () => {
    const didDoc = {
      "@context": ["https://www.w3.org/ns/did/v1"],
      "id": "did:web:localhost%3A5102",
      "verificationMethod": []
    };
    const options: MockOptions = {
      response: {
        status: 200,
        headers: { 'Content-Type': 'application/json' },
        data: didDoc
      }
    };
    mock("http://localhost:5102/.well-known/did.json", options);

    const resolver = new DIDResolver();
    const did = await resolver.resolve("did:web:localhost%3A5102");

    expect(did["@context"]).toContain("https://www.w3.org/ns/did/v1");
  });
});

describe('did:peer', () => {
  it("can resolve a peer did (alg 0)", async () => {
    const did = "did:peer:0z6MkqRYqQiSgvZQdnBytw86Qbs2ZWUkGv22od935YF4s8M7V";

    const resolver = new DIDResolver();
    const resolvedDoc = await resolver.resolve(did);

    expect(resolvedDoc["@context"]).toContain("https://www.w3.org/ns/did/v1");
    expect(resolvedDoc.verificationMethod![0].id).toBe("did:peer:0z6MkqRYqQiSgvZQdnBytw86Qbs2ZWUkGv22od935YF4s8M7V#6MkqRYqQiSgvZQdnBytw86Qbs2ZWUkGv22od935YF4s8M7V");
    expect(resolvedDoc.authentication![0].id).toBe("did:peer:0z6MkqRYqQiSgvZQdnBytw86Qbs2ZWUkGv22od935YF4s8M7V#6MkqRYqQiSgvZQdnBytw86Qbs2ZWUkGv22od935YF4s8M7V");
  });

  it("can resolve a peer did (alg 2)", async () => {
    const did = "did:peer:2.Ez6LSpSrLxbAhg2SHwKk7kwpsH7DM7QjFS5iK6qP87eViohud.Vz6MkqRYqQiSgvZQdnBytw86Qbs2ZWUkGv22od935YF4s8M7V.SeyJ0IjoiZG0iLCJzIjoiaHR0cHM6Ly9leGFtcGxlLmNvbS9lbmRwb2ludDEiLCJyIjpbImRpZDpleGFtcGxlOnNvbWVtZWRpYXRvciNzb21la2V5MSJdLCJhIjpbImRpZGNvbW0vdjIiLCJkaWRjb21tL2FpcDI7ZW52PXJmYzU4NyJdfQ";
    console.log(DIDResolver)
    const resolver = new DIDResolver();
    const resolvedDoc = await resolver.resolve(did);

    expect(resolvedDoc["@context"]).toContain("https://www.w3.org/ns/did/v1");
    expect(resolvedDoc.verificationMethod!.length).toBe(2);
    expect(resolvedDoc.keyAgreement![0].id).toBe("#key-1");
    expect(resolvedDoc.authentication![0].id).toBe("#key-2");
  });
});

describe('did:key', () => {
  it("can resolve a did:key", async () => {
    const did = "did:key:z6MkjdxYZ17j7DNPfgSB5LviYRxTCXPunZ5Vfbm5QKCEBVgt";

    const resolver = new DIDResolver();
    const resolvedDoc = await resolver.resolve(did);
    
    expect(resolvedDoc["@context"]).toContain("https://www.w3.org/ns/did/v1");
    expect(resolvedDoc.verificationMethod!.length).toBe(1);
    expect(resolvedDoc.authentication![0].id).toBe(`${did}#${did.split(':')[2]}`);
    expect(resolvedDoc.assertionMethod![0].id).toBe(`${did}#${did.split(':')[2]}`);
  });
});

================
File: src/tests/unit/dids/secret-resolver.test.ts
================
import { EnvironmentVariableSecretResolver, JSONSecretResolver } from "../../../lib/dids";
import { SecretTypeNotFound } from "../../../lib/dids/Secret";
import { describe, expect, it } from "bun:test"
import { base64url } from "../../../lib/crypto";

describe("SecretResolver", () => {
  it("can resolve a JsonWebKey2020 JSON file", async () => {
    const secretFile = {
      "id": "did:web:example.com#key-0",
      "type": "JsonWebKey2020",
      "publicKeyJwk": {
        "kty": "OKP",
        "crv": "Ed25519",
        "x": "s_7sGeMPuhusy_X4slKydGXWAhvVfqBDW2DwZHloWr0"
      },
      "privateKeyJwk": {
        "kty": "OKP",
        "crv": "Ed25519",
        "x": "s_7sGeMPuhusy_X4slKydGXWAhvVfqBDW2DwZHloWr0",
        "d": "u7OKM36_b8k4Yk6QI0c_lOznRsKwnOzlhTfqCkr6VmY"
      }
    };

    const resolver = new JSONSecretResolver(secretFile);
    const secret = await resolver.resolve(secretFile["id"]);
    const jwk = await secret.asJsonWebKey();

    expect(secret.id).toBe("did:web:example.com#key-0");
    expect(secret.type).toBe("JsonWebKey2020");
    expect(jwk.privateKeyJwk!.crv).toBe("Ed25519");
    expect(jwk.privateKeyJwk!.d).toBe(
      "u7OKM36_b8k4Yk6QI0c_lOznRsKwnOzlhTfqCkr6VmY"
    );
    expect(jwk.privateKeyJwk!.kty).toBe("OKP");
    expect(jwk.privateKeyJwk!.x).toBe(
      "s_7sGeMPuhusy_X4slKydGXWAhvVfqBDW2DwZHloWr0"
    );
  });

  it("can resolve a X25519KeyAgreementKey2019 JSON file", async () => {
    const secretFile = {
      "id": "did:web:example.com#key-1",
      "type": "X25519KeyAgreementKey2019",
      "publicKeyBase58": "3zSE11h82KtPYPj8p9cTgzr6yDWFYEsfM19xc1K5vjKY",
      "privateKeyBase58": "66pGmEHd7fBfQa9ap27vWSouHAmipbmmw6GduBwNRY6y"
    };
    const resolver = new JSONSecretResolver(secretFile);

    const secret = await resolver.resolve(secretFile["id"]);
    const jwk = await secret.asJsonWebKey();

    expect(secret.id).toBe("did:web:example.com#key-1");
    expect(secret.type).toBe("X25519KeyAgreementKey2019");
    expect(secret.privateKeyBase58).toBe(
      "66pGmEHd7fBfQa9ap27vWSouHAmipbmmw6GduBwNRY6y"
    );
    expect(jwk.privateKeyJwk!.crv).toBe("X25519");
    expect(jwk.privateKeyJwk!.kty).toBe("OKP");
    expect(jwk.privateKeyJwk!.d).toBe(
      "S8fJ_kWYHtou5yMYqEUQgeJgBz5el-BdH_msKrkwXQY"
    );
  });

  it("throws error when doesn't support a key type", async () => {
    expect(() => {
      new JSONSecretResolver({
        id: "did:web:example.com#key-1",
        type: "BAR",
      });
    }).toThrow(SecretTypeNotFound);
  });

  it("env var secret resolver can resolve a X25519KeyAgreementKey2019 JSON file", async () => {
    const secretFile = {
      "id": "did:web:example.com#key-1",
      "type": "X25519KeyAgreementKey2019",
      "publicKeyBase58": "3zSE11h82KtPYPj8p9cTgzr6yDWFYEsfM19xc1K5vjKY",
      "privateKeyBase58": "66pGmEHd7fBfQa9ap27vWSouHAmipbmmw6GduBwNRY6y"
    };
    const resolver = new EnvironmentVariableSecretResolver({SECRETS: base64url.encode(JSON.stringify([secretFile]))});
    
    const secret = await resolver.resolve(secretFile["id"]);
    const jwk = await secret.asJsonWebKey();

    expect(secret.id).toBe("did:web:example.com#key-1");
    expect(secret.type).toBe("X25519KeyAgreementKey2019");
    expect(secret.privateKeyBase58).toBe(
      "66pGmEHd7fBfQa9ap27vWSouHAmipbmmw6GduBwNRY6y"
    );
    expect(jwk.privateKeyJwk!.crv).toBe("X25519");
    expect(jwk.privateKeyJwk!.kty).toBe("OKP");
    expect(jwk.privateKeyJwk!.d).toBe(
      "S8fJ_kWYHtou5yMYqEUQgeJgBz5el-BdH_msKrkwXQY"
    );
  });

  it("env var secret resolver throws error when doesn't have SECRETS key", async () => {
    expect(() => {
      new EnvironmentVariableSecretResolver({});
    }).toThrow('No (base64 encoded) SECRETS found in environment');
  });
});

================
File: src/tests/unit/dids/secret.test.ts
================
import { Secret } from "../../../lib/dids";
import { describe, expect, it } from "bun:test";

describe("Secret", () => {
  it("can be constructed from json", async () => {
    const json = {
      "id": "did:web:example.com#key-0",
      "type": "JsonWebKey2020",
      "publicKeyJwk": {
        "kty": "OKP",
        "crv": "Ed25519",
        "x": "s_7sGeMPuhusy_X4slKydGXWAhvVfqBDW2DwZHloWr0"
      },
      "privateKeyJwk": {
        "kty": "OKP",
        "crv": "Ed25519",
        "x": "s_7sGeMPuhusy_X4slKydGXWAhvVfqBDW2DwZHloWr0",
        "d": "u7OKM36_b8k4Yk6QI0c_lOznRsKwnOzlhTfqCkr6VmY"
      }
    };

    const secret = new Secret(json);

    expect(secret.id).toBe("did:web:example.com#key-0");
    expect(secret.type).toBe("JsonWebKey2020");
    expect(secret.privateKeyJwk.x).toBe(
      "s_7sGeMPuhusy_X4slKydGXWAhvVfqBDW2DwZHloWr0"
    );
    expect(secret.privateKeyJwk.crv).toBe("Ed25519");
    expect(secret.privateKeyJwk.d).toBe(
      "u7OKM36_b8k4Yk6QI0c_lOznRsKwnOzlhTfqCkr6VmY"
    );
    expect(secret.privateKeyJwk.kty).toBe("OKP");
  });

  it("can be X25519KeyAgreementKey2020", async () => {
    const json = {
      "id": "did:web:example.com#key-1",
      "type": "X25519KeyAgreementKey2020",
      "publicKeyMultibase": "z6LSeRSE5Em5oJpwdk3NBaLVERBS332ULC7EQq5EtMsmXhsM",
      "privateKeyMultibase": "z3weeMD56C1T347EmB6kYNS7trpQwjvtQCpCYRpqGz6mcemT"
    };

    const secret = new Secret(json);

    expect(secret.id).toBe("did:web:example.com#key-1");
    expect(secret.type).toBe("X25519KeyAgreementKey2020");
    expect(secret.privateKeyMultibase).toBe("z3weeMD56C1T347EmB6kYNS7trpQwjvtQCpCYRpqGz6mcemT");
    expect(secret.publicKeyMultibase).toBe("z6LSeRSE5Em5oJpwdk3NBaLVERBS332ULC7EQq5EtMsmXhsM")
  });
});

================
File: src/tests/unit/vcs/issue-and-verify.test.ts
================
import { describe, it, expect } from 'bun:test';
import { JsonWebKeyPair, JsonWebSignature2020Suite, type VerifiableCredential } from '../../../lib/crypto';


import credential from '../../fixtures/credentials/case-10.json';
import key from '../../fixtures/keypairs/JsonWebKey2020.json';
import { IssuanceService } from '../../../lib/vcs/issue';
import { documentLoader } from '../../fixtures/crypto/documentLoader';
import { VerificationService } from '../../../lib/vcs/verify';
import { isProofArray } from '../../../lib/common/utils';

let vc: VerifiableCredential;

describe('issue and verify', () => {
	it('issues a JsonWebSignature2020 VC', async () => {
		const jwk = await JsonWebKeyPair.fromJWK(key);
		const suite = new JsonWebSignature2020Suite({ key: jwk, date: new Date().toISOString() });
    console.log('credential', credential.credentialSubject, credential.issuanceDate) 
		vc = await IssuanceService.issueCredential(credential, {
			type: 'vc-ld',
			suite,
			documentLoader
		});


    let { proof, ...cred } = vc;

    expect(cred).toStrictEqual(credential);
    
		// compare proof separately
		if (isProofArray(proof)) {
      // Handle array of proofs
      expect(proof.length).toBeGreaterThan(0);
      proof.forEach(singleProof => {
        expect(singleProof).toHaveProperty('jws');
        expect(singleProof.jws).toContain('..');
        expect(singleProof.proofPurpose).toBe('assertionMethod');
        expect(singleProof.type).toBe('JsonWebSignature2020');
        expect(singleProof.verificationMethod).toBe(jwk.id);
      });
    } else {
      // Handle single proof
      expect(proof).toHaveProperty('jws');
      expect(proof.jws).toContain('..');
      expect(proof.proofPurpose).toBe('assertionMethod');
      expect(proof.type).toBe('JsonWebSignature2020');
      expect(proof.verificationMethod).toBe(jwk.id);
    }
	});

	it('verifies a JsonWebKeySignature2020 VC', async () => {
		const jwk = await JsonWebKeyPair.fromJWK(key);
		const suite = new JsonWebSignature2020Suite({ key: jwk, date: new Date().toISOString() });
		const result = await VerificationService.verifyCredential(vc, suite, documentLoader);

		expect(result.verified).toBeTrue;
	});
});

================
File: src/tests/unit/vcs/issuer.test.ts
================
import { describe, it, expect, spyOn } from 'bun:test';


import credential from '../../fixtures/credentials/case-10.json';
import key from '../../fixtures/keypairs/JsonWebKey2020.json';
import { MockSignatureSuite } from '../../mocks/MockSignatureSuite';
import { IssuanceService } from '../../../lib/vcs/issue';
import { documentLoader } from '../../fixtures/crypto/documentLoader';
import { JsonWebKeyPair, JsonWebSignature2020Suite } from '../../../lib/crypto';

describe('issuer service', () => {
	it("calls 'sign' on a suite when issuing a valid credential", async () => {
		const mockSig = new MockSignatureSuite();
		spyOn(mockSig, 'createProof');

		const vc = await IssuanceService.issueCredential(credential, {
			type: 'vc-ld',
			suite: mockSig,
			documentLoader
		});

		expect(mockSig.createProof).toBeCalled();
	});

	it("doesn't call 'sign' on a suite when issuing a bad credential", async () => {
		const mockSig = new MockSignatureSuite();
		spyOn(mockSig, 'createProof');
		let badCred = { ...credential };
    // @ts-ignore
		delete badCred['@context'];

		try {
			const vc = await IssuanceService.issueCredential(badCred, {
				type: 'vc-ld',
				suite: mockSig,
				documentLoader
			});
		} catch (e) {
			expect(mockSig.createProof).toBeCalledTimes(0);
		}
	});

	it('issues a JsonWebSignature2020 VC', async () => {
		const jwk = await JsonWebKeyPair.fromJWK(key);
		const suite = new JsonWebSignature2020Suite({ key: jwk, date: new Date().toISOString() });

		const vc = await IssuanceService.issueCredential(credential, {
			type: 'vc-ld',
			suite,
			documentLoader
		});

		// compare proof separately
		let { proof, ...cred } = vc;
		if (!Array.isArray(proof)) {
			proof = [proof];
		}
		expect(cred).toStrictEqual(credential);
		expect(proof[0]).toHaveProperty('jws');
		expect(proof[0].jws).toContain('..');
		expect(proof[0].proofPurpose).toBe('assertionMethod');
		expect(proof[0].type).toBe('JsonWebSignature2020');
		expect(proof[0].verificationMethod).toBe(jwk.id);
	});
});

================
File: src/tests/unit/vcs/jwt.test.ts
================
import { describe, it, expect } from 'bun:test';
import credential from "../../fixtures/credentials/case-10.json";
import { LDCredentialToJWT } from '../../../lib/vcs/jwt';
describe("jwt utils", () => {
  it("should reformat credential to JWT format", () => {
    const newCred = LDCredentialToJWT(credential);

    expect(newCred.jti).toBe("urn:uvci:af5vshde843jf831j128fj");
    expect(newCred.sub).toBe("did:example:123");
    expect(newCred.iss).toBe(
      "did:key:z6MkiY62766b1LJkExWMsM3QG4WtX7QpY823dxoYzr9qZvJ3"
    );
    expect(newCred.nbf).toBe(1575375592);
    expect(newCred.iat).toBe(1575375592);
    expect(newCred.exp).toBe(1890994792);
    expect(newCred).toHaveProperty("nonce");
    expect(newCred.vc.type).toStrictEqual([
      "VerifiableCredential",
      "VaccinationCertificate",
    ]);
    expect(newCred.vc["@context"]).toStrictEqual([
      "https://www.w3.org/2018/credentials/v1",
      "https://w3id.org/vaccination/v1",
    ]);
  });
});

================
File: src/tests/unit/vcs/presentation.test.ts
================
import { describe, it, expect } from 'bun:test';
import presentation from '../../fixtures/presentations/case-10.json';
import key from '../../fixtures/keypairs/JsonWebKey2020.json';
import { documentLoader } from '../../fixtures/crypto/documentLoader';
import { JsonWebKeyPair, JsonWebSignature2020Suite, type LinkedDataSuite } from '../../../lib/crypto';
import { PresentationService } from '../../../lib/vcs/present';

describe('presentation service', () => {
	it('proves a JsonWebSignature2020 VP', async () => {
		const jwk = await JsonWebKeyPair.fromJWK(key);
		const suite = new JsonWebSignature2020Suite({ key: jwk, date: new Date().toISOString() });
		console.log(presentation.verifiableCredential[0].proof)
		const vp = await PresentationService.provePresentation(presentation, {
			challenge: '1235',
			domain: '1',
			type: 'vc-ld',
			suite: suite as LinkedDataSuite,
			documentLoader
		});

		// compare proof separately
		let { proof, ...pres } = vp;
		if (!Array.isArray(proof)) {
			proof = [proof];
		}

		expect(pres).toStrictEqual(presentation);
		expect(proof[0]).toHaveProperty('jws');
		expect(proof[0].domain).toBe('1');
		expect(proof[0].challenge).toBe('1235');
		expect(proof[0].jws).toContain('..');
		expect(proof[0].proofPurpose).toBe('authentication');
		expect(proof[0].type).toBe('JsonWebSignature2020');
		expect(proof[0].verificationMethod).toBe(jwk.id);
	});
});

================
File: src/tests/unit/vcs/validation.test.ts
================
import { describe, it, expect } from 'bun:test';

import cred1 from '../../fixtures/credentials/case-10.json';
import pres1 from '../../fixtures/presentations/case-10.json';
import { ValidateCredential, ValidatePresentation } from '../../../lib/vcs/validation';
import type { Credential, Presentation } from '../../../lib/crypto';

class DummyCredentialClass {
	@ValidateCredential(0)
	static methodBeingValidated(credential: Credential) {
		return 42;
	}
}

class DummyPresentationClass {
	@ValidatePresentation(0)
	static methodBeingValidated(presentation: Presentation) {
		return 42;
	}
}

describe('validation utils', () => {
	it('ValidateCredential should pass through valid credential', () => {
		const result = DummyCredentialClass.methodBeingValidated(cred1 as any);
		expect(result).toBe(42);
	});

	it('ValidateCredential should throw error for invalid credential', () => {
		try {
			let credBad = { ...cred1 };
      // @ts-ignore
			delete credBad.type;
			const result = DummyCredentialClass.methodBeingValidated(credBad as any);
			expect(true).toBeFalse();
		} catch (e: any) {
			expect(e.message).toBe('"type" property is required.');
		}
	});

	it('can validate credential with an ISO string date w/o milliseconds', () => {
		let cred = {
			...cred1,
			issuanceDate: new Date().toISOString().slice(0, -5) + 'Z'
		};
		const result = DummyCredentialClass.methodBeingValidated(cred as Credential);
		expect(result).toBe(42);
	});

	it('ValidatePresentation should pass through valid presentation', () => {
		const result = DummyPresentationClass.methodBeingValidated(pres1);
		expect(result).toBe(42);
	});

	it('ValidatePresentation should throw error for invalid presentation', () => {
		try {
			let presBad = JSON.parse(JSON.stringify(pres1));
			delete presBad.type;
			const result = DummyPresentationClass.methodBeingValidated(presBad);
			expect(true).toBeFalse();
		} catch (e: any) {
			expect(e.message).toBe('"type" property is required.');
		}
	});

	it('ValidatePresentation should throw error for invalid credential in presentation', () => {
		try {
			let presBad = JSON.parse(JSON.stringify(pres1));
			delete presBad.verifiableCredential[0].type;
			const result = DummyPresentationClass.methodBeingValidated(presBad);
			expect(true).toBeFalse();
		} catch (e: any) {
			expect(e.message).toBe('"type" property is required.');
		}
	});
});

================
File: src/tests/unit/vcs/verifier.test.ts
================
import { describe, it, expect } from 'bun:test';

import verifiableCredential from '../../fixtures/verifiableCredentials/case-10.json';
import verifiablePresentation from '../../fixtures/verifiablePresentations/case-10.json';
import key from '../../fixtures/keypairs/JsonWebKey2020.json';
import { JsonWebKeyPair, JsonWebSignature2020Suite } from '../../../lib/crypto';
import { VerificationService } from '../../../lib/vcs/verify';
import { documentLoader } from '../../fixtures/crypto/documentLoader';

describe('verifier service', () => {
	it('fails verification for an invalid JsonWebKeySignature2020 VC', async () => {
		const jwk = await JsonWebKeyPair.fromJWK(key);
		const suite = new JsonWebSignature2020Suite({ key: jwk, date: new Date().toISOString() });
		const vcCopy = JSON.parse(JSON.stringify(verifiableCredential));
		vcCopy.proof.jws = 'ey..123';
		const result = await VerificationService.verifyCredential(vcCopy, suite, documentLoader);

		expect(result.verified).toBeFalse();
	});
	it('verifies a JsonWebKeySignature2020 VC', async () => {
		const jwk = await JsonWebKeyPair.fromJWK(key);
		const suite = new JsonWebSignature2020Suite({ key: jwk, date: new Date().toISOString() });
		const result = await VerificationService.verifyCredential(
			verifiableCredential,
			suite,
			documentLoader
		);

		expect(result.verified).toBeTrue;
	});

	it('fails verification for an invalid JsonWebKeySignature2020 VP', async () => {
		const jwk = await JsonWebKeyPair.fromJWK(key);
		const suite = new JsonWebSignature2020Suite({ key: jwk, date: new Date().toISOString() });
		const vpCopy = JSON.parse(JSON.stringify(verifiablePresentation));
		vpCopy.proof.jws = 'ey..123';

		const result = await VerificationService.verifyPresentation(vpCopy, suite, documentLoader);

		expect(result.verified).toBeFalse();
	});

	it('verifies a JsonWebKeySignature2020 VP', async () => {
		const jwk = await JsonWebKeyPair.fromJWK(key);
		const suite = new JsonWebSignature2020Suite({ key: jwk, date: new Date().toISOString() });
		const result = await VerificationService.verifyPresentation(
			verifiablePresentation,
			suite,
			documentLoader
		);

		expect(result.verified).toBeTrue;
	});
});

================
File: src/global.d.ts
================
declare module 'jsonld';
declare module '@digitalbazaar/vc';
declare module '@digitalbazaar/ed25519-verification-key-2020';
declare module '@digitalbazaar/ed25519-signature-2020';

================
File: src/index.ts
================
export * from './lib/crypto';
export * from './lib/vcs';
export * from './lib/dids';

================
File: .gitignore
================
claude_chats
__ignored
output
node_modules
old
.DS_Store
dist
*.log
.env
.vscode
coverage

================
File: .releaserc.json
================
{
  "branches": ["master"],
  "plugins": [
    "@semantic-release/commit-analyzer",
    "@semantic-release/release-notes-generator",
    "@semantic-release/changelog",
    "@semantic-release/npm",
    "@semantic-release/github",
    "@semantic-release/git"
  ]
}

================
File: CHANGELOG.md
================
# [1.1.0](https://github.com/aviarytech/di-wings/compare/v1.0.1...v1.1.0) (2024-09-28)


### Features

* pr workflow added ([418590a](https://github.com/aviarytech/di-wings/commit/418590aba56311e7fd5c719ffbe7cdcb70959e44))

## [1.0.1](https://github.com/aviarytech/di-wings/compare/v1.0.0...v1.0.1) (2024-09-27)


### Bug Fixes

* update readme ([4509fb4](https://github.com/aviarytech/di-wings/commit/4509fb4fc470459e0c1e29d79566c781fdf32e9b))

# 1.0.0 (2024-09-27)


### Bug Fixes

* move github workflow into folder ([f8bf8a9](https://github.com/aviarytech/di-wings/commit/f8bf8a9283c179d015bc1c6031c33b0f52ee8076))
* publish script branch ([b9ec99c](https://github.com/aviarytech/di-wings/commit/b9ec99c0e8abca07918e192d68a0305c010cbabe))
* release branch ([a1d2eb3](https://github.com/aviarytech/di-wings/commit/a1d2eb37365026300f96c81134d30c0203e83e09))
* remove setJWA dependency ([617591f](https://github.com/aviarytech/di-wings/commit/617591ffce33c05b4b44cb53bded39704a773943))
* repo URL in package ([500506d](https://github.com/aviarytech/di-wings/commit/500506d2bd49cfec392a20415a18a0337356c9da))
* update example ([f75c37c](https://github.com/aviarytech/di-wings/commit/f75c37c5114d7b23e8657ce0c5ff0d4628f43de4))
* update node version in action ([03d2d6f](https://github.com/aviarytech/di-wings/commit/03d2d6f9485fd05ce55711ad232e7a72760cb65c))
* update readme ([ab2a64a](https://github.com/aviarytech/di-wings/commit/ab2a64a63267d11e445c9d653cceee499231da58))

================
File: package.json
================
{
  "name": "di-wings",
  "version": "1.1.0",
  "description": "Aviary Tech's common library for decentralized identity",
  "type": "module",
  "main": "src/index.ts",
  "module": "src/index.ts",
  "types": "src/index.ts",
  "exports": {
    ".": {
      "import": "./src/index.ts",
      "require": "./src/index.ts",
      "types": "./src/index.ts"
    }
  },
  "files": [
    "src"
  ],
  "scripts": {
    "test": "bun test",
    "test:log": "bun test &> output/test-log.txt",
    "test:watch": "bun test --watch",
    "test:bail": "bun test --watch --bail --verbose",
    "repopack": "npx repopack --output ./output/repopack.txt"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/aviarytech/di-wings.git"
  },
  "keywords": [
    "decentralized-identity",
    "digital-identity",
    "cryptography"
  ],
  "author": "Aviary Tech",
  "license": "MIT",
  "devDependencies": {
    "@digitalbazaar/ed25519-signature-2020": "^5.4.0",
    "@digitalbazaar/ed25519-verification-key-2020": "^4.1.0",
    "@digitalbazaar/vc": "^7.0.0",
    "@semantic-release/changelog": "^6.0.3",
    "@semantic-release/git": "^10.0.1",
    "@stablelib/pbkdf2": "^2.0.0",
    "@types/bun": "latest",
    "bun-bagel": "^1.1.0",
    "semantic-release": "^24.1.2",
    "typescript": "^5.0.0"
  },
  "dependencies": {
    "@aviarytech/did-peer": "^0.0.22",
    "@noble/hashes": "^1.5.0",
    "@noble/secp256k1": "^2.1.0",
    "@scure/bip32": "^1.5.0",
    "@stablelib/aes-kw": "^2.0.0",
    "@stablelib/ed25519": "^2.0.0",
    "@stablelib/random": "^2.0.0",
    "@stablelib/sha256": "^2.0.0",
    "@stablelib/x25519": "^2.0.0",
    "@stablelib/xchacha20poly1305": "^2.0.0",
    "b58": "^4.0.3",
    "buffer": "^6.0.3",
    "jose": "^5.9.3",
    "jsonld": "^8.3.2",
    "micro-ed25519-hdkey": "^0.1.2"
  },
  "engines": {
    "bun": ">=1.0.0"
  }
}

================
File: README.md
================
# DI-Wings: Aviary Tech Common Library

The "DI" in DI-Wings represents multiple core concepts central to Aviary Tech's mission:

1. **D**ecentralized **I**dentity: Our primary focus is on revolutionizing identity management through decentralized systems, giving individuals control over their digital identities.

2. **D**ata **I**ntegrity: We ensure the authenticity and immutability of identity data, protecting it from unauthorized alterations and maintaining its trustworthiness.

3. **D**igital **I**nnovation: We're committed to pushing the boundaries of digital technology, constantly innovating in the realm of identity solutions and related fields.

"Wings" aligns with Aviary Tech's branding and symbolizes:

- Enabling technology that gives "flight" to our products

- Freedom and empowerment in digital identity management

This name encapsulates our commitment to decentralized, secure, and innovative digital identity solutions that empower users and organizations alike.

## Using di-wings Crypto

The di-wings library provides a robust set of cryptographic utilities for decentralized identity operations. Here's how to use some of the key features:

### Installation

```bash
npm install di-wings
```

### Key Generation

```typescript
import { Ed25519VerificationKey2020, Secp256k1KeyPair } from 'di-wings';

// Generate an Ed25519 key pair
const ed25519Key = await Ed25519VerificationKey2020.generate();

// Generate a Secp256k1 key pair
const secp256k1Key = await Secp256k1KeyPair.generate();
```

### Signing and Verifying

```typescript
import { Ed25519VerificationKey2020 } from 'di-wings';

const key = await Ed25519VerificationKey2020.generate();
const data = new TextEncoder().encode('Hello, world!');

// Signing
const signature = await key.sign(data);

// Verifying
const isValid = await key.verify(data, signature);
console.log('Signature is valid:', isValid);
```

### JSON Web Signatures (JWS)

```typescript
import { JsonWebSignature2020Suite, JsonWebKeyPair } from 'di-wings';

const key = await JsonWebKeyPair.generate({ kty: 'EC', crv: 'secp256k1' });
const suite = new JsonWebSignature2020Suite({ key });

// Signing
const jws = await suite.sign(Buffer.from('Hello, world!'));

// Verifying
const result = await suite.verify(Buffer.from('Hello, world!'), key, { jws });
console.log('JWS verification result:', result.verified);
```

### JSON Web Encryption (JWE)

```typescript
import { JsonWebEncryptionSuite, X25519KeyAgreementKey2019 } from 'di-wings';

const aliceKey = await X25519KeyAgreementKey2019.generate();
const bobKey = await X25519KeyAgreementKey2019.generate();

const cipher = new JsonWebEncryptionSuite();

// Encrypting
const jwe = await cipher.encrypt({
  data: { secret: 'Hello, Bob!' },
  recipients: [{ header: { kid: bobKey.id, alg: 'ECDH-ES+A256KW' } }],
  publicKeyResolver: () => bobKey
});

// Decrypting
const decrypted = await cipher.decrypt({ jwe, keyAgreementKey: bobKey });
console.log('Decrypted message:', decrypted.secret);
```

### Mnemonics and HD Wallets

```typescript
import { entropyToMnemonic, mnemonicToSeed, seedToHD } from 'di-wings';

// Generate a mnemonic
const entropy = crypto.getRandomValues(new Uint8Array(16));
const mnemonic = entropyToMnemonic(entropy);

// Convert mnemonic to seed
const seed = mnemonicToSeed(mnemonic);

// Create an HD wallet
const masterKey = seedToHD(seed);
```

## Using Verifiable Credentials (VC) Libraries

DI-Wings includes support for Verifiable Credentials, allowing you to issue, verify, and manage VCs easily. Here's how to use the VC libraries:

**Important Note:** The current implementation supports Verifiable Credentials Data Model 1.1. The W3C is actively developing Verifiable Credentials Data Model 2.0, which may introduce significant changes. We will update our library to support VC 2.0 once it's finalized and widely adopted.

Here's how to use the VC 1.1 libraries:

### Issuing a Verifiable Credential

```typescript
import { IssuanceService, JsonWebKeyPair, JsonWebSignature2020Suite } from 'di-wings';
import { documentLoader } from './your-document-loader'; // Implement your own document loader

const credential = {
  "@context": [
    "https://www.w3.org/2018/credentials/v1",
    "https://w3id.org/vaccination/v1"
  ],
  "type": ["VerifiableCredential", "VaccinationCertificate"],
  "issuer": "did:example:123",
  "issuanceDate": "2023-01-01T00:00:00Z",
  "credentialSubject": {
    "id": "did:example:456",
    "type": "VaccinationEvent",
    // ... other credential details
  }
};

const key = await JsonWebKeyPair.generate({ kty: 'EC', crv: 'secp256k1' });
const suite = new JsonWebSignature2020Suite({ key, date: new Date().toISOString() });

const verifiableCredential = await IssuanceService.issueCredential(credential, {
  type: 'vc-ld',
  suite,
  documentLoader
});

console.log('Issued Verifiable Credential:', verifiableCredential);
```

### Verifying a Verifiable Credential

```typescript
import { VerificationService, JsonWebKeyPair, JsonWebSignature2020Suite } from 'di-wings';
import { documentLoader } from './your-document-loader';

const key = await JsonWebKeyPair.fromJWK(existingKeyJWK);
const suite = new JsonWebSignature2020Suite({ key, date: new Date().toISOString() });

const result = await VerificationService.verifyCredential(
  verifiableCredential,
  suite,
  documentLoader
);

console.log('Verification Result:', result.verified);
```

### Creating a Verifiable Presentation

```typescript
import { PresentationService, JsonWebKeyPair, JsonWebSignature2020Suite } from 'di-wings';
import { documentLoader } from './your-document-loader';

const presentation = {
  "@context": ["https://www.w3.org/2018/credentials/v1"],
  "type": ["VerifiablePresentation"],
  "verifiableCredential": [verifiableCredential]
};

const key = await JsonWebKeyPair.fromJWK(holderKeyJWK);
const suite = new JsonWebSignature2020Suite({ key, date: new Date().toISOString() });

const verifiablePresentation = await PresentationService.provePresentation(presentation, {
  challenge: 'challenge123',
  domain: 'example.com',
  type: 'vc-ld',
  suite,
  documentLoader
});

console.log('Created Verifiable Presentation:', verifiablePresentation);
```

### Verifying a Verifiable Presentation

```typescript
import { VerificationService, JsonWebKeyPair, JsonWebSignature2020Suite } from 'di-wings';
import { documentLoader } from './your-document-loader';

const key = await JsonWebKeyPair.fromJWK(holderKeyJWK);
const suite = new JsonWebSignature2020Suite({ key, date: new Date().toISOString() });

const result = await VerificationService.verifyPresentation(
  verifiablePresentation,
  suite,
  documentLoader
);

console.log('Presentation Verification Result:', result.verified);
```

## Using DID Libraries

DI-Wings now includes support for Decentralized Identifiers (DIDs), allowing you to resolve, manage, and work with various DID methods. Here's how to use the DID libraries:

### Resolving DIDs

```typescript
import { DIDResolver } from 'di-wings';

const resolver = new DIDResolver();

// Resolve a did:web
const webDID = await resolver.resolve("did:web:example.com");
console.log('Resolved did:web:', webDID);

// Resolve a did:key
const keyDID = await resolver.resolve("did:key:z6MkjdxYZ17j7DNPfgSB5LviYRxTCXPunZ5Vfbm5QKCEBVgt");
console.log('Resolved did:key:', keyDID);

// Resolve a did:peer
const peerDID = await resolver.resolve("did:peer:0z6MkqRYqQiSgvZQdnBytw86Qbs2ZWUkGv22od935YF4s8M7V");
console.log('Resolved did:peer:', peerDID);
```

### Working with DID Documents

```typescript
import { DIDDocument } from 'di-wings';

// Create a DID Document from a resolved DID
const didDocument = new DIDDocument(resolvedDID);

// Get verification methods
const verificationMethods = didDocument.verificationMethod;

// Get authentication methods
const authMethods = didDocument.authentication;

// Get key agreement methods
const keyAgreementMethods = didDocument.keyAgreement;

// Get a specific verification method by ID
const specificMethod = didDocument.getVerificationMethodById("did:example:123#key-1");

// Get a service by ID or type
const service = didDocument.getServiceById("did:example:123#service-1");
const didCommService = didDocument.getServiceByType("DIDCommMessaging");
```

### Managing Secrets

```typescript
import { Secret, JSONSecretResolver, EnvironmentVariableSecretResolver } from 'di-wings';

// Create a secret from a JSON object
const jsonSecret = new Secret({
  id: "did:example:123#key-1",
  type: "JsonWebKey2020",
  privateKeyJwk: { /* JWK data */ }
});

// Use a JSON-based secret resolver
const jsonResolver = new JSONSecretResolver({
  id: "did:example:123#key-1",
  type: "JsonWebKey2020",
  privateKeyJwk: { /* JWK data */ }
});

const resolvedSecret = await jsonResolver.resolve("did:example:123#key-1");

// Use an environment variable-based secret resolver
const envResolver = new EnvironmentVariableSecretResolver(process.env);
const envSecret = await envResolver.resolve("did:example:123#key-1");

// Convert a secret to a JsonWebKey2020
const jwk = await resolvedSecret.asJsonWebKey();
```

These examples demonstrate how to use the DID libraries in DI-Wings to work with Decentralized Identifiers, DID Documents, and manage secrets associated with DIDs. The library supports various DID methods and provides flexibility in how secrets are stored and resolved.

For more detailed documentation and advanced usage, please refer to the API documentation.

================
File: tsconfig.json
================
{
  "compilerOptions": {
    // Enable latest features
    "lib": ["ESNext", "DOM"],
    "target": "ESNext",
    "module": "ESNext",
    "moduleDetection": "force",
    "jsx": "react-jsx",
    "allowJs": true,

    // Bundler mode
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "noEmit": true,

    // Best practices
    "strict": true,
    "skipLibCheck": true,
    "noFallthroughCasesInSwitch": true,

    // Some stricter flags (disabled by default)
    "noUnusedLocals": false,
    "noUnusedParameters": false,
    "noPropertyAccessFromIndexSignature": false,

    // Decorators
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true,

    // Additional settings for module resolution
    "esModuleInterop": true,
    "resolveJsonModule": true,

    // Types
    "types": ["bun-types"]
  },
  "include": ["src/**/*", "global.d.ts"],
  "exclude": ["node_modules/**", "**/*.spec.ts"]
}
