**Objective:** Systematically identify, plan, and execute tasks using Taskmaster with an iterative, evidence-driven workflow. Provide rich, explicit context so the agent can operate autonomously with minimal back‑and‑forth. Prefer over‑specification of constraints, acceptance criteria, and examples.

**Workflow (Expanded):**

1.  **Identify Next Task:**
    *   Use the Taskmaster `next_task` tool (or `task-master next`) to fetch the next available task.
    *   Log the ID, title, priority, status, and dependencies.
    *   Summarize the task in one sentence and list 3–5 key risks/unknowns.

2.  **Understand Task Details:**
    *   Use `get_task` (or `task-master show [ID]`) to load full details.
    *   Extract and restate for shared context:
        - Problem statement and desired outcome
        - Functional and non‑functional requirements
        - Acceptance criteria (convert to a checklist)
        - Constraints (performance, security, compatibility, API stability)
        - External integrations and credentials needed
        - Data models, schemas, and API contracts affected
        - Rollout expectations (flags, migrations, docs)

3.  **Prepare and Execute Task (Iterative Cycle):**

    *   **A. Select Unit of Work:**
        *   If the main task has 'pending' subtasks, select the first one as the current unit of work and load its details.
        *   If no subtasks exist, the main task becomes the unit of work.
        *   If scope is unclear or large, use `expand_task` (or `task-master expand --id [ID] [--research]`) to split into coherent subtasks; then pick the first 'pending' subtask.
        *   Define scope in/out explicitly for this unit of work.

    *   **B. Plan Implementation:**
        *   Verify the target package/directory for the task. Scope all commands and edits accordingly.
        *   Produce a short design note including:
            *   Architectural approach and rationale (compare 2–3 alternatives briefly)
            *   Flow of control/data (bullets or sequence diagram)
            *   Backward compatibility and migration plan (if public APIs change)
            *   Security/privacy considerations (threat touch‑points)
            *   Observability plan (logs, metrics, telemetry events)
        *   Formulate a precise implementation plan:
            *   Files to create/modify
            *   Key functions, classes, or components to implement/change
            *   Core logic and data structures
            *   Edge cases and error handling strategy
            *   Rollout plan and feature flags (if applicable)
        *   Define a concrete Definition of Done (DoD) checklist:
            - All acceptance criteria met
            - Unit/integration tests implemented and passing locally
            - Lint, type‑check, and build succeed
            - Docs and changelog updated (if user‑facing)
            - Telemetry/error codes added for critical paths
        *   Append the design + plan to the unit of work using `update_subtask` or `update_task`.

    *   **C. Implement:**
        *   Set status to `in-progress` with `set_task_status` (or CLI equivalent).
        *   Implement in small, reviewable edits. After each edit:
            - Run lints and relevant tests
            - Verify types and build artifacts
            - Update telemetry where behavior changes
        *   Regularly document progress, decisions, and blockers via `update_subtask`/`update_task` to maintain an implementation log.

    *   **D. Complete, Reflect, and Document:**
        *   When the unit of work is functionally complete and verified:
            1.  **Reflection:** Briefly analyze scalability, maintainability, and operability:
                - Complexity hotspots and future risks
                - Performance implications (with rough estimates if useful)
                - Security/privacy considerations
                - Tech debt created/retired and follow‑ups
            2.  **Rules Update:** If new patterns or conventions emerged, add/update rules in `.cursor/rules/` per `cursor_rules.mdc` and `self_improve.mdc`.
            3.  **Set Status:** Mark the unit of work as `done` via `set_task_status`.
            4.  **Commit Changes:** Commit code and rule updates with a comprehensive message referencing the ID (e.g., `feat: Implement X for task/subtask [ID] – rationale… – rules updated…`).
            5.  **Post‑merge Check:** Ensure CI passes and publish artifacts are healthy (if applicable).

4.  **Continue or Fetch New Task:**
    *   If the parent task has more 'pending' subtasks, repeat step 3 for the next one.
    *   If the parent task is fully done, return to step 1 to fetch a new task.
    *   If `next_task` indicates no tasks remain, the process is complete.

**General Guidelines (Expanded):**
*   Follow the iterative process above; prefer many small steps over one large step.
*   AI‑powered Taskmaster tools may be long‑running; prefer MCP tools when available, else use CLI.
*   If requirements are unclear, list assumptions, required clarifications, and a proposed default plan. Proceed with safe defaults while awaiting input where possible.
*   Prioritize maintainability, scalability, security, and documentation.
*   Ensure you are not re‑implementing existing functionality; search first.

---

### Checklists

**Acceptance Criteria Template**
- [ ] Happy path verified with realistic data
- [ ] Edge cases handled (empty, large, malformed inputs)
- [ ] Errors use StructuredError codes and include telemetry
- [ ] Backward compatibility preserved or migration documented
- [ ] Performance baseline measured or reasoned

**Test Strategy Template**
- Unit tests for new logic and error branches
- Integration tests with mocks for external systems
- Contract tests for public APIs/types if changed
- Regression tests for fixed bugs

**Observability Template**
- Emit telemetry events for critical operations
- Use StructuredError for failure modes with stable codes
- Avoid secrets in logs; use stable fields for correlation

---

### Examples

"Edge Cases" for pagination API
- page=0, pageSize=0 → 400
- page=max, pageSize=1 → last page returns ≤1 item
- pageSize>1000 → clamp to 1000 and emit warning telemetry

"StructuredError" codes
- CONFIG_UNSUPPORTED_KEY_TYPE
- ORD_PROVIDER_INVALID_RESPONSE
- STORAGE_PUT_FAILED